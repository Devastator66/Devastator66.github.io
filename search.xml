<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021新年展望（辛丑）</title>
    <url>/2021/01/04/2021%E6%96%B0%E5%B9%B4%E5%B1%95%E6%9C%9B%EF%BC%88%E8%BE%9B%E4%B8%91%EF%BC%89/</url>
    <content><![CDATA[<p>元旦是总结过去，展望未来的日子，对于我来说，从来都没这样做过。今年可能是老了，也可能是混的不满意，觉得必须做点什么或改变点什么了。</p>
<a id="more"></a>

<p>其实在五年前，入职当前的工作时，有过一些打算。直到今天，从结果上可以说：实现的不怎么样。这里面的原因有很多，就我个人而言，有如下几点：</p>
<ol>
<li>目标太模糊，没什么前进动力；</li>
<li>追求安逸自在，没追求经济效益；</li>
<li>太重视技术，忽视了人际关系；</li>
<li>学的东西多，只当作吹牛的资本，没在社会实践中使用；</li>
<li>容易情绪化，不能淡定的对待宠辱。</li>
</ol>
<p>今后一定要引以为戒，不能再这么下去了！</p>
<p>这几年社会环境也不怎么样，值得一提的事件有：</p>
<ol>
<li>2016年房地产涨价去库存，互联网上再也没人唱空房价了；</li>
<li>2017年中国裁军30万，以及国企去杠杆（进而导致陆续裁员）；</li>
<li>2018年中美贸易战开始；</li>
<li>2019年中美贸易战继续，国企推进混改；</li>
<li>2020年新冠肺炎蔓延全球，中国砖家提出了内循环的概念。</li>
</ol>
<p>当前，美国大选刚刚结束，拜登当选，特朗普赖在白宫不走。无论是谁笑到最后，西方社会都不会善待中国。内循环在政治经济角度不是一个很好的概念，很容易让人联想到<strong>内卷</strong>。</p>
<p>过去就总结到此，下面该展望未来了。未来该怎么说呢？任何一个人都希望能过得更好。客观上讲，那不是个人能左右的，年龄越大越能感到命运之力。所以只能将自己修好，并期望上天眷顾。</p>
<p>2021年要完成的事如下：</p>
<ol>
<li>学会Python</li>
<li>通过软考高级</li>
<li>取得驾照</li>
</ol>
<p>希望能做到的事如下：</p>
<ol>
<li>在股市上赚到钱</li>
<li>能顺利转行</li>
<li>广结善缘</li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年终总结</title>
    <url>/2022/01/03/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>既然在年初写了计划，在年终还是总结一下吧。总的来说还是那句老话——计划赶不上变化。这一年工作上发生了不少事情，很多同事在公司管理大变革中表现得极不适应。我所在的部门更是处在一个岌岌可危的境地，好在我有一定的准备，经过一系列辗转腾挪后，算是得了个善果。</p>
<a id="more"></a>

<p>经过这个过程后，我的感悟是：外界环境真的很难改变，能改变的真的就只有自己，改变自己是真的不容易。环境上的任何改变本质上没有好坏，正确的处理方式就是顺势而为。平时学习和积累经验的意义在于预见问题，清楚自己和周围人的“位置”，知道自己该做什么。</p>
<p>凡事都具有客观规律，客观规律往往是简单的，但我们身处具体事件之中，难以洞察到事件的全貌，以至于走的太远无法回头。所以说，活到老学到老，平日应始终保持虚心的态度。</p>
<p>现在谈谈年初计划要完成的和希望完成的几件事：</p>
<ol>
<li>最开始计划学会的是FPGA，后来由于工作变故放弃了。</li>
<li>五月如期参加了系统分析师考试，遗憾的是没有通过。</li>
<li>小时候晕车，长大以后对汽车始终提不起兴趣，上班乘坐公交也挺顺，所以…拖来拖去，直到今日也没报名。</li>
<li>今年工作忙，没有看盘的时间和精力，又不敢“闭着眼”投资，一直空仓，结果自然是没赚到钱。</li>
<li>转行没转成，公司倒是换了一家，工资翻倍了。</li>
<li>最后一项很难量化，新认识了很多人，但不知道算不算朋友。</li>
</ol>
<p>可以说一项也没做到。这一年的大环境怎么样呢？从2018年贸易战那时就有人说：今年肯定是苦了点，明年就好了，要相信政府有能力……同时也有人说，2018将是最好的一年，以后一年不如一年……</p>
<p>特朗普虽然找到了帝国软肋——经济，但是不懂得“集中力量办大事”的原则，连盟友一并制裁，力量分散了。拜登上台后，秉承着民主党的激进意识形态，联合盟友“围攻”帝国。这次采用的方式不只是派几条船过来搞搞军演，还要将帝国从国际贸易体系中踢下车。不过，美国今年疫情仍旧冠绝全球，只能将大部分的精力放在国内。</p>
<p>当然了，帝国这边必然不会躺平，除了大力宣传当年抗美援朝的英勇事迹，同时也着手处理这些年内部的重重矛盾。从2020年开始，出现了一个概念——内循环。其实，内循环一直都存在，不一样的是各个环节，以及如何循环。作为一个百姓，近几年感受到的内循环就是：<strong>控制供给，刺激消费</strong>。</p>
<p>供给：以一种相对合理的理由提高市场准入门槛，控制供给数量，比如各种行业准入执照、产业升级、高质量发展等等。需求：利用社会舆论导向激发需求，比如前途、loser、爱国、健康等等。动力：通过货币供给，定向定量调节。很明显，这是一种人为驱动的循环。</p>
<blockquote>
<p>向青年人贩卖希望，向中年人贩卖焦虑，向老年人贩卖健康。</p>
</blockquote>
<p>帝国采用定向放水、供给侧改革、扩大内需等方法，虽然维护住了资产价格和债务循环，但代价是越来越慢的货币流通速度。社会逐渐失去活力，生育率逐年下降，居民欲望降低躺平。</p>
<blockquote>
<p>天之道，损有余而补不足；人之道则不然，损不足以奉有余。——《道德经》</p>
</blockquote>
<p>沙漏型的社会形态，上游通胀，下游通缩，两头都不好过，还不好处理。治本的方法很明显，但不敢用！如果此时<strong>加息</strong>捅破上游泡沫，一方面会导致大量债务违约，另一方面会触发资本避险，大量“聪明钱”会涌入关系民生的大宗商品。两个方面同时发力，必然会动摇社会稳定。最终，技术型官僚只能绞尽脑汁想出一些治标的方法，将一些“问题”冻结，留待未来处理。</p>
<blockquote>
<p>否卦：大往小来，上下不交而天下无邦也。</p>
</blockquote>
<p>前几年，国家一直隐晦的提醒这些资本家。部分人比较识时务，立刻就意识到了问题的严重性，及早开始处理；另一部分资本家大概是认为凭借自身的<strong>转嫁</strong>能力，可以让国家投鼠忌器，结果：</p>
<ol>
<li>4月10日市场监管总局依法对阿里巴巴集团控股有限公司在中国境内网络零售平台服务市场实施”二选一”垄断行为作出行政处罚，责令阿里巴巴集团停止违法行为，并处以其2019年中国境内销售额4557.12亿元4%的罚款，计182.28亿元。</li>
<li>7月24日中共中央办公厅、国务院办公厅印发《关于进一步减轻义务教育阶段学生作业负担和校外培训负担的意见》。优胜教育资金链断裂，陈昊甩锅老母；新东方美股从180多块跌到1块多，营收减少80%，辞退6万员工。</li>
<li>9月8日，从恒大财富宣布延期兑付本金开始，恒大的债务危机迅速升级，掀开了恒大集团高达2万亿的债务问题。</li>
<li>11月15日发布《国务院反垄断委员会关于原料药领域的反垄断指南》。加上医药集采政策，今年医药板块跌跌不休，医药基金全年收益是负的，其中医疗服务、外包股表现最差。</li>
<li>11月18日国家反垄断局正式挂牌成立。</li>
<li>12月20日网络主播黄薇（薇娅）在2019至2020期间偷税被罚13.41亿。经过司马南披露，薇亚背后的投资公司有阿里和联想。司马南视频有一个系列，专门讲联想搞金融转移国有资产和小额放贷。</li>
</ol>
<p>除了阿里巴巴集团，还有很多互联网巨头受到处罚，遏制资本无序扩张成了网上热门语言。可能是国家出于对内外环境恶化的预期，为预防2022年可能出现的系统性风险，提前挤掉某些领域的一些水分。另外，也让某些资本家知道：国家经济政策不只是放水和劝诫。</p>
<p>其他值得一提的事件：</p>
<ol>
<li>2020年12月2日，美国国会众议院表决通过《外国公司问责法案》，要求在美国上市的外国公司，证明不受外国政府拥有或掌控，需要遵循美国的审计标准，披露某些额外信息。这直接使得中概互联公司陷入两难境地，全年股价一泻千里。</li>
<li>7月20日《关于优化生育政策促进人口长期均衡发展的决定》发布，正式放开了三孩生育政策。</li>
<li>广东电网自9月16日起，执行“开二停五”用电方案。自此之后有十多个城市开始限电。</li>
<li>全年没有香港动荡方面的消息。</li>
</ol>
<p>唉…就说到这吧，日子难过，但还得继续，期望来年工作顺利，学有所成，发笔大财！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Antlr4环境搭建</title>
    <url>/2017/03/16/Antlr4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Antlr由Java语言编写，能够根据用户定义的语法文件自动生成词法分析器和语法分析器。</p>
<a id="more"></a>

<h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><p>一、登录官网<a href="https://www.antlr.org/">https://www.antlr.org/</a>，下载antlr-4.6-complete.jar。这个就是主程序，需要JDK和JRE支持。</p>
<p>二、添加两个批处理文件</p>
<ul>
<li>antlr4.bat: <code>java org.antlr.v4.Tool %*</code></li>
<li>run.bat: <code>java org.antlr.v4.runtime.misc.TestRig %*</code></li>
</ul>
<p>三、把上述三个文件都放入同一个文件夹，例如E:\Tools\Antlr4.6，并添加环境（系统）变量</p>
<ul>
<li>CLASSPATH: <code>.;E:\\Tools\\Antlr4.6\\antlr-4.6-complete.jar;</code></li>
<li>Path: <code>E:\\Tools\\Antlr4.6;</code></li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>新建文件Hello.g4，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grammar Hello;          #必须与文件名一致</span><br><span class="line">r   :   &#39;hello&#39; ID;</span><br><span class="line">ID  :   [a-z]+;</span><br><span class="line">WS  :   [ \t\r\n]+ -&gt;skip;</span><br></pre></td></tr></table></figure>
<p>执行编译，打开CMD，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 目标文件目录</span><br><span class="line">$ antlr4 Hello.g4       #会生成一堆文件</span><br><span class="line">$ javac Hello*.java     #所以需要JDK</span><br></pre></td></tr></table></figure>
<h4 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h4><p>一、显示文字样式的语法树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ run Hello r -tree     #回车后，要求输入测试样例</span><br><span class="line">hello world             #回车</span><br><span class="line">^z                      #ctrl+z，回车</span><br></pre></td></tr></table></figure>
<p>可看到结果：(r hello world)。</p>
<p>二、显示图形样式的语法树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ run Hello r -gui</span><br><span class="line">hello world             #样例</span><br><span class="line">^Z                      #回车</span><br></pre></td></tr></table></figure>
<p>会弹出一个窗口，显示样例的语法树图形。</p>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>2022新年展望（壬寅）</title>
    <url>/2022/01/11/2022%E6%96%B0%E5%B9%B4%E5%B1%95%E6%9C%9B%EF%BC%88%E5%A3%AC%E5%AF%85%EF%BC%89/</url>
    <content><![CDATA[<p>新的一年又开始了，虽然去年发生了很多事情，还曾一度觉得度日如年，但一路走过来，仍旧有一种“一晃又一年”的感觉。虽说去年计划中的事情都没实现，但我觉得写一个年初计划还是有好处的。计划其实就是尺度，当得到结果时，可以审视自己偏离了多少，以此来发现自身的问题。</p>
<a id="more"></a>

<p>去年计划中，对自己归纳了五点，现在回顾一下：</p>
<ol>
<li>前进的动力是有了，但目标仍旧模糊。我觉得问题没出在自己身上，当前环境中的凡人，除了躺平的，可能都是如此。这大概是个认识自己的过程，就像《五轮书》空篇说的：“每日刻苦练习，渐渐排除内心困惑，直到有一天心中一片澄明”。</li>
<li>追求安逸自在不是错误，而且与追求经济效益不矛盾。现在看的更清楚了，只有财富自由，才能真正的安逸自在。</li>
<li>技术还得坚持学习，人际关系也得注意，重要的是认识自己，知道自己擅长什么，不擅长什么，努力强化自己的强项，敢于放弃自己的弱项。</li>
<li>只有站在更高的位面理解知识，才能在实践中灵活运用。文史类知识必须结合自身实践经验来理解；理工类知识只有自己重新发明或发现一遍，才能真正理解。另外，先要消除自己那颗虚荣心，才能管好嘴。</li>
<li>控制情绪很难，真正做到的没有几人。有效的方法有几种，但个人觉得最有意义的一种是：提前洞察，客观理解，对大环境有一定地把握，当面对“细节”问题时自然没有情绪。</li>
</ol>
<p>在做自己的计划前，最好先看看国内外大环境！这不是开玩笑，很多小企业主或“二代型”领导不看环境，订立一堆不切实际的目标，完全就是自取灭亡。</p>
<p>美国新冠疫情仍旧严重，先是德尔塔变异株，最近又出了奥密克戎。这个变异株毒性弱，但传染性强，对于美国这种“国家讲人权，人民讲自由”的国度，简直就是灾难，就10日一天新增新冠病例148.3万例。所以，今年上半年美国应该没空恶心帝国。欧洲各国不用说了，在疫情方面跟美国一样。</p>
<p>不过在全球化的大环境下，各国遇到的问题即同步，又类似。目前，帝国大陆还没爆发像美国那样的混乱，但其内部也是矛盾重重亟待解决。</p>
<ol>
<li>房地产一直是个问题，在帝国当资本家剥削工人不如当地主收资本家的地租。去年恒大2W亿暴雷，不少大V跳出来唱空楼市赚取流量，年底有关部门提出稳定房地产市场。另外，今年可能会进行房产税试点。</li>
<li>服务业相对于第一、二产业对国民生活没有那么必须，而且资产较轻易于整合。在互联网公司的加持下，传统服务业中的众多行业纷纷走向整合之路，资本迅速聚集，出现了垄断苗头。服务业逐渐显现出金融属性，加上其固有的非必须性，为经济带来了不稳定性。去年，帝国对众多互联网公司进行了处罚，并在年底成立反垄断局；年底中央经济工作会议提出，要正确认识和把握资本的特性和行为规律，要为资本设置“红绿灯”。</li>
<li>去年美国CPI上涨7%，为1982年以来涨幅最大的一次。涨幅主要来自汽车、能源和住房价格。美联储可能会提前加息，以应对通胀。帝国中央经济工作会议定调今年25个稳字。稳的是什么？归根到底就是社会，具体执行还得围绕着就业。</li>
</ol>
<p>如上所示，2022年的经济预期不算好，虽然十四五规划提到发展科技，发展高端制造业等等，但发展这些产业要比发展服务业困难太多。工业、科技不像服务业，离消费端较远，受<strong>人为刺激需求</strong>的影响弱。任何企业发展要看盈利，企业没法在没有客观需求的市场发展。所以，即使国家肯砸钱，恐怕短期内也不会有显著效果。</p>
<p>2021年，由于工作较忙，变动较大，人心浮躁，没怎么学习。但这也没办法，毕竟忙于事务，就会导致没工夫学习；天天不问世事，确实适合学习，但是不适合当前社会。如何调整好心态，快速适应变化的环境并分配好时间，需要一定的决心和方法。</p>
<p>2022年要完成的事如下：</p>
<ol>
<li>掌握Python Web开发和爬虫技术</li>
<li>通过“项目管理师”考试</li>
<li>形成自己的股市交易体系</li>
</ol>
<p>希望能做到的事如下：</p>
<ol>
<li>每日11:30前入睡</li>
<li>坚持锻炼身体，跳绳或徒手健身</li>
<li>广结善缘</li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基本配置</title>
    <url>/2007/11/28/CSS%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>CSS（Cascading Style Sheets）层叠样式表，主要用于设置网页的样式，通常与HTML的空标签div配合使用。使用css可集中添加样式，因此更易于维护。</p>
<a id="more"></a>

<h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p>1.直接在html各种标签内联，例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;margin-left:30px&quot;</span>&gt;</span></span><br><span class="line">hello,world!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.直接在html文件的head标签内写入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      选择器1 &#123;</span><br><span class="line"><span class="css">            属性1:属性值; <span class="comment">/* 注释 */</span></span></span><br><span class="line">            属性2:属性值;</span><br><span class="line">            ...</span><br><span class="line">      &#125;</span><br><span class="line">      选择器2 &#123;</span><br><span class="line">            属性1:属性值;</span><br><span class="line">            属性2:属性值;</span><br><span class="line">            ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.将样式定义在一个.css文件中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器1 &#123;<span class="comment">/* 不需要style标签 */</span></span><br><span class="line">      属性1:属性值;</span><br><span class="line">      属性2:属性值;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">选择器2 &#123;</span><br><span class="line">      属性1:属性值;</span><br><span class="line">      属性2:属性值;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后在html文件的标签内链入css文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件url&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>4.导入css文件<br>把一个css文件导入html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">	<span class="keyword">@import</span> url(css文件url);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把一个css文件导入css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(css文件url);<span class="comment">/* 就是去掉了style标签 */</span></span><br></pre></td></tr></table></figure>
<p>5.总结<br>第2-4种方法都需要指定“选择器”，然后通过选择器使设置生效。<br>优先级：内联 &gt; 导入，导入顺序越靠后，优先级越高。</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>1.html标签<br>直接用标签作为选择器，使得每次使用标签会附带设置的样式。</p>
<p>2.class属性</p>
<ul>
<li>定义样式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blue-text</span> &#123;<span class="comment">/* 类名 */</span></span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用样式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">blue-text</span>&gt;</span>显示蓝色的字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
1)在定义样式时，类名前要有点。<br>2)class可以有多个值，class=”类名1 类名2 …”，对应设置了多种样式。</li>
</ul>
<p>3.ID属性</p>
<ul>
<li>定义样式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#red-text</span> &#123;<span class="comment">/* id */</span></span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用样式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">red-text</span>&gt;</span>显示红色的字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
1)在定义样式时，id前要有#。<br>2)每个标签的id只能有一个值。</li>
</ul>
<p>4.总结<br>样式的继承：内层标签会继承外层标签的样式<br>优先级：id &gt; class &gt; 标签</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>颜色：#RRGGBB（十六进制表示），rgb(255,255,255)<br>单位：px pt % em 2em cm mm in</p>
<p>1.字体<br>font-family:courier,times…;可定义多种，应对字体不存在的情况<br>font-size:4cm/12px/150%;长度，百分比<br>font-style:italic/normal/oblique;斜体，普通，倾斜<br>font-weight:normal/900/bold/lighter;加粗<br>font-variant:normal/small-caps;普通，小型大写字母</p>
<blockquote>
<p>按照顺序style variant weight size familiy设置字体</p>
</blockquote>
<p>2.文本<br>letter-spacing:0.5cm;字符间隔，可以为负<br>word-spacing文字间隔，可以为负<br>text-decoration:overline/underline/line-through/none;上划线、下划线、删除线、去掉线<br>text-align:left/right/center;左右中<br>text-indent:0.8cm;缩进<br>line-height行高，不能使用负值<br>text-transform:uppercase/lowercase;大写、小写</p>
<p>3.背景（默认平铺）<br>background-color:yellow;<br>background-image:url(地址);<br>background-repeat/repeat-x/repeat-y/no-repeat;重复、水平、垂直、不重复（针对图片）<br>background-position:top/bottom/center/left/right;横纵向的背景位置<br>background-attachment:fixed/scroll;当滚动滑轮时，背景固定、滚动</p>
<blockquote>
<p>按照顺序color image repeat attachment position设置背景</p>
</blockquote>
<p>4.边框<br>border-style:none没边框、dotted点线、dashed破折线、solid实线、double双线、groove槽线、ridge脊线、inset内嵌效果、outset突起效果。<br>border-width:1px;设置边框宽度<br>border-color:red;<br>border-top/right/bottom/left-color单独设置四边的样式、宽度、颜色</p>
<blockquote>
<p>如果只设置了四条边（上右下左）的某条，省略的边则与对边相同。<br>按照顺序width style color设置边框</p>
</blockquote>
<p>5.列表（针对列表标签）<br>list-style-type:<br>无序disc/circle/square/none;<br>有序decimal/lower-roman/upper-roman/lower-alpha;</p>
<h4 id="css和div布局"><a href="#css和div布局" class="headerlink" title="css和div布局"></a>css和div布局</h4><p>div默认换行，span默认不换行，这两种标签都没有效果，都被用来配合css使用。span一般用于小块，div一般用于大块。通过嵌套使用div对页面进行分块，来完成各种布局。</p>
<p>1.盒子的概念<br>每个HTML元素都可以看作一个装了东西的盒子，盒子具有width、height。盒子里面的东西到盒子边框的距离称为padding；盒子边框到外层盒子边框之间的距离称为margin。</p>
<p>2.布局中常用的属性<br>font、color、height、width、border、text-align、background。<br>margin可以为百分比，以上级盒子宽度为基准，可以为负。布局前可以对body的margin（上右下左）清零。</p>
<p>3.定位Position</p>
<ul>
<li>absolute生成绝对定位的元素，将元素从文档流中拖出来，不占用原来元素的空间，相对于其最接近的一个具有定位属性的父级元素定位。如果不存在就逐级向上排查，直到相对于body元素，即浏览器窗口。</li>
<li>relative生成相对定位的元素，相对于其正常起点的位移。在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。</li>
<li>fixed生成绝对定位的元素，相对于浏览器窗口进行定位。</li>
<li>static默认值。没有定位，元素出现在正常的流中。</li>
</ul>
<blockquote>
<p>以上都是通过top/Left/right/bottom属性完成定位。</p>
</blockquote>
<p>4.浮动</p>
<ul>
<li>float:left/right;块会脱离当前文档流进行左右浮动，直到它的外边缘碰到包含框或另一个浮动框为止。</li>
<li>clear:left/right/none/both;定义块的哪边不能挨着浮动框。</li>
</ul>
<blockquote>
<p>可以单独设置一个clear块，把它插入到某个位置来清除各种浮动。</p>
</blockquote>
<h4 id="总体设置"><a href="#总体设置" class="headerlink" title="总体设置"></a>总体设置</h4><ol>
<li><p>css放一个目录，image放一个目录，按照样式类型建立css文件，然后在html中链接。</p>
</li>
<li><p>先设置body样式：清除内外边距margin、padding，设置font。在最外层块中设置分辨率，以宽度为准（1024*768）width、height，要减去滚动条。</p>
</li>
<li><p>将内层分成页眉、主体、页脚三个块，通过属性width、height、background完成。在三个块间可设置分割条，通过<code>clear:both</code>完成。IE默认的最小像素为18px，可以设置<code>overflow:hidden</code>来隐藏超出部分。</p>
</li>
<li><p>把页眉部分分成三块logo、banner、tool。把这三个样式分别与页眉样式关联，默认会自动换行，必须添加float属性。再在其中挤进一条菜单，<code>clear:both</code>，最好也设置为浮动。</p>
</li>
<li><p>用列表定义菜单项，ul属性margin和padding要清0，list-style:none。在li中设置属性width和float后会水平显示，同时可设置文字行高和居中。在每项间可添加分隔线，定义一个width:1px的样式，在各列间添加空li，把这个样式给它们。</p>
</li>
<li><p>把主体分成2或3列，仍旧通过属性width,height,float完成。左右块的float分别设置成left和right，中间就会留出间隔条。</p>
</li>
<li><p>在块中添加图片：先定义个块，在其样式中用<code>background:url();</code>添加图片。当一张图片过长时，可以使用<code>background:url() no-repeat left/right;</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML常用标签</title>
    <url>/2007/11/22/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>HTML（Hyper Text Markup Language）超文本标记语言，用来构建网页最基本功能。</p>
<a id="more"></a>

<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	   头部 <span class="comment">&lt;!--不在页面中显示--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	   主体 <span class="comment">&lt;!--放要显示的内容--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="头部标签"><a href="#头部标签" class="headerlink" title="头部标签"></a>头部标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span> <span class="comment">&lt;!--设置当前文本的编码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="主体标签"><a href="#主体标签" class="headerlink" title="主体标签"></a>主体标签</h4><p>1.文本标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hn</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">hn</span>&gt;</span> <span class="comment">&lt;!--自动换行，n=1~6，一个页面内h1最多放一个--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">字体</span> <span class="attr">color</span>=<span class="string">颜色</span> <span class="attr">size</span>=<span class="string">大小</span>&gt;</span>设置字体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.格式标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>居中<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">width</span>=<span class="string">宽度</span> <span class="attr">size</span>=<span class="string">高度</span>&gt;</span> <span class="comment">&lt;!--居中水平分割线，可使用百分数，会随着网页大小变化--&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.超链接标签</p>
<ul>
<li><p>基本链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">https://www.baidu.com</span> <span class="attr">target</span>=<span class="string">&quot;_self/_blank&quot;</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">a</span>&gt;</span>	<span class="comment">&lt;!--绝对路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./hello world.txt&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self/_blank&quot;</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">a</span>&gt;</span>	<span class="comment">&lt;!--相对路径--&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>锚点链接（页内跳转）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;锚点名&quot;</span>&gt;</span>段落标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#锚点名</span>&gt;</span>返回段首<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span>&gt;</span>返回页首<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>4.图像标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">url</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>img属性</p>
<ul>
<li>border：边框宽度，如果不要边框设置为0。</li>
<li>width/height：设置的不合适会失真。</li>
<li>alt：当鼠标放到图片上或图片加载失败时提示的内容，搜索引擎会根据这个文字搜索到图片。</li>
</ul>
<p>5.列表标签</p>
<ul>
<li>无序列表<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>有序列表<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>6.表格标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">caption</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span>	<span class="comment">&lt;!--行--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>字段1<span class="tag">&lt;/<span class="name">th</span>&gt;</span>	<span class="comment">&lt;!--标题，字体加粗显示--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>字段2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>字段3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span>	<span class="comment">&lt;!--列--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>table属性<br>align：left，center，right<br>border：默认无边框<br>width：格的宽度<br>height：格的高度<br>cellspacing：格与格的间距<br>cellpadding：文字与格的间距<br>bgcolor：背景颜色<br>bordercolor：边框颜色<br>bordercolorlight：边框亮面</p>
</li>
<li><p>tr属性<br>align，valign，bgcolor</p>
</li>
<li><p>td/th属性<br>width：会影响同列<br>height：会影响同行<br>align：left，center，right<br>valign：top，middle，bottom<br>colspan：当前格占几列<br>rowspan：当前格占几行</p>
</li>
</ul>
<p>7.表单标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">控件类型</span> <span class="attr">name</span>=<span class="string">变量名</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>form属性<br>name：表单名<br>action：表单内容提交到哪（URL）<br>method：提交方式：get一堆缺点，一般用post。<br>target：提交后返回的结果在哪个窗口显示<br>title：当鼠标悬停在表单上出现的内容</p>
</li>
<li><p>input属性<br>name：变量名<br>size：框体宽<br>value：默认值<br>type：</p>
<ul>
<li>text文本框</li>
<li>password密码框</li>
<li>submit提交按钮</li>
<li>reset重置按钮</li>
<li>button按钮，需要配合Javascript使用。</li>
<li>checkbox复选框，如果需要同时操作，相应的name用数组表示。checked表示选中。</li>
<li>radio单选框，一个组name相同。checked表示选中。</li>
<li>hidden定义隐藏字段。隐藏字段对于用户是不可见的。</li>
<li>file上传文件</li>
</ul>
</li>
</ul>
<p>8.下拉列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">size</span>=<span class="string">&quot;&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>项<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>select属性<br>name：变量名<br>size：如果有这个属性会以列表形式显示<br>multiple：可多选，也会以列表形式显示。</p>
</li>
<li><p>option属性<br>value：有这个属性会提交它的值，没有则提交项。<br>selected：标记选中</p>
</li>
</ul>
<p>9.图像地图<br>用于设置一个图片的不同区域对应不同的链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;路径/图片名.jpg&quot;</span> <span class="attr">usemap</span>=<span class="string">#标记名/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">标记名</span> <span class="attr">id</span>=<span class="string">标记名</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;rect&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;10,10,20,20&quot;</span> <span class="attr">href</span>=<span class="string">跳转url1</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;35,35,10&quot;</span> <span class="attr">href</span>=<span class="string">跳转url2</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>shape为rect，coords为对角线坐标（上x，上y，下x，下y）。<br>shape为circle，coords为圆心坐标和半径长度（x,y,r）。<br>shape为poly，coords为各定点坐标（x1，y1，x2，2y，…）。</p>
<p>10.符号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;	<span class="symbol">&amp;lt;</span></span><br><span class="line">&gt;	<span class="symbol">&amp;gt;</span></span><br><span class="line">&amp;	<span class="symbol">&amp;amp;</span></span><br><span class="line">&quot;	<span class="symbol">&amp;quot;</span></span><br><span class="line">￥	<span class="symbol">&amp;yen;</span></span><br><span class="line">$	<span class="symbol">&amp;sect;</span></span><br><span class="line">© 	<span class="symbol">&amp;copy;</span></span><br><span class="line">®	<span class="symbol">&amp;reg;</span></span><br><span class="line">×	<span class="symbol">&amp;times;</span></span><br><span class="line">÷	<span class="symbol">&amp;divide;</span></span><br><span class="line">空格	<span class="symbol">&amp;nbsp;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>DDR内存</title>
    <url>/2021/08/21/DDR%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>家中一台用了十多年的计算机已经很慢了，但是仍旧没有坏的迹象，扔了可惜，于是决定买根内存升级一下。首先需要确定内存的型号，拆开后盖找到内存，黏贴的标识上没有型号，只能根据缺口的位置上网查了。</p>
<p>本篇文章将便携式计算机和台式兼容机所使用的DDR内存相关信息总结于此，以方便将来查阅。</p>
<a id="more"></a>

<p>初代DDR内存工作电压为2.25V，工作频率为333MHz、400MHz，笔记本上用的DDR针脚数（俗称的金手指）为200个（台式DDR内存有180针脚）。</p>
<p>DDR2内存工作电压为1.8V，工作频率从667MHZ到1066MHZ，笔记本上用的DDR2针脚数为200个（台式DDR2内存有240个针脚）。</p>
<p>DDR3内存工作电压为1.5V，工作频率有1066、1333、1600、1800、1866、2000MHZ，笔记本上用的DDR3内存只有1066MHz，有204个针脚。</p>
<p>台式兼容机DDR内存对比图：</p>
<p><img src="https://i.loli.net/2021/08/28/SqLJ3hsrGjHwRWz.png" alt="1台式.png"></p>
<p>便携式计算机DDR内存对比图：</p>
<p><img src="https://i.loli.net/2021/08/28/z3HDrWob4Cy2Jgd.png" alt="2便携式.PNG"></p>
]]></content>
      <categories>
        <category>PC</category>
      </categories>
      <tags>
        <tag>PC</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址与子网划分</title>
    <url>/2008/12/16/IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>计算机网络的三大功能：信息交换、资源共享、分布式处理。按结构分为两类：</p>
<ol>
<li>对等网（peer to peer），没有专门的计算机充当客户机或服务器。</li>
<li>基于服务器的网络。<a id="more"></a>

</li>
</ol>
<h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>我们当前使用的就是这种格式的IP地址，由一个32位二进制数表示。为了方便，将其划分为4个字节，每字节由十进制数表示，形如W.X.Y.Z。每个IP由两部分组成：网络号和主机号，由此分为5类：</p>
<ul>
<li>A类，<code>0 &quot;7位网络号&quot; &quot;24位主机号&quot;</code>，$W\in [1,126]$，支持126个网络，每个网络支持$2^{24}−2=16777214$台计算机。</li>
<li>B类，<code>1 0 &quot;14位网络号&quot; &quot;16位主机号&quot;</code>，$W\in [128,191]$，支持$(191−128+1)×256=16384$个网络，每个网络支持$2^{16}−2=65534$台计算机。</li>
<li>C类，<code>1 1 0 &quot;21位网络号&quot; &quot;8位主机号&quot;</code>，$W\in [192,223]$，支持$(223−192+1)×256×256=2097152$个网络，每个网络支持$2^8−2=254$台计算机。</li>
<li>D类，<code>1 1 1 0 &quot;组播地址&quot;</code>，$W\in [224,239]$。</li>
<li>E类，<code>1 1 1 1 &quot;保留&quot;</code>，$W\in [240,254]$。</li>
</ul>
<p>W=127表示本机地址。上述“支持计算机台数”都减2是因为每个网络的第一个IP代表本网，最后一个代表广播地址。例如192.168.1这个网络，192.168.1.0就代表本网，192.168.1.255保留给广播。</p>
<h4 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h4><p>为满足内网的使用需要，保留了一部分不在公网使用的IP地址，如下：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="left">IP地址范围</th>
<th align="left">网络号</th>
<th align="center">网络数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A类</td>
<td align="left">10.0.0.0 ~ 10.255.255.255</td>
<td align="left">10</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">B类</td>
<td align="left">172.16.0.0 ~ 172.31.255.255</td>
<td align="left">172.16 ~ 172.31</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">C类</td>
<td align="left">192.168.0.0 ~ 192.168.255.255</td>
<td align="left">192.168.0 ~ 192.168.255</td>
<td align="center">256</td>
</tr>
</tbody></table>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>划分原理是非常简单的，就是在主机号域划分出几位作为子网号，由此一个IP地址从两部分变为三部分：网络号、子网号、主机号。好处在于可灵活定义子网标识的位数，来控制每个子网的规模。</p>
<p>子网由子网掩码进行标识。网络和子网部分全为1，主机部分全为0。判断两台计算机是否在同一子网内，需要用到子网掩码，其方法是将两个IP地址与给定的子网掩码分别进行逻辑与运算，如果结果相等，则属于同一个子网，否则就不属于同一个子网。</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>由一个128位二进制数表示，优点如下：</p>
<ol>
<li>更大的地址空间。</li>
<li>使用更小的路由表，用一条记录就可表示一个子网。</li>
<li>增强了组播支持和对流的支持。</li>
<li>加入了对自动配置的支持。这是对DHCP协议的改进和扩展。</li>
<li>具有更高的安全性。</li>
</ol>
<blockquote>
<p>当前并未普及。</p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发环境部署</title>
    <url>/2009/10/05/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>部署Java开发环境很容易，但需要记忆，每次都上网搜不如自己做好记录。</p>
<a id="more"></a>

<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><ol>
<li>从官网<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a>下载jdk。</li>
<li>为jdk选择路径\Java\jdkXXX.XXX；然后安装jre，选择路径\Java\jreXXX.XXX。</li>
</ol>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ol>
<li>新建系统环境变量JAVA_HOME，值为<code>X:\...\java\jdkXXX.XXX</code>。</li>
<li>在用户环境变量path中，增加<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</code>。</li>
<li>新建系统环境变量classpath，值为<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code>。（可选）</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ol>
<li>为了代码能够执行，在源文件中必须包含一个public的main函数，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译：javac fileName.java，会得到一些*.class文件。</li>
<li>运行：java fileName（不要扩展名）。</li>
</ol>
<blockquote>
<p>每个Java源文件至多有一个public类，且必须与public类同名。如果没有public类，那么文件名随意。</p>
</blockquote>
<h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><ol>
<li>Eclipse最常用</li>
<li>IntelliJ IDEA功能最强大</li>
<li>选择自己喜欢的一款支持语法高亮的编辑器</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex排版一 概述</title>
    <url>/2017/11/03/LaTex%E6%8E%92%E7%89%88%E4%B8%80%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>LaTeX是一种基于ΤeΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发。由于具有TeX的基因，一方面它特别适合编写数学、计算机类文档书籍，另一方面继承了一定的复杂性（肯定比Word难上手）。</p>
<p>原本我对排版不怎么关注，直到最近在工作中遇到一些事情，才发现专业的排版能深刻影响人们对内容的态度。要想在短期内把Office练到出版社水平谈何容易，当初写论文时，就发现Word不怎么听话，所以现在要想更轻松的达到目的，最直接的方法就是采用专业的工具以得到专业的结果。于是就联想到了高德纳和它的TeX。</p>
<a id="more"></a>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一、无论LaTex还是Tex，都要找个发行版程序安装才能使用，我选择的是TeX Live 2017版。在官方网站<a href="https://tug.org/texlive/">https://tug.org/texlive/</a>下载后，用虚拟光驱加载光盘镜像，运行install-tl.bat。选择安装位置，设置“修改注册表中的PATH设置”为“是”，点击“安装TeX Live”按钮。</p>
<p>二、还需要一个编辑器，可以选择的是Atom，登录官网<a href="https://atom.io/">https://atom.io/</a>下载安装。打开Atom，File-&gt;Settings-&gt;Install，安装如下三个插件：</p>
<ul>
<li>latex：安装完成后点击Settings，TeX Path项填入…\texlive\2017\bin\win32；Engine项设置为pdflatex或xelatex（对中文支持较好）。</li>
<li>language-latex</li>
<li>pdf-view</li>
</ul>
<p>三、本人推荐使用Visual Studio Code，微软的跨平台编辑器，功能强大，速度比Atom快，界面同样好看。从官网<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>下载安装。打开程序，按压Ctrl+Shift+X，搜索LaTex Workshop插件并安装。完成后，文件-&gt;首选项-&gt;设置，搜索LaTex-Workshop，点击“在settings.json中编辑”，在其中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">            &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;-pdf&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">            &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">            &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;%DOCFILE%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;xelatex&quot;,</span><br><span class="line">            &quot;xelatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;xelatexb&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">          &quot;xelatex&quot;,</span><br><span class="line">          &quot;bibtex&quot;,</span><br><span class="line">          &quot;xelatex&quot;,</span><br><span class="line">          &quot;xelatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;pdflatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;latexmk&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;pdflatex&quot;,</span><br><span class="line">            &quot;bibtex&quot;,</span><br><span class="line">            &quot;pdflatex&quot;,</span><br><span class="line">            &quot;pdflatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.latex.clean.fileTypes&quot;: [</span><br><span class="line">    &quot;*.aux&quot;,</span><br><span class="line">    &quot;*.bbl&quot;,</span><br><span class="line">    &quot;*.blg&quot;,</span><br><span class="line">    &quot;*.idx&quot;,</span><br><span class="line">    &quot;*.ind&quot;,</span><br><span class="line">    &quot;*.lof&quot;,</span><br><span class="line">    &quot;*.lot&quot;,</span><br><span class="line">    &quot;*.out&quot;,</span><br><span class="line">    &quot;*.toc&quot;,</span><br><span class="line">    &quot;*.acn&quot;,</span><br><span class="line">    &quot;*.acr&quot;,</span><br><span class="line">    &quot;*.alg&quot;,</span><br><span class="line">    &quot;*.glg&quot;,</span><br><span class="line">    &quot;*.glo&quot;,</span><br><span class="line">    &quot;*.gls&quot;,</span><br><span class="line">    &quot;*.ist&quot;,</span><br><span class="line">    &quot;*.fls&quot;,</span><br><span class="line">    &quot;*.log&quot;,</span><br><span class="line">    &quot;*.fdb_latexmk&quot;,</span><br><span class="line">    &quot;*.gz&quot;</span><br><span class="line">  ],</span><br><span class="line">&quot;latex-workshop.latex.autoClean.run&quot;:&quot;onBuilt&quot;,</span><br></pre></td></tr></table></figure>
<p>保存设置，即可生效。上述定义分为三块：tools、recipes、clean.fileTypes。</p>
<ul>
<li>tools是对编译程序的描述，上面定义了四种工具。</li>
<li>recipes用来设置编译组合，最上面的设置将作为默认编译方式（Ctrl+Shift+B）。</li>
<li>clean.fileTypes是要在编译后清除的中间文件类型。</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>新建文件，路径和文件名必须全英文，扩展名为tex。用安装的编辑器打开，键入如下内容：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<span class="comment">%中文论文</span></span><br><span class="line"><span class="keyword">\title</span> &#123;文章标题&#125;</span><br><span class="line"><span class="keyword">\author</span> &#123;姓名&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span> <span class="comment">%显示标题姓名</span></span><br><span class="line"><span class="keyword">\section</span>&#123;第一节&#125;</span><br><span class="line">第一节介绍性内容</span><br><span class="line"><span class="keyword">\subsection</span>&#123;第一小节&#125;</span><br><span class="line">第一小节内容</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;第一小小节&#125;</span><br><span class="line">第一小小节内容</span><br><span class="line"><span class="keyword">\subsection</span>&#123;第二节&#125;</span><br><span class="line">第二节内容</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>两个编辑器都是按Ctrl+Alt+B快捷键进行编译，然后就可以看到生成的pdf文件显示在右侧。</p>
<h4 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h4><p>一、当你使用Latex语法编写文档时，第一个问题就是：我是想写论文，还是想写一本书。上面框架中的第一行<code>\documentclass[选项]&#123;文档类&#125;</code>就用于设置这个，常用的”文档类”有如下三个：book/ctexbook，report/ctexrep，article/ctexart。</p>
<blockquote>
<p>book、reprot、article用于英文文档，以ctex为前缀的文档类用于中文文档。一般article、report用于写论文，book用于写书。</p>
</blockquote>
<p>二、文章正式内容应放在<code>\begin&#123;document&#125; ... \end&#123;document&#125;</code>之间。它上面的部分称为<strong>导言区</strong>，用于放置一些全局设置和包引用。</p>
<p>三、章节层次</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">部分</td>
<td align="left">\part</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">章</td>
<td align="left">\chapter</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">节</td>
<td align="left">\section</td>
<td align="left">article最高层</td>
</tr>
<tr>
<td align="left">小节</td>
<td align="left">\subsection</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">小小节</td>
<td align="left">\subsubsection</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">段</td>
<td align="left">\paragraph</td>
<td align="left">没有编号，以粗体文字开头</td>
</tr>
<tr>
<td align="left">小段</td>
<td align="left">\subparagraph</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在上述命令后加*表示不编入目录，不编号。</p>
]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex排版三 细节</title>
    <url>/2017/12/16/LaTex%E6%8E%92%E7%89%88%E4%B8%89%20%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h4 id="文字字符"><a href="#文字字符" class="headerlink" title="文字字符"></a>文字字符</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\text</span>&#123;文字&#125;</span><br><span class="line"><span class="keyword">\textbf</span>&#123;加粗&#125;</span><br><span class="line"><span class="keyword">\emph</span>&#123;强调&#125;</span><br><span class="line"><span class="keyword">\underline</span>&#123;下划线&#125;</span><br><span class="line"><span class="keyword">\footnote</span>&#123;脚注内容&#125;</span><br><span class="line"><span class="keyword">\copyright</span>            <span class="comment">%版权符号</span></span><br><span class="line"><span class="keyword">\songti</span>&#123;宋体&#125;         <span class="comment">%ctex提供的中文字体</span></span><br><span class="line"><span class="keyword">\heiti</span>&#123;黑体&#125;</span><br><span class="line"><span class="keyword">\kaishu</span>&#123;楷书&#125;</span><br><span class="line"><span class="keyword">\ </span>                    <span class="comment">%空格</span></span><br><span class="line"><span class="keyword">\quad</span>                 <span class="comment">%一m宽度空白</span></span><br><span class="line"><span class="keyword">\qquad</span>                <span class="comment">%二m宽度空白</span></span><br><span class="line"><span class="keyword">\#</span> <span class="keyword">\$</span> <span class="keyword">\%</span> <span class="keyword">\&amp;</span> <span class="keyword">\&#123;</span> <span class="keyword">\&#125;</span> <span class="keyword">\_</span>  <span class="comment">%不能直接显示的符号，在前面加上转义字符\</span></span><br><span class="line"><span class="keyword">\backslash</span>            <span class="comment">%反斜杠</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;quote&#125;</span><br><span class="line">  <span class="keyword">\zihao</span>&#123;-5&#125;<span class="keyword">\kaishu</span> 引用的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;quote&#125;</span><br></pre></td></tr></table></figure>
<p>1.<code>\zihao&#123;-5&#125;\kaishu</code>调整字号为小五号，字体为楷书，后面要接一个空格再写正文。<br>2.这段文字将在它的放置处单独分行，增加缩进和上下间距排印，以突出引用部门。</p>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>先要在导言区定义定理，通过<code>\newtheorem&#123;环境名&#125;&#123;标题名&#125;[章节]</code>，然后在文章中插入定理：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;环境名&#125;[定理名]</span><br><span class="line">  定理1的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;环境名&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;环境名&#125;[定理名]</span><br><span class="line">  定理2的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;环境名&#125;</span><br></pre></td></tr></table></figure>
<p>1.[环境名]是统一的，每次引用都只是这一个名字。<br>2.[标题名]是在定理开头显示的文字，通常为“定理”或“引理”。<br>3.同一环境名下的定理会自动顺延编号，所以“标题名”和“定理名”不要带编号。<br>4.[章节]是可选的，可以为chapter、section分别对应按章或节自动编号。<br>5.[定理名]是可选的。</p>
<h4 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h4><p>一、在行内插入数学公式：<code>$ 算式 $</code>。</p>
<p>二、独立行显示数学公式：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span> 公式 <span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>三、数据符号</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125;                   <span class="comment">%分数</span></span><br><span class="line"><span class="keyword">\log</span><span class="built_in">_</span>a b                      <span class="comment">%对数</span></span><br><span class="line"><span class="keyword">\ln</span> a</span><br><span class="line"><span class="keyword">\lg</span> b</span><br><span class="line">a<span class="built_in">^</span>b                           <span class="comment">%指数</span></span><br><span class="line"><span class="keyword">\sqrt</span>&#123;x&#125;                      <span class="comment">%平方根</span></span><br><span class="line"><span class="keyword">\sqrt</span>[n]&#123;x&#125;                   <span class="comment">%n次方根</span></span><br><span class="line"><span class="keyword">\overline</span>&#123;m+n&#125;                <span class="comment">%上水平线</span></span><br><span class="line"><span class="keyword">\underline</span>&#123;m+n&#125;               <span class="comment">%下水平线</span></span><br><span class="line"><span class="keyword">\cdots</span>                        <span class="comment">%省略号...</span></span><br><span class="line"><span class="keyword">\underbrace</span>&#123;a+b+<span class="keyword">\cdots</span>+z&#125;<span class="built_in">_</span>26  <span class="comment">%下大括号</span></span><br><span class="line"><span class="keyword">\overbrace</span>&#123;a+b&#125;<span class="built_in">^</span>2             <span class="comment">%上大括号</span></span><br><span class="line"><span class="keyword">\vec</span> a                        <span class="comment">%单个字符向量</span></span><br><span class="line"><span class="keyword">\overrightarrow</span>&#123;AB&#125;           <span class="comment">%右向量</span></span><br><span class="line"><span class="keyword">\overleftarrow</span>&#123;CD&#125;            <span class="comment">%左向量</span></span><br><span class="line"><span class="keyword">\angle</span> a                      <span class="comment">%角</span></span><br><span class="line">30<span class="built_in">^</span><span class="keyword">\circ</span>                      <span class="comment">%度</span></span><br><span class="line"><span class="keyword">\pi</span>                           <span class="comment">% π</span></span><br></pre></td></tr></table></figure>
<p>通常下标用_，上标用^，上下标的组合式用{}括起。两个减号可以输出一条横线，表示数字的范围。</p>
<p>四、希腊字母<br><img src="https://i.loli.net/2019/12/20/EVwstqQneN4CbzB.png" alt="罗马字母.png"></p>
<p>五、数学运算</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">+ - <span class="keyword">\times</span> <span class="keyword">\div</span>               <span class="comment">%加减乘除</span></span><br><span class="line"><span class="keyword">\pm</span> <span class="keyword">\mp</span>                       <span class="comment">%加减、减加</span></span><br><span class="line"><span class="keyword">\cdot</span>                         <span class="comment">%点乘</span></span><br><span class="line"><span class="keyword">\cup</span>  <span class="keyword">\vee</span>                    <span class="comment">%并集（圆、尖）</span></span><br><span class="line"><span class="keyword">\cap</span>  <span class="keyword">\wedge</span>                  <span class="comment">%交集（圆、尖）</span></span><br><span class="line"><span class="keyword">\oplus</span> <span class="keyword">\ominus</span> <span class="keyword">\otimes</span>        <span class="comment">%圆加、圆减、圆乘</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;                <span class="comment">%求和</span></span><br><span class="line"><span class="keyword">\prod</span><span class="built_in">_</span>&#123;a&#125;<span class="built_in">^</span>&#123;b&#125;                 <span class="comment">%求积</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>&#123;0&#125;<span class="built_in">^</span>&#123;<span class="keyword">\pi</span>&#125;                <span class="comment">%积分</span></span><br><span class="line"><span class="keyword">\lim</span><span class="built_in">_</span>&#123;n <span class="keyword">\to</span> <span class="keyword">\infty</span>&#125;x<span class="built_in">_</span>n        <span class="comment">%求极限，条件放在右侧</span></span><br><span class="line"><span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;n <span class="keyword">\to</span> 1&#125;x<span class="built_in">_</span>n      <span class="comment">%求极限，条件放在下面</span></span><br><span class="line"><span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;<span class="keyword">\substack</span>&#123;x <span class="keyword">\to</span> +<span class="keyword">\infty</span><span class="keyword">\\</span> y<span class="keyword">\to</span> -<span class="keyword">\infty</span>&#125;&#125;x<span class="built_in">_</span>n <span class="comment">%求二重极限</span></span><br></pre></td></tr></table></figure>
<p>六、关系</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&lt; &gt; =                         <span class="comment">%小于、大于、等于</span></span><br><span class="line"><span class="keyword">\le</span> <span class="keyword">\ge</span> <span class="keyword">\ll</span> <span class="keyword">\gg</span>               <span class="comment">%小于等于、大于等于、远小于、远大于</span></span><br><span class="line"><span class="keyword">\equiv</span> <span class="keyword">\ne</span> <span class="keyword">\doteq</span>             <span class="comment">%恒等、不等、点等</span></span><br><span class="line"><span class="keyword">\sim</span> <span class="keyword">\cong</span>                    <span class="comment">%波浪 约等于</span></span><br><span class="line"><span class="keyword">\subset</span> <span class="keyword">\subseteq</span>             <span class="comment">%子集</span></span><br><span class="line"><span class="keyword">\supset</span> <span class="keyword">\supseteq</span>             <span class="comment">%超集</span></span><br><span class="line"><span class="keyword">\in</span> <span class="keyword">\ni</span> <span class="keyword">\notin</span>                <span class="comment">%属于（左、右）、不属于</span></span><br></pre></td></tr></table></figure>
<p>七、箭头、定界符及其他</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\leftarrow</span> <span class="keyword">\rightarrow</span>        <span class="comment">%左右箭头</span></span><br><span class="line"><span class="keyword">\uparrow</span> <span class="keyword">\downarrow</span>           <span class="comment">%上下箭头</span></span><br><span class="line"><span class="keyword">\leftrightarrow</span>               <span class="comment">%双向箭头</span></span><br><span class="line"><span class="keyword">\Leftarrow</span> <span class="keyword">\Rightarrow</span>        <span class="comment">%左右粗箭头</span></span><br><span class="line"><span class="keyword">\Uparrow</span> <span class="keyword">\Downarrow</span>           <span class="comment">%上下粗箭头</span></span><br><span class="line"><span class="keyword">\Leftrightarrow</span>               <span class="comment">%双向粗箭头</span></span><br><span class="line"><span class="keyword">\langle</span> <span class="keyword">\rangle</span>               <span class="comment">%尖括号</span></span><br><span class="line"><span class="keyword">\lfloor</span> <span class="keyword">\rfloor</span>               <span class="comment">%下限（左右）</span></span><br><span class="line"><span class="keyword">\lceil</span> <span class="keyword">\rceil</span>                 <span class="comment">%上限（左右）</span></span><br><span class="line"><span class="keyword">\forall</span>                       <span class="comment">%对于所有</span></span><br><span class="line"><span class="keyword">\exists</span>                       <span class="comment">%存在</span></span><br></pre></td></tr></table></figure>
<p>八、大括号公式</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">  0 <span class="built_in">&amp;</span> &lt;v<span class="built_in">_</span>i,v<span class="built_in">_</span>j&gt;<span class="keyword">\text</span>&#123;或&#125;(v<span class="built_in">_</span>i,v<span class="built_in">_</span>j)<span class="keyword">\in</span> VR <span class="keyword">\\</span></span><br><span class="line">  1 <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;反之&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p>1.需要导入包<code>\usepackage&#123;amsmath&#125;</code>。显示中文需要用<code>\text&#123;&#125;</code>括起。<br>2.整体应包裹在$之内，每一行公式用\\分隔。<br>3.用&amp;分隔一条公式的值和条件。</p>
<p>九、矩阵</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;matrix&#125; 1<span class="built_in">&amp;</span>0<span class="keyword">\\</span> 0<span class="built_in">&amp;</span>-1 <span class="keyword">\end</span>&#123;matrix&#125;   <span class="comment">%无包裹</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;pmatrix&#125; 1<span class="built_in">&amp;</span>0<span class="keyword">\\</span> 0<span class="built_in">&amp;</span>-1 <span class="keyword">\end</span>&#123;pmatrix&#125; <span class="comment">%圆括号</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;Bmatrix&#125; 1<span class="built_in">&amp;</span>0<span class="keyword">\\</span> 0<span class="built_in">&amp;</span>-1 <span class="keyword">\end</span>&#123;Bmatrix&#125; <span class="comment">%花括号</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;bmatrix&#125; 1<span class="built_in">&amp;</span>0<span class="keyword">\\</span> 0<span class="built_in">&amp;</span>-1 <span class="keyword">\end</span>&#123;bmatrix&#125; <span class="comment">%方括号</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;vmatrix&#125; 1<span class="built_in">&amp;</span>0<span class="keyword">\\</span> 0<span class="built_in">&amp;</span>-1 <span class="keyword">\end</span>&#123;vmatrix&#125; <span class="comment">%竖线</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;Vmatrix&#125; 1<span class="built_in">&amp;</span>0<span class="keyword">\\</span> 0<span class="built_in">&amp;</span>-1 <span class="keyword">\end</span>&#123;Vmatrix&#125; <span class="comment">%双竖线</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>1.需要导入包<code>\usepackage&#123;amsmath&#125;</code>，整体应包裹在$之内。<br>2.中间不能有空行，中文须用<code>\text&#123;&#125;</code>包裹，\\为换行。<br>3.每个数据之间用&amp;分隔。</p>
<p>例如：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">A[i][j] =</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">  0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span></span><br><span class="line">  1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span></span><br><span class="line">  0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span></span><br><span class="line">  1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span></span><br><span class="line">  0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0 </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>十、综合<br>1.给公式加一个框</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\boxed</span>&#123;a+b=c&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>2.将各种公式组合到一起</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">  A[i][j] = </span><br><span class="line">  <span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">      0 <span class="built_in">&amp;</span> &lt;v<span class="built_in">_</span>i,v<span class="built_in">_</span>j&gt;<span class="keyword">\text</span>&#123;或&#125;(v<span class="built_in">_</span>i,v<span class="built_in">_</span>j)<span class="keyword">\in</span> VR <span class="keyword">\\</span></span><br><span class="line">      1 <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;反之&#125;</span><br><span class="line">  <span class="keyword">\end</span>&#123;cases&#125;<span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\text</span>&#123;矩阵表示：&#125;A[i][j] = </span><br><span class="line">      <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">        0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span></span><br><span class="line">        1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span></span><br><span class="line">        0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span></span><br><span class="line">        1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span></span><br><span class="line">        0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0 </span><br><span class="line">      <span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p>3.多行公式，&amp;符号用于对齐</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align*&#125;</span><br><span class="line">  A <span class="built_in">&amp;</span>= B+C<span class="keyword">\\</span></span><br><span class="line">    <span class="built_in">&amp;</span>= D*E<span class="keyword">\\</span></span><br><span class="line">    <span class="built_in">&amp;</span>= F-G</span><br><span class="line"><span class="keyword">\end</span>&#123;align*&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h4><p>一、xelatex支持的图像格式有pdf、png、jpg、eps等。<br>二、需要在导言区引入graphicx宏包：<code>\usepackage&#123;graphicx&#125;</code>。<br>三、在行内插入图片：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[scale=0.6]&#123;./path/name.png&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>路径中不要使用中文，否则报错。可以使用相对路径。</p>
</blockquote>
<p>四、独立显示一幅浮动图片：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[ht]</span><br><span class="line">  <span class="keyword">\centering</span></span><br><span class="line">  <span class="keyword">\includegraphics</span>[scale=0.6]&#123;./path/name.png&#125;</span><br><span class="line">  <span class="keyword">\caption</span>&#123;图的说明文字&#125;</span><br><span class="line">  <span class="keyword">\label</span>&#123;标签名&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>figure表示浮动体，ht表示图片在当前处或一页的上部。centering表示后面的内容居中。caption添加说明和自动编号。label定义一个标签，在文章其他部分可通过\ref{标签名}引用此图。</p>
</blockquote>
<h4 id="条目"><a href="#条目" class="headerlink" title="条目"></a>条目</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">  <span class="keyword">\item</span>[1]第一条</span><br><span class="line">  <span class="keyword">\item</span>[2]第二条</span><br><span class="line">  <span class="keyword">\item</span>[3]第三条</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;对齐方式&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">    表头1 <span class="built_in">&amp;</span> ... <span class="built_in">&amp;</span> 表头n <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">    内容1 <span class="built_in">&amp;</span> ... <span class="built_in">&amp;</span> 内容n <span class="keyword">\\</span></span><br><span class="line">          ......       <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一行之内不同列之间用&amp;分隔，每行用\\分隔。</li>
<li>表格中的横线、竖线、表头、实际内容都要按照预想的样式键入字符设置。如上所示，先用\hline显示一条横线，然后是一行表头，接着又是一条横线，之后就是若干行具体内容了，最后由一条横线收尾。表头和内容之间即使没有竖线分隔，也会自动按照格式摆放。</li>
<li>对齐方式有三种，分别为l，c，r，每个字母代表一列，竖线也是在“对齐方式”中设置的。例如|ccc|表示有三列，都是中对齐，只有两侧有边线。</li>
</ul>
<p>整体示例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|r|cccc|l|&#125;</span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">  序号 <span class="built_in">&amp;</span> 部门 <span class="built_in">&amp;</span> 姓名 <span class="built_in">&amp;</span> 性别 <span class="built_in">&amp;</span> 年龄 <span class="built_in">&amp;</span> 工资<span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">    1 <span class="built_in">&amp;</span> 设计 <span class="built_in">&amp;</span> 张三 <span class="built_in">&amp;</span> 男 <span class="built_in">&amp;</span> 36 <span class="built_in">&amp;</span> 10<span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">    2 <span class="built_in">&amp;</span> 设计 <span class="built_in">&amp;</span> 李四 <span class="built_in">&amp;</span> 男 <span class="built_in">&amp;</span> 25 <span class="built_in">&amp;</span> 8<span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line">    3 <span class="built_in">&amp;</span> 设计 <span class="built_in">&amp;</span> 王五 <span class="built_in">&amp;</span> 男 <span class="built_in">&amp;</span> 33 <span class="built_in">&amp;</span> 9<span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>整个tabular块放在了center块中，可使表格居中显示。</p>
</blockquote>
<h4 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h4><p>导入<code>\usepackage&#123;listings&#125;</code>包。然后在导言区添加如下代码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line">    columns=fixed,</span><br><span class="line">    numbers=left,                                        <span class="comment">% 在左侧显示行号</span></span><br><span class="line">    numberstyle=<span class="keyword">\scriptsize</span><span class="keyword">\color</span>&#123;darkgray&#125;,             <span class="comment">% 设定行号格式</span></span><br><span class="line">    frame=single,                                        <span class="comment">% 不显示背景边框</span></span><br><span class="line">    tabsize=4,                                           <span class="comment">% 设置tab空格数</span></span><br><span class="line">    breaklines,                                          <span class="comment">% 自动折行  </span></span><br><span class="line">    basicstyle=<span class="keyword">\scriptsize</span>,                              <span class="comment">% 代码字体尺寸</span></span><br><span class="line">    xleftmargin=3em,xrightmargin=1em, aboveskip=1em,     <span class="comment">% 显示位置</span></span><br><span class="line">    backgroundcolor=<span class="keyword">\color</span>[RGB]&#123;245,245,244&#125;,            <span class="comment">% 设定背景颜色</span></span><br><span class="line">    keywordstyle=<span class="keyword">\color</span>[RGB]&#123;40,40,255&#125;,                 <span class="comment">% 设定关键字颜色</span></span><br><span class="line">    commentstyle=<span class="keyword">\it</span><span class="keyword">\color</span>[RGB]&#123;0,96,96&#125;,                <span class="comment">% 设置注释颜色</span></span><br><span class="line">    stringstyle=<span class="keyword">\rmfamily</span><span class="keyword">\slshape</span><span class="keyword">\color</span>[RGB]&#123;128,0,0&#125;,   <span class="comment">% 设置字符串</span></span><br><span class="line">    showstringspaces=false,                              <span class="comment">% 不显示字符串中的空格</span></span><br><span class="line">    language=c++,                                        <span class="comment">% 设置语言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在文章中插入代码示例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">\setmainfont</span>&#123;Consolas&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;lstlisting&#125;</span><br><span class="line">    <span class="params">#</span>include &lt;stdio.h&gt;</span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;hello,world!&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;lstlisting&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>\setmainfont</code>用于设置代码显示的字体</p>
</blockquote>
<p>引用源代码文件示例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">\setmainfont</span>&#123;Consolas&#125;</span><br><span class="line"> <span class="keyword">\lstinputlisting</span>[firstline=1, lastline=6]&#123;./path/filename.*&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>firstline为要显示的首行号，lastline为要显示的末行号。</p>
</blockquote>
]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex排版二 整体框架</title>
    <url>/2017/11/12/LaTex%E6%8E%92%E7%89%88%E4%BA%8C%20%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>按照写作目的，本文主要内容分为两部分：论文编写基本框架和书籍编写基本框架。</p>
<a id="more"></a>

<h4 id="写论文"><a href="#写论文" class="headerlink" title="写论文"></a>写论文</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8,a4paper]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\title</span> &#123;文章标题&#125;</span><br><span class="line"><span class="keyword">\author</span> &#123;姓名&#125;</span><br><span class="line"><span class="keyword">\date</span> &#123;<span class="keyword">\today</span>&#125;    <span class="comment">%设置日期，为空则不显示日期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;      <span class="comment">%图片</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;       <span class="comment">%数学表示</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;listings&#125;      <span class="comment">%语法高亮</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;        <span class="comment">%颜色包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;  <span class="comment">%文章开始</span></span><br><span class="line"><span class="keyword">\maketitle</span>        <span class="comment">%显示标题姓名</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;abstract&#125;</span><br><span class="line">  <span class="comment">%摘要内容</span></span><br><span class="line"><span class="keyword">\end</span>&#123;abstract&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\newpage</span>  <span class="comment">%目录另起一页</span></span><br><span class="line"><span class="keyword">\tableofcontents</span>  <span class="comment">%显示目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\newpage</span>  <span class="comment">%正文另起一页</span></span><br><span class="line"><span class="keyword">\section</span>&#123;第一节&#125;</span><br><span class="line">  <span class="comment">%第一节内容</span></span><br><span class="line"><span class="keyword">\subsection</span>&#123;第一小节&#125;</span><br><span class="line">  <span class="comment">%第一小节内容</span></span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;第一小小节&#125;</span><br><span class="line">  <span class="comment">%第一小小节内容</span></span><br><span class="line"><span class="keyword">\section</span>&#123;第二节&#125;</span><br><span class="line">  <span class="comment">%第二节内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;10&#125;  <span class="comment">%参考文献</span></span><br><span class="line"><span class="keyword">\bibitem</span> &#123;TAOCP1&#125; Donald Knuth , 计算机程序设计艺术 , 人民邮电出版社 , 2010.10 ,Vol.1.</span><br><span class="line"><span class="keyword">\bibitem</span> &#123;TAOCP2&#125; Donald Knuth , 计算机程序设计艺术 , 人民邮电出版社 , 2010.10 ,Vol.2.</span><br><span class="line"><span class="keyword">\bibitem</span> &#123;TAOCP3&#125; Donald Knuth , 计算机程序设计艺术 , 人民邮电出版社 , 2010.10 ,Vol.3.</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;  <span class="comment">%文章结尾</span></span><br></pre></td></tr></table></figure>
<p>1.通过第一行<code>\documentclass[选项]&#123;文档类&#125;</code>中的“选项”（多个选项之间以逗号分隔），可以设置：</p>
<ul>
<li>纸张 a4paper，a5paper，b5paper</li>
<li>字号 10pt，11pt，12pt</li>
</ul>
<p>2.通过\usepackage引入支持文档编辑的包。常用的就是上面那四个。</p>
<p>3.按照ctexart文档类的特性，摘要会紧接上文内容显示。可以使用\newpage命令把摘要或目录用独立页显示。</p>
<p>4.文章具体内容放在每个小结层次内。</p>
<p>5.参考文献</p>
<ul>
<li><code>\begin&#123;thebibliography&#125;&#123;标号位宽&#125;</code>中的“标号位宽”表示自动编号的最大位数。例如共有30条参考，这个标号位宽可以是30，99，ab等。</li>
<li>每条参考格式：<code>\bibitem&#123;标签&#125; 作者 , 书名 , 出版社 , 年份</code>。标签是个名字，在文章正文中引用文献时会用到它。</li>
<li>引用文献的命令：<code>cite&#123;标签&#125;</code>。</li>
</ul>
<h4 id="写书"><a href="#写书" class="headerlink" title="写书"></a>写书</h4><p>因为一本书的体量远远大于一篇论文，如果把所有文字放在一个文件里，管理起来会很困难。所以采用多文件的方式，有层次的存放各种类型的文档。比如，建立一个根目录book，在其下建立主文件（main.tex）和各章节子目录chapter1、chapter2…在每个章目录内建立章文件（chapter.tex）和picture、code目录，用来保存本章各种图片和源代码。</p>
<p>一、书籍主文件框架（main.tex）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[选项]&#123;ctexbook&#125;</span><br><span class="line"><span class="keyword">\title</span> &#123;文章标题&#125;</span><br><span class="line"><span class="keyword">\author</span> &#123;姓名&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%引入常用包，跟上面论文框架类似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span>                  <span class="comment">%显示标题姓名</span></span><br><span class="line"><span class="keyword">\include</span>&#123;./path/Foreword&#125;   <span class="comment">%插入前言</span></span><br><span class="line"><span class="keyword">\tableofcontents</span>            <span class="comment">%显示目录</span></span><br><span class="line"><span class="keyword">\include</span>&#123;./path/chapter1&#125;   <span class="comment">%引入章节，路径中文件名不带扩展名</span></span><br><span class="line"><span class="keyword">\include</span>&#123;./path/chapter2&#125;</span><br><span class="line"><span class="keyword">\appendix</span>                   <span class="comment">%引入附录，此命令后，引入的章节以“附录X”编号</span></span><br><span class="line"><span class="keyword">\include</span>&#123;./path/appendixA&#125;  </span><br><span class="line"><span class="keyword">\include</span>&#123;./path/appendixB&#125;</span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;plain&#125;   <span class="comment">%插入参考</span></span><br><span class="line"><span class="keyword">\bibliography</span>&#123;数据库文件名&#125;  <span class="comment">%不要加上扩展名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>1.通过<code>\include</code>引入子目录中的章节文件。</p>
<p>2.另一种加入参考文献的方法</p>
<ul>
<li>在书末尾通过<code>\bibliographystyle</code>和<code>\bibliography</code>引入文献数据库（*.bib）。</li>
<li>引用文献仍是通过<code>\cite&#123;标签&#125;</code>，不引用的文献不会显示。一个文献都不引用，编译报错。</li>
<li>数据库文件（*.bib）的格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@BOOK&#123;标签,</span><br><span class="line">  author &#x3D; &#123;作者&#125;,</span><br><span class="line">  title &#x3D; &#123;文献标题&#125;,</span><br><span class="line">  publisher &#x3D; &#123;出版社&#125;,</span><br><span class="line">  year &#x3D; &#123;XXXX&#125;, </span><br><span class="line">  volume &#x3D; &#123;第几卷&#125;,</span><br><span class="line">  edition &#x3D; &#123;第几版&#125;  %first、second、third</span><br><span class="line">&#125;</span><br><span class="line">@ARTICLE&#123;标签,</span><br><span class="line">  author &#x3D; &#123;作者&#125;,</span><br><span class="line">  title &#x3D; &#123;文献标题&#125;,</span><br><span class="line">  joural &#x3D; &#123;期刊名&#125;,</span><br><span class="line">  year &#x3D; &#123;XXXX&#125;,</span><br><span class="line">  number &#x3D; &#123;期刊号&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里列举了BOOK、ARTICLE的一些常用属性设置，当然还可以设置其他的属性。一个*.bib文件可以存放多个文献的信息。带bib数据库的文档需要多次编译。这种方式并不比之前的方法省事，通常都是从网上下载这种bib数据库文件直接引用。</p>
</blockquote>
<p>二、章节文件框架（chapter.tex）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\chapter</span>&#123;章节名称&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;第一节&#125;</span><br><span class="line">  <span class="comment">%第一节内容</span></span><br><span class="line"><span class="keyword">\subsection</span>&#123;第一小节&#125;</span><br><span class="line">  <span class="comment">%第一小节内容</span></span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;第一小小节&#125;</span><br><span class="line">  <span class="comment">%第一小小节内容</span></span><br><span class="line"><span class="keyword">\section</span>&#123;第二节&#125;</span><br><span class="line">  <span class="comment">%第二小节内容</span></span><br><span class="line"><span class="keyword">\endinput</span>   <span class="comment">%显式的结束文本，后面的内容不会被编译</span></span><br></pre></td></tr></table></figure>
<p>去掉章节编号：添加星即可<code>\chapter*&#123;&#125;</code>。同时，这个chapter也不会被编进目录中。</p>
]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>MPP36威震天</title>
    <url>/2018/11/17/MPP36%E5%A8%81%E9%9C%87%E5%A4%A9/</url>
    <content><![CDATA[<p>去年买了MPP10擎天柱，这个威震天就成了今年必买的玩具了。拿到实物第一感觉是威将的做工进步了，料子比MPP10好，而且这次是自主设计，一体变形（含枪托）。</p>
<a id="more"></a>

<p>整体造型还原G1，头雕仿官方MP36，身材与MPP10比例一致，臂炮具有灯效。搭配的激光鸟可变形为消声器，脚下有磁性，可吸附在威震天的手臂上。与官方MP36相比，正面还是官方更还原G1动画，背面MPP36更加平整。</p>
<p><img src="https://i.loli.net/2021/11/07/lroNSVHJdnzWF2y.png" alt="1威震天.png"><br><img src="https://i.loli.net/2020/05/05/fFYK4ybaDNEPXwM.jpg" alt="威震天-3.jpg"></p>
<p>小时候，我特别讨厌威震天。印象里在每集的开头，威震天都会有个计划说给观众听，然后发出自信的淫笑。在每集的结尾都会被柱子打的屁滚尿流，随之发出一声惨叫——撤退，狂派众人狼狈逃窜。</p>
<p>还有关键的一点，我不喜欢威震天的动画形象：老鼠灰加上马桶头，变形成一把小枪也没见多厉害。小时候，我总是盼着红蜘蛛能造反成功，那样就再也不会看见它了:D</p>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Transformers</category>
      </categories>
      <tags>
        <tag>Transformers</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2017/04/17/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>因为要在Hexo上写博客，所以需要了解点Markdown语法，经过简单的学习，在这里做一些笔记。</p>
<a id="more"></a>

<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>标题会以粗体显示，一级标题最大，之后逐级递减：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<h4 id="基本编辑"><a href="#基本编辑" class="headerlink" title="基本编辑"></a>基本编辑</h4><p>1.分段：用“空行”分段。<br>2.文字：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span>，<span class="strong">**粗体**</span>，~~删除线~~</span><br></pre></td></tr></table></figure>
<p>3.一些需要转义的字符：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\\   \`  \<span class="emphasis">*  \_   \&#123;   \&#125;   \[   \]   \(   \)</span></span><br><span class="line"><span class="emphasis">\#   \+  \-  \.   \!</span></span><br></pre></td></tr></table></figure>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>1.有序列表</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一条</span><br><span class="line"><span class="bullet">2.</span> 第二条</span><br></pre></td></tr></table></figure>
<p>2.无序列表</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 外层</span><br><span class="line"><span class="bullet">  +</span> 内层</span><br><span class="line"><span class="bullet">  +</span> 内层</span><br><span class="line"><span class="bullet">-</span> 外层</span><br><span class="line"><span class="bullet">  *</span> 其他</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里* + -是通用的，显示都一样，真正区分内外层的是缩进，不是符号。</p>
</blockquote>
<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>以一个以竖线开头的框体。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;一级引言</span><br><span class="line">&gt;&gt;二级引言</span><br></pre></td></tr></table></figure>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| NO. | Name | Dep |</span><br><span class="line">|:--- |:----:| ---:|</span><br><span class="line">| 1   | Jack | CIA |</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二行的冒号用作标记对齐方式，分别为左、中、右对齐。</p>
</blockquote>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.网址：<span class="xml"><span class="tag">&lt;<span class="name">https:www.XXXXX.org</span>&gt;</span></span></span><br><span class="line">2.超链接：[<span class="string">XXXXX</span>](<span class="link">http://www.XXXXX.com</span>)</span><br><span class="line">3.邮箱：<span class="xml">&lt;name@Xmail.com&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">标签</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></table></figure>
<h4 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h4><p>1.单行代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`printf(&quot;hello&quot;);`</span></span><br></pre></td></tr></table></figure>
<p>2.多行代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码由```c开头，以```结尾。</p>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果需要更复杂的显示，可以直接插入html代码。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Office笔记</title>
    <url>/2017/09/22/Office%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>随着管理工作越来越多，经常会使用Office套件。对于一些看似普通的功能，还真不能简单的试出来。每次百度搜，不如直接看自己的博客，所以此贴动态更新，把Office的点点滴滴都收集于此。</p>
<a id="more"></a>

<h4 id="在Word中显示分数"><a href="#在Word中显示分数" class="headerlink" title="在Word中显示分数"></a>在Word中显示分数</h4><ol>
<li>按CTRL+F9，在弹出的大括号中输入<code>EQ \F(*,*)</code>，括号中逗号左边输入分子，右边输入分母。</li>
<li>编辑完成后，选中该代码，按F9，就出现了分数形式。</li>
</ol>
<h4 id="在Word中生成目录"><a href="#在Word中生成目录" class="headerlink" title="在Word中生成目录"></a>在Word中生成目录</h4><ol>
<li>按照我们希望的样子排版好文档。</li>
<li>把鼠标放到想要作为目录项的各个标题上，在工具栏的“样式”框中点击“标题1”、“标题2”或“标题3”，以确定标题层次。</li>
<li>把光标移动到想生成目录的地方，点击菜单引用-&gt;目录-&gt;插入目录，在弹出的窗口中点击“确定”即可。</li>
<li>如果修改了文章层次，只需在目录上右键点击“更新域”即可。</li>
</ol>
<h4 id="在竖页中插入横页"><a href="#在竖页中插入横页" class="headerlink" title="在竖页中插入横页"></a>在竖页中插入横页</h4><ol>
<li>移动光标到前一页，点击菜单页面布局-&gt;分隔符，在分节符栏选择下一页。这时会新建一页。</li>
<li>选择纸张方向-&gt;横向即可。</li>
</ol>
<h4 id="在word中快速选择一段文字"><a href="#在word中快速选择一段文字" class="headerlink" title="在word中快速选择一段文字"></a>在word中快速选择一段文字</h4><ol>
<li>按住Ctrl，鼠标点击起始位置。</li>
<li>按住Shfit，鼠标点击结束位置。</li>
</ol>
]]></content>
      <categories>
        <category>PC</category>
      </categories>
      <tags>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础语法</title>
    <url>/2019/05/05/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><ol>
<li>弱类型语言。任何数据都是对象。</li>
<li>代码区分大小写，变量可由下划线、数字、字母组成。</li>
<li>不使用花括号标识代码块，而是采用缩进的形式。</li>
<li>不使用任何符号标识每行代码的结束（分号可用来分隔一行中的多个表达式）。</li>
<li>引入了编码-探索开发模式。</li>
<li>代码库特别丰富，支持各种应用领域。<a id="more"></a>

</li>
</ol>
<blockquote>
<p>本文介绍Python 3语法</p>
</blockquote>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>一、整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line">-<span class="number">8</span></span><br><span class="line"><span class="built_in">int</span>(<span class="number">3.14</span>)       <span class="comment">#3，强制转换为整数，小数部分丢弃</span></span><br><span class="line"><span class="built_in">int</span>(-<span class="number">7</span>)         <span class="comment">#-7</span></span><br></pre></td></tr></table></figure>
<p>二、浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line">-<span class="number">3.762</span></span><br><span class="line"><span class="built_in">float</span>(-<span class="number">1</span>)       <span class="comment">#-1.0，强制转换为浮点数，添加小数部分</span></span><br></pre></td></tr></table></figure>
<p>三、字符串<br>字符串通常用单引号包裹，也可以用双引号开始和结束。使用双引号，其内部可以使用单引号字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>             <span class="comment">#用单引号括起</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span>       <span class="comment">#&#x27;ab&#x27;，字符串连接</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> * <span class="number">3</span>         <span class="comment">#&#x27;aaa&#x27;，重复三次字符串</span></span><br><span class="line"><span class="built_in">str</span>(<span class="number">100</span>)        <span class="comment">#&#x27;100&#x27;，转换为字符串</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&#x27;python&#x27;</span>)   <span class="comment">#6，字符串长度</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;py&#x27;th&#x27;on&quot;</span>) <span class="comment">#8，内部有单引号，外部用双引号标识字符串</span></span><br><span class="line">print(<span class="string">&#x27;abc&#x27;</span>,end=<span class="string">&#x27;n&#x27;</span>)    <span class="comment">#end定义行尾字符，默认为\n。</span></span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,sep=<span class="string">&#x27;,&#x27;</span>)  <span class="comment">#sep定义字符间分隔符，默认为空格</span></span><br><span class="line">print(<span class="string">r&quot;Hello\nHow are you?\nI\&#x27;m fine.&quot;</span>) <span class="comment">#r标识原始字符串，打印出反斜杠</span></span><br><span class="line">print(<span class="string">&#x27;&#x27;&#x27;Dear Tom,</span></span><br><span class="line"><span class="string">How are you?</span></span><br><span class="line"><span class="string">I&#x27;m fine,</span></span><br><span class="line"><span class="string">Thank you&#x27;&#x27;&#x27;</span>)          <span class="comment">#三引号之间的引号、制表符、换行都被直接识别</span></span><br><span class="line"></span><br><span class="line">first_name = <span class="string">&#x27;Ada&#x27;</span></span><br><span class="line">last_name = <span class="string">&#x27;Wang&#x27;</span></span><br><span class="line">full_name = <span class="string">f&#x27;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&#x27;</span>  <span class="comment">#字符串中有变量</span></span><br><span class="line">print(full_name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>]                 <span class="comment">#&#x27;h&#x27;</span></span><br><span class="line"><span class="built_in">str</span>[-<span class="number">1</span>]                <span class="comment">#&#x27;0&#x27;</span></span><br><span class="line"><span class="built_in">str</span>[<span class="number">1</span>:<span class="number">3</span>]               <span class="comment">#&#x27;el&#x27;</span></span><br><span class="line"><span class="built_in">str</span>[:<span class="number">3</span>]                <span class="comment">#&#x27;hel&#x27; 不含本身</span></span><br><span class="line"><span class="built_in">str</span>[<span class="number">2</span>:]                <span class="comment">#&#x27;llo&#x27; 含本身</span></span><br><span class="line"><span class="string">&#x27;hel&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;hello&#x27;</span>       <span class="comment">#True</span></span><br><span class="line"><span class="string">&#x27;ol&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;hello&#x27;</span>    <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python字符串默认使用Unicode编码。转义字符：<code>\&#39;  \&quot;  \t  \n  \\</code>。</p>
</blockquote>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>一、算术</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">1</span> - <span class="number">2</span> * <span class="number">6</span>   <span class="comment">#-8，加减乘</span></span><br><span class="line"><span class="number">3</span> / <span class="number">2</span>           <span class="comment">#1.5，除</span></span><br><span class="line"><span class="number">3</span> // <span class="number">2</span>          <span class="comment">#1，商</span></span><br><span class="line"><span class="number">6</span> % <span class="number">4</span>           <span class="comment">#2，余</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span>          <span class="comment">#8，乘方</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从左到右，乘方的优先级最高，接下来是乘除，最后加减。可以用圆括号改变优先级。</p>
</blockquote>
<p>二、赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">13</span>//<span class="number">4</span>)**<span class="number">3</span>  <span class="comment">#27</span></span><br><span class="line">a += <span class="number">3</span>          <span class="comment">#30</span></span><br><span class="line">a -= <span class="number">5</span>          <span class="comment">#25</span></span><br><span class="line">a *= <span class="number">2</span>          <span class="comment">#50</span></span><br><span class="line">a /= <span class="number">5</span>          <span class="comment">#10.0</span></span><br><span class="line">a //= <span class="number">4</span>         <span class="comment">#2.0</span></span><br><span class="line">a **= <span class="number">8</span>         <span class="comment">#256.0</span></span><br><span class="line">a %= <span class="number">13</span>         <span class="comment">#9.0</span></span><br><span class="line">a = <span class="built_in">input</span>()     <span class="comment">#由用户输入，类型为字符串</span></span><br><span class="line"><span class="built_in">int</span>(a) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果等号右侧是表达式，那么先进行等号右侧表达式的计算。</p>
</blockquote>
<p>三、逻辑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span>            <span class="comment">#布尔值两个</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> == <span class="string">&#x27;abc&#x27;</span>  <span class="comment">#True</span></span><br><span class="line"><span class="string">&#x27;dog&#x27;</span> != <span class="string">&#x27;cat&#x27;</span>  <span class="comment">#True </span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;ab&#x27;</span>    <span class="comment">#True</span></span><br><span class="line"><span class="string">&#x27;bc&#x27;</span> &gt; <span class="string">&#x27;abc&#x27;</span>    <span class="comment">#True</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;abd&#x27;</span>   <span class="comment">#False </span></span><br><span class="line"><span class="number">42</span> &lt; <span class="number">42.0</span>       <span class="comment">#False</span></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="number">5</span> &lt; <span class="number">7</span> <span class="comment">#True，与</span></span><br><span class="line"><span class="number">3</span> &lt;= <span class="number">2</span> <span class="keyword">or</span> <span class="number">2</span> &gt; <span class="number">8</span> <span class="comment">#False，或</span></span><br><span class="line"><span class="keyword">not</span> <span class="number">3</span> == <span class="number">8</span>      <span class="comment">#True，非</span></span><br><span class="line"><span class="keyword">not</span> <span class="number">3</span> != <span class="number">3</span>      <span class="comment">#True，非</span></span><br><span class="line">a <span class="keyword">is</span> b          <span class="comment">#如果变量a和b指向同一个对象，返回True</span></span><br><span class="line">a <span class="keyword">is</span> <span class="keyword">not</span> b      <span class="comment">#如果变量a和b指向不同的对象，返回True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串比较是从前向后逐个比较对应位置的字符（按照ACSII码大小），直到得出结果。</p>
</blockquote>
<p>四、位运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0xa</span></span><br><span class="line">b = <span class="number">0xb</span></span><br><span class="line">a &amp; b</span><br><span class="line">a | b</span><br><span class="line">a ^ b           <span class="comment">#异或</span></span><br><span class="line">~a</span><br><span class="line">a &lt;&lt; <span class="number">2</span>          <span class="comment">#左移，每移一位，相当于十进制的乘2操作</span></span><br><span class="line">b &gt;&gt; <span class="number">2</span>          <span class="comment">#右移，低位丢弃，高位补0</span></span><br></pre></td></tr></table></figure>
<h4 id="程序流"><a href="#程序流" class="headerlink" title="程序流"></a>程序流</h4><p>一、分支语句<br>分支语句根据条件判定执行哪个分支，最后只有一个分支会被执行，所以需要注意条件出现的顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>()     <span class="comment">#用户输入</span></span><br><span class="line">a = <span class="built_in">int</span>(a)      <span class="comment">#用户输入默认为字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">9</span>:       <span class="comment">#if-else语句</span></span><br><span class="line">    print(<span class="string">&#x27;小于9&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;大于9&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span>:      <span class="comment">#if-elif-else语句</span></span><br><span class="line">    print(<span class="string">&#x27;大于10&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">3</span> &lt; a &lt; <span class="number">8</span>:</span><br><span class="line">    print(<span class="string">&#x27;小于8&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">&#x27;太小了&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;其他值&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0、0.0、’’被解释为False，其他值被解释为True。</p>
</blockquote>
<p>二、循环语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0</span>               <span class="comment">#while语句</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  <span class="comment">#for语句</span></span><br><span class="line">    print(i)        <span class="comment">#打印0和1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>range(min,[max],[step])，产生[min,max)内的整数序列。循环内部可以使用break和Continue。如果程序陷入无限循环，按压Ctrl+C终止程序。</p>
</blockquote>
<p>三、异常处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span>(<span class="params">div</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> / div</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:   <span class="comment">#系统错误码</span></span><br><span class="line">        print(<span class="string">&#x27;Error: Invalid argument.&#x27;</span>)</span><br><span class="line">d(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>一、自定义函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span>                       <span class="comment">#全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">fst,sec=<span class="number">2</span>,thd=<span class="number">3</span></span>):</span>   <span class="comment">#函数定义</span></span><br><span class="line">    fst = <span class="number">1</span></span><br><span class="line">    <span class="keyword">global</span> x                <span class="comment">#修改全局变量</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    print(sec+x)</span><br><span class="line">    <span class="keyword">return</span> fst,sec+x,thd</span><br><span class="line"></span><br><span class="line">fun(<span class="number">2</span>)                      <span class="comment">#1,4,3</span></span><br><span class="line">fun(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)                  <span class="comment">#1,3,4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>(<span class="params">size,*tup_num</span>):</span>    <span class="comment">#任意数量参数，tup_num作为一个元组</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> tup_num:</span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;n&#125;</span>,&quot;</span>)</span><br><span class="line"></span><br><span class="line">fun1(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)           <span class="comment">#2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>(<span class="params">n1,n2,**dict_num</span>):</span> <span class="comment">#字典参数</span></span><br><span class="line">    dict_num[<span class="string">&#x27;c&#x27;</span>] = n1      <span class="comment">#在字典中添加键值对</span></span><br><span class="line">    dict_num[<span class="string">&#x27;d&#x27;</span>] = n2</span><br><span class="line">    <span class="keyword">return</span> dict_num</span><br><span class="line"></span><br><span class="line">fun2(<span class="number">1</span>,<span class="number">2</span>,a=<span class="number">3</span>,b=<span class="number">4</span>)           <span class="comment">#&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 4, &#x27;c&#x27;: 1, &#x27;d&#x27;: 2&#125; 后两个参数直接向字典中加入键值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数可以返回None，也可以返回多个值。</p>
</blockquote>
<p>二、匿名函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span>(<span class="params">l, f</span>):</span>        <span class="comment">#对l中每个元素应用f</span></span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> l]    <span class="comment">#中括号表示结果是个列表</span></span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>三、导入函数<br>可以将函数定义都放在一个源代码文件（模块）中，例如：FunFile.py。在其他文件导入FunFile中的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random,sys       <span class="comment">#导入random和sys模块中的全部函数</span></span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)    <span class="comment">#在[1,10]之间取1个随机数。调用函数：Module_name.fun()</span></span><br><span class="line">sys.exit()              <span class="comment">#终止程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *    <span class="comment">#导入random模块中全部函数</span></span><br><span class="line">randint(<span class="number">1</span>,<span class="number">8</span>)            <span class="comment">#不用写出模块名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint         <span class="comment">#导入random模块中randint函数，导入的多个函数名用逗号分隔</span></span><br><span class="line">randint(<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint <span class="keyword">as</span> rdi  <span class="comment">#起个别名</span></span><br><span class="line">rdi(<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>(Value,Type)  <span class="comment">#判断Value是否是Type类型。标准库函数可以直接调用</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>模块就是源代码文件，其中的变量和函数通过.访问。</p>
</blockquote>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, height, weight</span>):</span>  <span class="comment">#构造函数</span></span><br><span class="line">        self.height = height             <span class="comment">#self就是本地对象指针</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getw</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;The weight is <span class="subst">&#123;self.weight&#125;</span>kg.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setw</span>(<span class="params">self,w</span>):</span></span><br><span class="line">        self.weight = w</span><br><span class="line"></span><br><span class="line">my_cat = Cat(<span class="number">25</span>, <span class="number">8</span>)      <span class="comment">#新建对象</span></span><br><span class="line">my_cat.height            <span class="comment">#25 访问属性</span></span><br><span class="line">my_cat.getw()            <span class="comment">#8 访问成员函数</span></span><br><span class="line">my_cat.weight = <span class="number">10</span>       <span class="comment">#直接改变属性的值</span></span><br><span class="line">my_cat.getw()            <span class="comment">#10</span></span><br><span class="line">my_cat.setw(<span class="number">7</span>)           <span class="comment">#通过成员函数改变属性</span></span><br><span class="line">my_cat.weight            <span class="comment">#7</span></span><br></pre></td></tr></table></figure>
<p>继承</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    ......               <span class="comment">#创建子类时，父类必须在当前文件中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatFood</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,<span class="built_in">type</span>=<span class="string">&#x27;fish&#x27;</span></span>):</span></span><br><span class="line">        self.<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlueCat</span>(<span class="params">Cat</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,height,weight,colour</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(height,weight)  <span class="comment">#父类的成员</span></span><br><span class="line">        self.colour = colour             <span class="comment">#自身的成员</span></span><br><span class="line">        self.eat = CatFood()             <span class="comment">#对象属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">geth</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&quot;The BlueCat&#x27;s height is <span class="subst">&#123;self.height&#125;</span>.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getw</span>(<span class="params">self</span>):</span>                      <span class="comment">#重载了父类的成员函数</span></span><br><span class="line">        print(<span class="string">f&quot;The BlueCat&#x27;s weight is <span class="subst">&#123;self.weight&#125;</span>kg.&quot;</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getcol</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&quot;The BlueCat&#x27;s colour is <span class="subst">&#123;self.colour&#125;</span>.&quot;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">my_BlueCat = BlueCat(<span class="number">30</span>, <span class="number">10</span>, <span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">my_BlueCat.height</span><br><span class="line">my_BlueCat.geth()</span><br><span class="line">my_BlueCat.getcol()</span><br><span class="line">my_BlueCat.setw(<span class="number">15</span>)      <span class="comment">#调用父类的成员函数</span></span><br><span class="line">my_BlueCat.getw()        <span class="comment">#调用子类的成员函数</span></span><br><span class="line">my_BlueCat.eat.<span class="built_in">type</span>      <span class="comment">#访问对象属性中的属性</span></span><br></pre></td></tr></table></figure>
<p>可以将任意个类定义（Cname1，Cname2…）放在一个文件中(ClassFile.py)。在另一个文件引用那些类的方法：</p>
<ol>
<li>通过<code>from ClassFile import Cname1, Cname2</code>导入其中某个类；</li>
<li>通过<code>import ClassFile</code>导入整个模块，然后通过<code>ClassFile.Cname1</code>形式的语句引用类；</li>
<li>通过<code>from ClassFile import *</code>导入ClassFile.py中定义的所有类，然后就可以直接使用类名；</li>
<li>通过<code>from ClassFile import Cname1 as CN</code>为导入的Cname1类起个别名。</li>
</ol>
<h4 id="元祖Tuple"><a href="#元祖Tuple" class="headerlink" title="元祖Tuple"></a>元祖Tuple</h4><p>长度固定，不可改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>                 <span class="comment">#两端可由()括起</span></span><br><span class="line">nest_tup = (<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>),(<span class="number">3</span>,<span class="number">4</span>)    <span class="comment">#每个元素是tuple</span></span><br><span class="line">a_tup = (<span class="string">&#x27;one&#x27;</span>,)            <span class="comment">#只有一个元素时，后面应跟一个逗号，否则认为是个一般数据。</span></span><br><span class="line"><span class="built_in">tuple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])              <span class="comment">#(1,2,3)</span></span><br><span class="line">a = <span class="built_in">tuple</span>(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line">a                           <span class="comment">#(&#x27;s&#x27;,&#x27;t&#x27;,&#x27;r&#x27;)</span></span><br><span class="line">a[<span class="number">0</span>]                        <span class="comment">#&#x27;s&#x27;，从0计数</span></span><br><span class="line">a[-<span class="number">2</span>]                       <span class="comment">#&#x27;t&#x27;</span></span><br><span class="line">nest_tup[<span class="number">0</span>][<span class="number">1</span>]              <span class="comment">#7</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>) + (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)             <span class="comment">#(1,2,3,4,5)</span></span><br><span class="line">(<span class="number">5</span>,<span class="number">6</span>) * <span class="number">3</span>                   <span class="comment">#(5,6,5,6,5,6)</span></span><br><span class="line"></span><br><span class="line">tup2 = <span class="number">4</span>,<span class="number">5</span>,(<span class="number">6</span>,<span class="number">7</span>)               </span><br><span class="line">a,b,(c,d) = tup2</span><br><span class="line">d                           <span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">serl = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">a,b,*_ = serl</span><br><span class="line">a                           <span class="comment">#1</span></span><br><span class="line">b                           <span class="comment">#2</span></span><br><span class="line">a,b                         <span class="comment">#(1,2)</span></span><br><span class="line"></span><br><span class="line">serl[<span class="number">1</span>:<span class="number">3</span>]                   <span class="comment">#(2,3)</span></span><br><span class="line">serl[:<span class="number">4</span>]                    <span class="comment">#(1,2,3,4)</span></span><br><span class="line">serl[<span class="number">3</span>:]                    <span class="comment">#(4,5,6)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串类似于元祖，是不可改变数据，可以使用[]访问其中的字符，支持切片和负数访问。</p>
</blockquote>
<h4 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h4><p>列表与元祖类似，但是可以改变，用[]标识。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line">l[<span class="number">3</span>]                <span class="comment">#&#x27;abc&#x27;</span></span><br><span class="line">l[-<span class="number">2</span>]               <span class="comment">#3</span></span><br><span class="line">a1,a2,a3,a4 = l</span><br><span class="line">a3                  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">1</span>:<span class="number">4</span>]              <span class="comment">#[2,3,&#x27;abc&#x27;]，切片[a:b]得到[a,b)范围内的元素</span></span><br><span class="line">l[:<span class="number">3</span>]               <span class="comment">#[1,2,3]</span></span><br><span class="line">l[<span class="number">3</span>:]               <span class="comment">#[&#x27;abc&#x27;]</span></span><br><span class="line"></span><br><span class="line">l+[<span class="number">4</span>,<span class="number">5</span>]             <span class="comment">#[1,2,3,&#x27;abc&#x27;,4,5]</span></span><br><span class="line">[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] * <span class="number">2</span>         <span class="comment">#[6, 7, 8, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> l              <span class="comment">#True，判断2是否在l中</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">not</span> <span class="keyword">in</span> l          <span class="comment">#True，判断6是否不在l中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(l)              <span class="comment">#4</span></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">2</span>]            <span class="comment">#l = [1,2,&#x27;abc&#x27;]</span></span><br><span class="line"></span><br><span class="line">l.index(<span class="string">&#x27;abc&#x27;</span>)      <span class="comment">#2，得到索引</span></span><br><span class="line">l.append(<span class="string">&#x27;def&#x27;</span>)     <span class="comment">#[1,2,&#x27;abc&#x27;,&#x27;def&#x27;]，附加在末尾</span></span><br><span class="line">l.remove(<span class="number">2</span>)         <span class="comment">#[1,&#x27;abc&#x27;,&#x27;def&#x27;]，删除第一个遇到的</span></span><br><span class="line">l.insert(<span class="number">2</span>,<span class="string">&#x27;pqr&#x27;</span>)   <span class="comment">#[1, &#x27;abc&#x27;, &#x27;pqr&#x27;, &#x27;def&#x27;]</span></span><br><span class="line"></span><br><span class="line">sl = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">sl.sort                 <span class="comment">#[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]，ASCII顺序</span></span><br><span class="line">sl.sort(reverse=<span class="literal">True</span>)   <span class="comment">#[&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;B&#x27;, &#x27;A&#x27;]</span></span><br><span class="line">sl.sort(key=<span class="built_in">str</span>.lower)  <span class="comment">#[&#x27;a&#x27;, &#x27;A&#x27;, &#x27;b&#x27;, &#x27;B&#x27;, &#x27;c&#x27;]，字母表序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))           <span class="comment">#[1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">s1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">s2 = copy.copy(s1)      <span class="comment">#实际复制列表到s2</span></span><br><span class="line">s1 = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">s2 = copy.deepcopy(s1)  <span class="comment">#实际复制嵌套列表到s2</span></span><br></pre></td></tr></table></figure>
<p>列表变量包含的是对列表的引用。当列表变量作为参数传递给函数时，如果在函数内部对其元素进行了修改，函数返回后，这些修改会被保持。如果不想让函数修改列表，可以在传递列表变量时使用切片，例如ListName[:]。</p>
<blockquote>
<p>变量名包含可变数据（列表，字典）的引用；包含不可变数据（元祖）本身。</p>
</blockquote>
<h4 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h4><p>字典也称为哈希表或关联数组，是尺寸可变的键-值对集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#125;              <span class="comment">#空字典</span></span><br><span class="line">dict1[<span class="string">&#x27;b&#x27;</span>] = <span class="number">3</span>          <span class="comment">#插入第一个序对</span></span><br><span class="line">dict1[<span class="string">&#x27;1&#x27;</span>] = [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]	<span class="comment">#插入第二个序对</span></span><br><span class="line">dict1                   <span class="comment">#&#123;&#x27;b&#x27;:3,1:[&#x27;x&#x27;,&#x27;y&#x27;]&#125;</span></span><br><span class="line">dict1[<span class="string">&#x27;1&#x27;</span>]              <span class="comment">#[&#x27;x&#x27;,&#x27;y&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> <span class="keyword">in</span> dict1            <span class="comment">#True，检查dict1中是否包含某个key</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> dict1              <span class="comment">#False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;1&#x27;</span>]          <span class="comment">#删除一项</span></span><br><span class="line">dict1[<span class="number">3.14</span>] = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">ret = dict1.pop(<span class="number">3.14</span>)   <span class="comment">#删除并返回值</span></span><br><span class="line">ret                     <span class="comment">#&#x27;abc&#x27;</span></span><br><span class="line">dict1                   <span class="comment">#&#123;&#x27;b&#x27;:3&#125;</span></span><br><span class="line"></span><br><span class="line">dict1.update(&#123;<span class="number">2.7</span>:<span class="string">&#x27;err&#x27;</span>,<span class="number">12</span>:<span class="number">16</span>&#125;) <span class="comment">#dict1被扩充</span></span><br><span class="line"><span class="built_in">list</span>(dict1.keys())              <span class="comment">#得到dict1所有key的列表</span></span><br><span class="line"><span class="built_in">list</span>(dict1.values())            <span class="comment">#得到dict1所有value的列表</span></span><br><span class="line"></span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]):</span><br><span class="line">    mapping[key] = value</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure>
<p>字典的值可以是任何对象，字典的键必须是不可变对象（复合对象内部元素也必须是不可变的）。不可变对象都是可hash的，，使用hash(值)即可测试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict2 = &#123;&#125;</span><br><span class="line">dict2[<span class="built_in">tuple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])] = <span class="number">5</span>           <span class="comment">#&#123;(1,2,3):5&#125;</span></span><br><span class="line">dict2[<span class="built_in">tuple</span>([<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>],<span class="number">3</span>])] = <span class="number">1</span>     <span class="comment">#报错，tuple([1,[2,&#x27;b&#x27;],3])=(1, [2, &#x27;b&#x27;], 3)</span></span><br></pre></td></tr></table></figure>
<h4 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h4><p>完全参照集合的数学概念，具有无序性和唯一性，是不可变数据类型，类似于只有键，没有值的字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])        <span class="comment">#&#123;1,2,3&#125;</span></span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>&#125;       <span class="comment">#&#123;2,3,5&#125;</span></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; == &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;  <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">a.union(b)          <span class="comment">#&#123;1,2,3,4,5,6&#125;，并集</span></span><br><span class="line">a | b               <span class="comment">#同上，二者皆不会改变a，b值</span></span><br><span class="line">a.intersection(b)   <span class="comment">#&#123;2&#125;，交集</span></span><br><span class="line">a &amp; b</span><br><span class="line"></span><br><span class="line">l = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&#123;l&#125;                 <span class="comment">#报错，不能含可变数据</span></span><br></pre></td></tr></table></figure>
<h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>一、列表推导[expr for val in collection if condition]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>,<span class="string">&#x27;five&#x27;</span>,<span class="string">&#x27;six&#x27;</span>]</span><br><span class="line">[s.upper() <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span> <span class="keyword">if</span> <span class="built_in">len</span>(s)&gt;<span class="number">3</span>]    <span class="comment">#[&#x27;THREE&#x27;, &#x27;FOUR&#x27;, &#x27;FIVE&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>二、字典推导{key-expr:value-expr for value in collection if condition}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;val : index <span class="keyword">for</span> index, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">str</span>)&#125;  <span class="comment">#&#123;&#x27;one&#x27;: 0, &#x27;two&#x27;: 1, &#x27;three&#x27;: 2, &#x27;four&#x27;: 3, &#x27;five&#x27;: 4, &#x27;six&#x27;: 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>三、集合推导{expr for value in collection if condition}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>&#125;   <span class="comment">#&#123;3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是嵌套结构，for的顺序按照内嵌的顺序，过滤条件总在末尾。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>掌握了这些语法，结合各种库就可以做很多有趣的事了，比如办公自动化、建立网站、数据可视化、爬虫、人工智能等等。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SS08眩晕</title>
    <url>/2019/07/28/SS08%E7%9C%A9%E6%99%95/</url>
    <content><![CDATA[<p>SS变形金刚主要是电影版玩具，本人关注较少，能记住的角色只有变1开场出来的眩晕、变2大力神、变3震荡波、变4禁闭。买这款SS08眩晕主要是因为近期降价幅度较大，100出头的价格感觉还是比较值的。</p>
<a id="more"></a>

<p>总的来说人形态、载具形态都很还原电影，头雕精细，附带蝎子，按理说应该是一款非常成功的商品，无奈用料太薄太脆，以致于载具形态合缝相当不好，变形体验极差，一圈下来全是白痕，让人不得不质疑商家的诚意，所以价格腰斩一点也不令人意外。</p>
<p><img src="https://i.loli.net/2020/02/03/UjtzmIOHbAglcXL.jpg" alt="眩晕1.jpg"><br><img src="https://i.loli.net/2020/02/03/WTeufJi4m8wZbCP.jpg" alt="眩晕2.jpg"><br><img src="https://i.loli.net/2020/02/03/YOUaiSxXz8pZT4e.jpg" alt="眩晕3.jpg"></p>
<p>所以说，对于变形金刚不能无脑认为官方的东西都是好的。</p>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Transformers</category>
      </categories>
      <tags>
        <tag>Transformers</tag>
      </tags>
  </entry>
  <entry>
    <title>PhotoShop日常应用</title>
    <url>/2018/12/06/PS%E6%97%A5%E5%B8%B8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>记得在大学刚入学时，系主任在全系动员会中讲了一个段子：有个学生，面临第二次留级，按照规矩应该开除，但是其父母是国家高级干部，跟校领导很熟，大家碍于情面只能再给他一次机会。于是乎，系主任决定亲自去会会这个留级生，<br>问：“为什么不好好学习？”<br>答：“课上讲的都没用。”<br>问：“那什么有用？”<br>答：“PhotoShop，我自己正通过网络自学呢。”</p>
<a id="more"></a>

<p>当时会场哗然，嘲笑之声此起彼伏，对于计算机专业的freshman有这个反应不令人意外。现在我已经毕业多年了，回头看这件事，完全是另一番风味。通常情况下，新手最好不要嘲笑过来人，即使那个人表现得很平庸！</p>
<p>毕业时，系里只有少数人从事了计算机行业，后来又有一堆人转行，试问计算机专业知识对这些“离去”的人有多大意义呢？相对的，在生活和工作中经常会用到PS，有时候这个技能还会起到关键作用。</p>
<p>本文将不定期更新，将生活和工作中关于PS的点点滴滴记录于此。</p>
<h4 id="抠图章"><a href="#抠图章" class="headerlink" title="抠图章"></a>抠图章</h4><p>点击“选择”菜单-&gt;色彩范围，调整“颜色容差”使得图章在下面黑框中显示出来。点击右侧“吸管”，选择显示出来的图章部分，确定。返回主界面后，发现蚂蚁线已包围图章部分，按压Ctrl+J复制图层。在图层面板，去掉原图层的显示，以支持透明图像的格式（png）保存图片。 </p>
<h4 id="组合多张图片"><a href="#组合多张图片" class="headerlink" title="组合多张图片"></a>组合多张图片</h4><p>将这些图片分别拖入PS，通过菜单“图像”-&gt;“图像大小”查看各图片的尺寸。然后计算出总共所需尺寸（宽度和高度），使其能容纳全部想要放置的图片。</p>
<p>通过菜单“图像”-&gt;“画布大小”，将其中一张图片的画布调整为总尺寸。然后使用Ctrl+C和Ctrl+V，将其他图片粘贴到这张画布上调整位置。如果画布设置过大，可以使用裁剪工具将多余部分切除。</p>
<h4 id="1寸照片更换背景色"><a href="#1寸照片更换背景色" class="headerlink" title="1寸照片更换背景色"></a>1寸照片更换背景色</h4><p>用魔术棒选择背景，再点击拾色器调整颜色，比如想要蓝色背景，可以将RGB的值设置为R:0、G:191、B:243。然后，使用油漆桶工具点击选中的背景区域。</p>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 字符串</title>
    <url>/2016/03/11/VC%E7%BC%96%E7%A8%8B%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>在任何编程过程中，字符串操作即广泛又重要。对于MFC，最通用的字符串类型就是CString，很多操作都要将数据转换为CString类型，以方便处理、共享、传递。</p>
<a id="more"></a>

<p>我们通常使用的CString，其实只是模版类CStringT的一个实例类，可以使用_T宏包裹一个字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_T(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>CStringT会根据实际需要使用UNICODE或是ANSII字符。</p>
<h4 id="Windows下处理字符的一些注意事项"><a href="#Windows下处理字符的一些注意事项" class="headerlink" title="Windows下处理字符的一些注意事项"></a>Windows下处理字符的一些注意事项</h4><ol>
<li>我们在建立MFC程序时，可以去掉“使用Unicode库”前面的勾，来简化字符处理（强烈推荐）。如果勾选了那个选项，在每次使用字符串常量时，应在前面加上L，例如<code>L”abcdef”</code>。</li>
<li>勾选了“使用Unicode库”的情况下，字符数组char a[]转换为CString需要强制转换，例如<code>(CStringW)a</code>；如果未勾选，则可以直接赋值给CString对象，例如<code>CString str = a</code>。</li>
<li>每个汉字占两个字符。</li>
<li>Windows的一个回车等价于\r\n，无论从文件获取一行，还是写入文件一行，都要注意这一点。</li>
<li>Windows的文件路径用反斜杠\分隔，在代码中需要转义，例如<code>CString path = “C:\\Windows\\system32”</code>。</li>
</ol>
<h4 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CStringT::<span class="keyword">operator</span> =	<span class="comment">//给CString对象赋一个字符串。</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> +	<span class="comment">//连接两个字符串。</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> +=	<span class="comment">//将新字符串连接到现有字符串的末尾。</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> ==	<span class="comment">//确定两个字符串是否逻辑上相等。</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> !=	<span class="comment">//确定两个字符串是否逻辑上不相等。</span></span><br><span class="line"><span class="comment">/* 判断字符串大小的标准 */</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> &lt;	<span class="comment">//如果找到两个不相等的相应字符，</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> &gt;	<span class="comment">//则将比较结果作为字符串之间比较的结果。</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> &lt;=	<span class="comment">//如果找到的所有字符完全相同，</span></span><br><span class="line">CStringT::<span class="keyword">operator</span> &gt;=	<span class="comment">//字符多的判断为大。</span></span><br></pre></td></tr></table></figure>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CStringT::Delete(<span class="keyword">int</span> Index, <span class="keyword">int</span> Count = <span class="number">1</span>)      <span class="comment">//从Index（基于0）起，删除Count个字符。</span></span><br><span class="line">CStringT::Insert(<span class="keyword">int</span> Index, PCXSTR psz)         <span class="comment">//在Index处，插入字符串psz，剩下的字符接在psz的末尾。</span></span><br><span class="line">CStringT::Replace(PCXSTR pszOld, PCXSTR pszNew) <span class="comment">//用字符串pszNew取代字符串pszOld。pszNew可以比pszOld更长。</span></span><br><span class="line">CStringT::Find(PCXSTR pszSub, <span class="keyword">int</span> iStart = <span class="number">0</span>)   <span class="comment">//返回字符串pszSub在主串中的位置，默认从主串索引0开始搜索。</span></span><br><span class="line">CStringT::ReverseFind(XCHAR ch) <span class="comment">//从末尾开始在主串中查找字符ch，返回ch在主串中的正向位置。</span></span><br><span class="line">CStringT::Right(<span class="keyword">int</span> nCount)     <span class="comment">//返回从最右端提取的nCount个字符。</span></span><br><span class="line">CStringT::Left(<span class="keyword">int</span> nCount)      <span class="comment">//返回从最左端提取的nCount个字符。</span></span><br><span class="line">CStringT::Mid(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> nCount)   <span class="comment">//从iFirst起，返回nCount个字符。</span></span><br><span class="line">CStringT::Mid(<span class="keyword">int</span> iFirst)       <span class="comment">//返回从iFirst起直到末尾的字符。</span></span><br><span class="line">CStringT::MakeLower()           <span class="comment">//将此字符串中的所有字符转换为小写字符。</span></span><br><span class="line">CStringT::MakeUpper()           <span class="comment">//将此字符串中的所有字符都转换为大写字符。</span></span><br><span class="line">CStringT::MakeReverse()         <span class="comment">//反转字符串。</span></span><br></pre></td></tr></table></figure>
<p>上述函数形参中的PCXSTR类型，可以直接使用字符串常量或CString对象作为实参。Delete、Insert、Replace、Find都重载了字符版本，就是形参中的PCXSTR类型变成了XCHAR类型。</p>
<h4 id="CStringT继承CSimpleStringT的一些有用函数"><a href="#CStringT继承CSimpleStringT的一些有用函数" class="headerlink" title="CStringT继承CSimpleStringT的一些有用函数"></a>CStringT继承CSimpleStringT的一些有用函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CSimpleStringT::Empty()                    <span class="comment">//将当前CString变量清空，字符长度为零。</span></span><br><span class="line">CSimpleStringT::IsEmpty()                  <span class="comment">//测试是否为空。</span></span><br><span class="line">CSimpleStringT::GetAt(<span class="keyword">int</span> iChar)           <span class="comment">//返回iChar位置的字符。</span></span><br><span class="line">CSimpleStringT::SetAt(<span class="keyword">int</span> iChar, XCHAR ch) <span class="comment">//将iChar位置的字符设置为ch。</span></span><br><span class="line">CSimpleStringT::GetBuffer()                <span class="comment">//返回字符缓冲区指针。</span></span><br><span class="line">CSimpleStringT::GetLength()                <span class="comment">//返回字符数。</span></span><br></pre></td></tr></table></figure>
<h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CStringT::Format(PCXSTR pszFormat, [, argument] ...)   <span class="comment">//按照pszFormat格式化字符串，后面的argument为pszFormat提供各种类型的数据。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>%d 十进制整数(int)</li>
<li>%u 无符号十进制数</li>
<li>%f 十进制浮点数(float)</li>
<li>%o 八进制数</li>
<li>%x 十六进制数</li>
<li>%c 单个字符</li>
<li>%s 字符串</li>
</ul>
<p>由此看出，使用Format主要是用来将数字转换为CString。例如，获取当前系统时间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CTime t = CTime::GetCurrentTime();</span><br><span class="line">CString m_strTime;</span><br><span class="line">m_strTime.Format(<span class="string">&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">	t.GetYear(),t.GetMonth(),t.GetDay(),</span><br><span class="line">	t.GetHour(),t.GetMinute(),t.GetSecond());</span><br></pre></td></tr></table></figure>
<h4 id="与TCHAR数组的转换"><a href="#与TCHAR数组的转换" class="headerlink" title="与TCHAR数组的转换"></a>与TCHAR数组的转换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString edt2 = <span class="string">&quot;abcdef&quot;</span>;                <span class="comment">//CString -&gt; TCHAR</span></span><br><span class="line">TCHAR *str = <span class="keyword">new</span> TCHAR(<span class="number">10</span>);</span><br><span class="line">str = edt2.GetBuffer(edt2.GetLength());</span><br><span class="line"></span><br><span class="line">CString edt3 = str;                    <span class="comment">//TCHAR -&gt; CString</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>RG沙扎比</title>
    <url>/2019/12/24/RG%E6%B2%99%E6%89%8E%E6%AF%94/</url>
    <content><![CDATA[<p>沙扎比（SAZABI）MSN-04是赤色彗星夏亚的最后一台机体，无论是动漫还是模型都颇具人气。个人觉得沙扎比是高达系列里造型最好的机体，所以这个是必入的。最初接触到的是卡版沙扎比，各方面都好，就是总觉得体型太大了，严重与其他MG模型不搭。RG沙扎比体型适中，造型细节很好，我个人更偏爱这个版本。</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2021/10/06/VaIUbXGFSLqwlAy.png" alt="沙扎比-1.png"></p>
<p>模型特性：采用拼装骨架结构紧实、隐藏水口，可动优秀（可调整大腿位置），可以爆甲，外甲有一定的分色。</p>
<p><img src="https://i.loli.net/2021/10/06/5OQH4ZUTC6FgqKc.png" alt="沙扎比-2.png"></p>
<h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ol>
<li>这个RG沙扎比的料子感觉比龟霸软，用指甲按就会出现痕迹，盾牌尖锐部分轻易就会卷边。其结构相对于其他RG机体虽然算的上紧实，但还是没法跟MG2.0时期的东西比。</li>
<li>弧形件水口用打磨板也能处理。这样对我来说，海绵砂纸就没什么用了，也许可以用来处理“水波纹”。</li>
<li>有点想买模型专用锉刀，尤其是600目切割力的，因为600目砂纸用的太费，修不了几个水口就没有切削力了，换砂纸实在太麻烦。</li>
<li>再次强调：无论是模型专用单刃钳，还是锉刀，硬度都比较高。硬度高的钢通常易断易锈，所以一定不要沾湿，每次最好准备一块布来擦拭。</li>
<li>一定要相信万代的做工，只要是接插不顺，必定是你错了。</li>
</ol>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Gundam</category>
      </categories>
      <tags>
        <tag>Gundam</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 定时器</title>
    <url>/2016/03/25/VC%E7%BC%96%E7%A8%8B%20%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>从名字看，定时器更像是硬件相关的东西；从功能上看，MFC定时器也确实跟单片机的定时器类似。MFC定时器的使用分为三个步骤：安装、响应、结束。</p>
<a id="more"></a>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT_PTR nIDEvent,  <span class="comment">//一个整数，用于标识定时器</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nElapse,       <span class="comment">//多长间隔发出一个WM_TIMER消息，单位毫秒</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (CALLBACK* lpfnTimer)(HWND,    <span class="comment">//回调函数地址，一般设置为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT,</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT_PTR,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD))</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数lpfnTimer接受一个回调函数（用于处理WM_TIMER消息）地址，如果为NULL，则WM_TIMER消息将被放置在应用程序的消息队列中，并由CWnd对象处理。</p>
<p>SetTimer是CWnd类的成员函数，所以可以在程序中直接调用。此函数将一个定时器安装到系统中，每当nElapse时间间隔，系统都会将WM_TIMER消息发布到消息队列中，或将消息传递给应用程序定义的TimerProc回调函数。</p>
<p>例：在OnInitDialog中设置两个定时器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">SetTimer(<span class="number">1</span>,<span class="number">5000</span>,<span class="literal">NULL</span>);<span class="comment">//定时器1，每5秒触发</span></span><br><span class="line">SetTimer(<span class="number">2</span>,<span class="number">10000</span>,<span class="literal">NULL</span>);<span class="comment">//定时器2，每10秒触发</span></span><br></pre></td></tr></table></figure>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>响应定时器是通过响应WM_TIMER消息完成的。我们在类向导中选择合适的类，添加WM_TIMER消息响应函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CArrayAndListDlg::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    <span class="keyword">switch</span> (nIDEvent)<span class="comment">//多定时器</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            AfxMessageBox(<span class="string">&quot;定时器1：只触发一次！&quot;</span>);</span><br><span class="line">            KillTimer(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            LASTINPUTINFO lputinfo;</span><br><span class="line">            lputinfo.cbSize = <span class="keyword">sizeof</span>(lputinfo);<span class="comment">//必须赋值，否则无效</span></span><br><span class="line">            GetLastInputInfo(&amp;lputinfo);<span class="comment">//获取系统最后输入时间</span></span><br><span class="line">            <span class="keyword">if</span> (GetTickCount()-lputinfo.dwTime &gt; <span class="number">60000</span>)<span class="comment">//1分钟</span></span><br><span class="line">            &#123;</span><br><span class="line">                AfxMessageBox(<span class="string">&quot;定时器2：当系统无输入1分钟时结束！&quot;</span>);</span><br><span class="line">                KillTimer(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDialogEx::OnTimer(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span>;<span class="comment">//结束nIDEvent定时器</span></span><br></pre></td></tr></table></figure>
<p>它也是CWnd类的成员函数，故而也可以直接调用。</p>
]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 对话框</title>
    <url>/2015/08/15/VC%E7%BC%96%E7%A8%8B%20%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    <content><![CDATA[<p>我们点击某个菜单项或某个按钮，会弹出一个对话框，以进行某个子功能。这个子对话框可以根据实际需要自行定义，也可以使用现成的通用对话框。</p>
<a id="more"></a>

<h4 id="自定义对话框"><a href="#自定义对话框" class="headerlink" title="自定义对话框"></a>自定义对话框</h4><p>在资源视图下，插入Dialog资源，默认会有两个按钮：OK（IDOK）和Cancel(IDCANCEL)。这两个按钮比较特殊，其ID是固定的，如果误删除了，可以添加两个按钮并修改ID为那两个固定ID即可。用户点击这两个按钮，会调用OnOK()和OnCancel()，由于这两个函数内部调用了EndDialog，所以点击这两个按钮会关闭对话框。</p>
<p>选中对话框资源，可以修改对话框样式，比如Font(Size)修改字体字号，Caption调整标题等等。设置后ID后，双击对话框资源为其关联对话框子类（继承于CDialog）。这个子类初始只有DoDataExchange函数。</p>
<p>要想显示自定义对话框，需要在主程序框架头文件中引入自定义对话框头文件，然后建立自定义对话框类对象。使用这个对象可以创建两种对话框：模态和非模态。模态对话框只有在退出后才能控制主程序，非模态对话框没有这个限制。</p>
<p>一、模态对话框</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDlgModel m_DlgModel;</span><br><span class="line"><span class="keyword">if</span> (m_DlgModel.DoModal() == IDOK)<span class="comment">//以模态对话框运行</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;cancel&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>DoModal的返回值应为IDOK或IDCANCEL。在子对话框结束时，调用OnOK关闭对话框会返回IDOK，调用OnCancel关闭对话框会返回IDCANCEL。我们利用这一点可以根据返回的结果，分情况编写处理代码。通过类对象可以获取子对话框成员变量、函数。</p>
<p>二、非模态对话框</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_DlgNoM.Create(IDD_DIALOG_NOMODEL,<span class="keyword">this</span>);    <span class="comment">//创建对话框</span></span><br><span class="line">m_DlgNoM.ShowWindow(SW_SHOW);                <span class="comment">//显示对话框</span></span><br></pre></td></tr></table></figure>
<p>模态对话框的创建、关闭很不自然，一般情况下不建议使用。m_DlgNoM的定义不能直接放在某个响应函数中，因为Create不能阻塞函数执行。当函数执行结束，这个对象就会销毁，表现出来就是这个对话框会一闪而过，所以一般有两种方法解决这个问题：1.把这个对象作为主程序类的成员变量，2.把这个对象定义在堆上。</p>
<p>在非模态对话框完成工作后，不能直接调用OnOK或OnCancel关闭程序。因为这两个函数内部的EndDialog不能销毁对话框，当再次运行Create创建非模态对话框时会发生冲突。使用DestroyWindow()可以正常结束非模态对话框。</p>
<h4 id="文件对话框"><a href="#文件对话框" class="headerlink" title="文件对话框"></a>文件对话框</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">file</span><span class="params">(TRUE)</span></span>; <span class="comment">//true打开对话框，false另存为对话框</span></span><br><span class="line">CString Path;</span><br><span class="line">CString FileName;</span><br><span class="line"><span class="keyword">if</span> (IDOK == file.DoModal())</span><br><span class="line">&#123;</span><br><span class="line">    Path = file.GetPathName();        <span class="comment">//获取文件全路径</span></span><br><span class="line">    FileName = file.GetFileName();    <span class="comment">//获取文件名</span></span><br><span class="line">    <span class="comment">//根据文件名对文件进行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CFileDialog的构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CFileDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bOpenFileDialog,            <span class="comment">//true打开文件，false另存为文件</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszDefExt = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszFileName = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszFilter = <span class="literal">NULL</span>,       <span class="comment">//设置过滤器</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CWnd* pParentWnd = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwSize = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bVistaStyle = TRUE)</span></span>;</span><br></pre></td></tr></table></figure>
<p>打开文件只需给出第一个参数即可，另存为文件可以给出过滤器，格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> TCHAR BASED_CODE szFilter[] = _T(<span class="string">&quot;Word Files (*.doc;*.docx)|*.doc;*.docx|&quot;</span>)</span><br><span class="line">    _T(<span class="string">&quot;Worksheet Files (*.xls)|*.xls|Text Files (*.txt)|&quot;</span>)</span><br><span class="line">    _T(<span class="string">&quot;*.txt|All Files (*.*)|*.*||&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="颜色对话框"><a href="#颜色对话框" class="headerlink" title="颜色对话框"></a>颜色对话框</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CColorDialog color;</span><br><span class="line"><span class="keyword">int</span> R,G,B;</span><br><span class="line"><span class="keyword">if</span> (IDOK == color.DoModal())            <span class="comment">//按下了颜色对话框中的OK按钮</span></span><br><span class="line">&#123;</span><br><span class="line">    COLORREF temp = color.GetColor();   <span class="comment">//得到选择的颜色</span></span><br><span class="line">    R = GetRValue(temp);                <span class="comment">//分别得到RGB值</span></span><br><span class="line">    G = GetGValue(temp);</span><br><span class="line">    B = GetBValue(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字体对话框"><a href="#字体对话框" class="headerlink" title="字体对话框"></a>字体对话框</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFontDialog font;</span><br><span class="line"><span class="keyword">if</span> (IDOK == font.DoModal())</span><br><span class="line">&#123;</span><br><span class="line">    LOGFONT lgFont;                    <span class="comment">//字体信息结构，不包括颜色</span></span><br><span class="line">    font.GetCurrentFont(&amp;lgFont);      <span class="comment">//把当前选择的字体保存到lgFont</span></span><br><span class="line">    CFont cFont;                       <span class="comment">//设置字体只能通过CFont</span></span><br><span class="line">    cFont.CreateFontIndirect(&amp;lgFont); <span class="comment">//转化为CFont</span></span><br><span class="line">    GetDlgItem(IDC_STATIC)-&gt;SetFont(&amp;cFont,TRUE);<span class="comment">//调用CWnd方法设置静态控件的字体，TRUE代表重绘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印对话框"><a href="#打印对话框" class="headerlink" title="打印对话框"></a>打印对话框</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CPrintDialog <span class="title">print</span><span class="params">(FALSE)</span></span>;      <span class="comment">//false表示带设置对话框，true表示不带设置对话框</span></span><br><span class="line">CString str;</span><br><span class="line"><span class="keyword">if</span> (IDOK == print.DoModal())</span><br><span class="line">&#123;</span><br><span class="line">    str.Format(<span class="string">&quot;%s-%s-%s&quot;</span>,</span><br><span class="line">        print.GetDeviceName(),  <span class="comment">//设备名</span></span><br><span class="line">        print.GetPortName(),    <span class="comment">//设备端口</span></span><br><span class="line">        print.GetDriverName()); <span class="comment">//设备驱动</span></span><br><span class="line">&#125;</span><br><span class="line">AfxMessageBox(str);</span><br></pre></td></tr></table></figure>
<p>CPrintDialog中还有很多成员函数，在现实开发中可以参考使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFromPage</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//得到打印起始页</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetToPage</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">//得到打印结束页</span></span><br><span class="line"><span class="function">LPDEVMODE <span class="title">GetDevMode</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//得到DEVMODE结构</span></span><br><span class="line"><span class="function">HDC <span class="title">GetPrinterDC</span><span class="params">()</span> <span class="keyword">const</span></span>;     <span class="comment">//打印设备内容句柄</span></span><br></pre></td></tr></table></figure>
<h4 id="替换查找对话框"><a href="#替换查找对话框" class="headerlink" title="替换查找对话框"></a>替换查找对话框</h4><p>与上面那几个通用对话框不同，需要将替换查找对话框建立为非模态对话框。这里在堆中建立CFindReplaceDialog对象，使用DestroyWindow()关闭窗口，在对话框被破坏时CFindReplaceDialog对象被自动释放。</p>
<p>弹出替换查找对话框的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    m_pFRDlg = <span class="keyword">new</span> CFindReplaceDialog();        <span class="comment">//非模态对话框在堆中建立</span></span><br><span class="line">    m_pFRDlg-&gt;Create(FALSE, _T(<span class="string">&quot;&quot;</span>), _T(<span class="string">&quot;&quot;</span>), FR_DOWN, <span class="keyword">this</span>);</span><br><span class="line">    m_pFRDlg-&gt;m_fr.lStructSize = <span class="keyword">sizeof</span>(FINDREPLACE);</span><br><span class="line"><span class="comment">//  m_pFRDlg-&gt;m_fr.hwndOwner = this-&gt;m_hWnd;</span></span><br><span class="line"><span class="comment">//  m_pFRDlg-&gt;m_fr.lpstrFindWhat = m_pFRDlg-&gt;GetFindWhatStr();</span></span><br><span class="line"><span class="comment">//  m_pFRDlg-&gt;m_fr.lpstrReplaceWith = m_pFRDlg-&gt;GetReplaceWithStr();</span></span><br><span class="line"><span class="comment">//  m_pFRDlg-&gt;m_fr.wFindWhatLen = m_pFRDlg-&gt;GetFindWhatStrLen();</span></span><br><span class="line"><span class="comment">//  m_pFRDlg-&gt;m_fr.wReplaceWithLen = m_pFRDlg-&gt;GetReplaceWithStrLen();</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>m_pFRDlg被当作父窗口类成员变量，定义在头文件中。其中的m_fr为CFindReplaceDialog的成员变量，类型为FINDREPLACE，其中保存了一些对话框特性。</p>
</blockquote>
<p>当用户点击按钮查找下一个、替换、替换全部或者关闭对话框时，查找替换对话框会向父窗口发送WM_FINDREPLACE消息，需要手动添加这个消息的响应：</p>
<p>一、在父窗口类头文件中键入消息定义（当作全局变量）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> UINT WM_FINDREPLACE = ::RegisterWindowMessage(FINDMSGSTRING);</span><br></pre></td></tr></table></figure>
<p>二、在父窗口类头文件中键入消息处理函数声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">afx_msg LONG <span class="title">OnFindReplace</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br></pre></td></tr></table></figure>
<p>三、在END_MESSAGE_MAP()中添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ON_REGISTERED_MESSAGE(WM_FINDREPLACE, &amp;CGeraDlgDlg::OnFindReplace)</span><br></pre></td></tr></table></figure>
<p>四、在父窗口类cpp文件中键入消息处理函数的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">CGeraDlgDlg::OnFindReplace</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CString str = m_pFRDlg-&gt;GetFindString();</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在消息处理函数中，可以使用m_pFRDlg调用其成员函数，获取并处理信息。下面是一些CFindReplaceDialog成员函数的介绍：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">Create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bFindDialogOnly,        <span class="comment">//true查找对话框，false查找替换对话框</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszFindWhat,        <span class="comment">//默认查找字符串，为NULL就没有默认字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszReplaceWith = <span class="literal">NULL</span>,	<span class="comment">//默认替换字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwFlags = FR_DOWN,     <span class="comment">//选项，默认向下</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CWnd* pParentWnd = <span class="literal">NULL</span>)</span></span>;    <span class="comment">//为NULL将主窗口作为父窗口</span></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">()</span> <span class="keyword">const</span></span>;           <span class="comment">//如果想要找下一个字符串返回非0</span></span><br><span class="line"><span class="function">CString <span class="title">GetFindString</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">//返回需要查找的字符串</span></span><br><span class="line"><span class="function">CString <span class="title">GetReplaceString</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//返回需要替换的字符串</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceAll</span><span class="params">()</span> <span class="keyword">const</span></span>;         <span class="comment">//判断用户是否全部替换</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReplaceCurrent</span><span class="params">()</span> <span class="keyword">const</span></span>;     <span class="comment">//是否替换当前字符串</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsTerminating</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//用户是否终止查找</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 文件</title>
    <url>/2016/03/15/VC%E7%BC%96%E7%A8%8B%20%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>文件是任何系统最基本的资源，通常作为程序输入输出的对象。对于MFC，最基本的操作文件类就是CFile，它提供了众多基本函数，比如文件读写、移动读写指针等。当然，还有其他的文件操作类，简化了一些操作，但基本的使用思路没什么不同。</p>
<a id="more"></a>

<h4 id="CFile基本操作"><a href="#CFile基本操作" class="headerlink" title="CFile基本操作"></a>CFile基本操作</h4><p><strong>一 创建</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFile(    <span class="comment">//构造函数</span></span><br><span class="line">    LPCTSTR lpszFileName,    <span class="comment">//文件路径</span></span><br><span class="line">    UINT nOpenFlags);        <span class="comment">//访问选项</span></span><br></pre></td></tr></table></figure>
<p>参数nOpenFlags可选择如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFile::modeRead         <span class="comment">//只读属性</span></span><br><span class="line">CFile::modeWrite        <span class="comment">//只写属性</span></span><br><span class="line">CFile::modeReadWrite    <span class="comment">//读写访问</span></span><br><span class="line">CFile::modeCreate       <span class="comment">//如果文件不存在创建文件，如果存在则覆盖并设置文件为空</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>模式可以组合使用，通过运算符 | 。</p>
</blockquote>
<p>创建文件主要靠的是参数modeCreate，所以创建一个文件除了通过CFile的构造函数，还可以通过下面的Open函数实现。使用构造函数创建文件对象，直接就打开了实际的文件。</p>
<p><strong>二 打开和关闭</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">Open</span><span class="params">(      <span class="comment">//以nOpenFlags属性打开lpszFileName路径的文件</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszFileName,    <span class="comment">//文件路径</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nOpenFlags,         <span class="comment">//访问选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CFileException* pError = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span>;        <span class="comment">//关闭一个文件并删除对象。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数lpszFileName可接受字符串常量或CString类型的变量。</p>
</blockquote>
<p>例：打开指定路径的文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString CurrentPath; </span><br><span class="line">GetModuleFileName(<span class="literal">NULL</span>,CurrentPath.GetBufferSetLength(MAX_PATH+<span class="number">1</span>),MAX_PATH+<span class="number">1</span>);  <span class="comment">//获取当前程序的路径</span></span><br><span class="line"><span class="keyword">int</span> i = CurrentPath.ReverseFind(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">CurrentPath = CurrentPath.Left(i+<span class="number">1</span>);</span><br><span class="line">CurrentPath += <span class="string">&quot;log.dat&quot;</span>;    <span class="comment">//当前程序路径下的日志文件路径</span></span><br><span class="line"></span><br><span class="line">CFile f;</span><br><span class="line"><span class="keyword">if</span> (f.Open(CurrentPath,CFile::modeRead))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进行文件操作</span></span><br><span class="line">    f.Close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;文件打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>三 读写</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> UINT <span class="title">Read</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* lpBuf,        <span class="comment">//接收数据缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nCount)</span></span>;       <span class="comment">//读取的最大字节数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span>* lpBuf,  <span class="comment">//包含待写入数据的缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nCount)</span></span>;       <span class="comment">//要从缓冲区传输的字节数</span></span><br></pre></td></tr></table></figure>
<p>从这两个函数的缓冲区类型上看，MFC并没有对其进行严格的限制，通常可以作为缓冲区的参数类型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>]        <span class="comment">//1.字符数组</span></span><br><span class="line">str.GetBuffer()   <span class="comment">//2.CString缓冲区</span></span><br></pre></td></tr></table></figure>
<p>例：读取日志并根据用户名得到密码<br>我们假设待读取的文件内容为姓名和密码，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">张三	m123ad242</span><br><span class="line">李四	acs003342</span><br><span class="line">王五	skdlfjs32</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：log.dat文件的字符格式应为GBK，否则获取中文会得到乱码。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件已open</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">CString Name = <span class="string">&quot;&quot;</span>;    <span class="comment">//收集姓名</span></span><br><span class="line">CString No = <span class="string">&quot;&quot;</span>;      <span class="comment">//收集编号</span></span><br><span class="line"><span class="keyword">while</span> (a != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    f.Read(&amp;a,<span class="number">1</span>);<span class="comment">//获取本行第一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Name += a;</span><br><span class="line">            f.Read(&amp;a,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Name == <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f.Read(&amp;a,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                No += a;</span><br><span class="line">                f.Read(&amp;a,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (a != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                f.Read(&amp;a,<span class="number">1</span>);</span><br><span class="line">            Name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件读取指针是每调用一次Read，自动更新指针到下一个位置。</p>
<p>例：在文件末尾写入信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件已open</span></span><br><span class="line">CString name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">CString str = name + <span class="string">&quot;下线&quot;</span> + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">f.SeekToEnd();	<span class="comment">//移动文件指针到末尾</span></span><br><span class="line">f.Write(str,str.GetLength());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>写入的字符格式也是GBK。</p>
</blockquote>
<p><strong>四 定位</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ULONGLONG <span class="title">Seek</span><span class="params">(    <span class="comment">//移动文件指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LONGLONG lOff,         <span class="comment">//移动的字节数，正值表示从前向后移动，负值则从后向前移动。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nFrom)</span></span>;           <span class="comment">//当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekToBegin</span><span class="params">()</span></span>;        <span class="comment">//移动到文件开始</span></span><br><span class="line"><span class="function">ULONGLONG <span class="title">SeekToEnd</span><span class="params">()</span></span>;     <span class="comment">//移动到文件末尾</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ULONGLONG <span class="title">GetPosition</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//获取当前的文件指针的位置</span></span><br></pre></td></tr></table></figure>
<p>参数nFrom可以选择如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFile::begin        <span class="comment">//从文件开始（从0计）</span></span><br><span class="line">CFile::current      <span class="comment">//从当前位置</span></span><br><span class="line">CFile::end          <span class="comment">//从文件末尾</span></span><br></pre></td></tr></table></figure>
<p>Seek如果移动指针失败，则返回一个未定义值并抛出一个CFileException异常。</p>
<p>例：定位到文件最后一个字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>.Seek(<span class="number">-1</span>,CFile::end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (CFileException* e)</span><br><span class="line">&#123;</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;当前文件空&quot;</span>);</span><br><span class="line">    flag = <span class="number">1</span>;    <span class="comment">//出现异常置位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>五 大小，改名、删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ULONGLONG <span class="title">GetLength</span><span class="params">()</span> <span class="keyword">const</span></span>;           <span class="comment">//返回文件的尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLength</span><span class="params">(ULONGLONG dwNewLen)</span></span>;    <span class="comment">//设置文件的尺寸。dwNewLen可以大于或小于文件尺寸。源文件会被放大或截断，放大部分用0x0填充。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> PASCAL <span class="title">Rename</span><span class="params">(      <span class="comment">//重命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszOldName,        <span class="comment">//老路径名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszNewName,        <span class="comment">//新路径名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CAtlTransactionManager* pTM = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> PASCAL <span class="title">Remove</span><span class="params">(      <span class="comment">//移除文件</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszFileName,       <span class="comment">//路径名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CAtlTransactionManager* pTM = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Rename和Remove都是静态函数，可以直接调用，例如CFile::Remove。</p>
</blockquote>
<p><strong>六 属性</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetStatus</span><span class="params">(CFileStatus&amp; rStatus)</span> <span class="keyword">const</span></span>;    <span class="comment">//获得文件的状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BOOL PASCAL <span class="title">GetStatus</span><span class="params">(        <span class="comment">//获得文件状态（静态版本）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">    CFileStatus&amp; rStatus,            <span class="comment">//用于接收文件状态</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CAtlTransactionManager* pTM = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> PASCAL <span class="title">SetStatus</span><span class="params">(        <span class="comment">//设置文件状态</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CFileStatus&amp; status,       <span class="comment">//通过提前填充CFileStatus对象来设置</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CAtlTransactionManager* pTM = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>CFileStatus成员：</p>
<ul>
<li>CTime m_ctime 文件创建日期时间</li>
<li>CTime m_mtime 文件最后修改日期时间</li>
<li>CTime m_atime 文件最后访问日期时间</li>
<li>ULONGLONG m_size 文件尺寸（字节）</li>
<li>BYTE m_attribute 文件属性</li>
<li>char m_szFullName[_MAX_PATH] 文件名</li>
</ul>
<p>m_attribute数据：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Attribute</span> &#123;</span></span><br><span class="line">    normal =    <span class="number">0x00</span>,</span><br><span class="line">    readOnly =  <span class="number">0x01</span>,</span><br><span class="line">    hidden =    <span class="number">0x02</span>,</span><br><span class="line">    system =    <span class="number">0x04</span>,</span><br><span class="line">    volume =    <span class="number">0x08</span>,</span><br><span class="line">    directory = <span class="number">0x10</span>,</span><br><span class="line">    archive =   <span class="number">0x20</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>例：获取文件大小和创建时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFileStatus status;</span><br><span class="line"><span class="keyword">if</span>(f.GetStatus(status))</span><br><span class="line">&#123;</span><br><span class="line">    m_Edit1.Format(<span class="string">&quot;%d&quot;</span>,status.m_size);</span><br><span class="line">    m_Edit2.Format(<span class="string">&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">        status.m_ctime.GetYear(),status.m_ctime.GetMonth(),status.m_ctime.GetDay(),</span><br><span class="line">        status.m_ctime.GetHour(),status.m_ctime.GetMinute(),status.m_ctime.GetSecond());</span><br><span class="line">    m_Edit3.Format(<span class="string">&quot;0x%x&quot;</span>,status.m_attribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：设置文件属性为隐藏</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFileStatus t;</span><br><span class="line">t.m_size = <span class="number">0</span>;	</span><br><span class="line">t.m_attribute |= CFile::hidden;</span><br><span class="line">CFile::SetStatus(CurrentPath,t);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果CFileStatus对象中的某项被设置为0，那么这一项不会更新。</p>
</blockquote>
<h4 id="CStdioFile基本操作"><a href="#CStdioFile基本操作" class="headerlink" title="CStdioFile基本操作"></a>CStdioFile基本操作</h4><p>CStdioFile继承自CFile，提供了行读写函数。</p>
<p><strong>一 读取一行</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> LPTSTR <span class="title">ReadString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LPTSTR lpsz,       <span class="comment">//指定一个字符缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nMax)</span></span>;        <span class="comment">//最大接收字符数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">ReadString</span><span class="params">(CString&amp; rString)</span></span>;    <span class="comment">//接收一个CString对象</span></span><br></pre></td></tr></table></figure>
<p>通常，接收CString对象的版本更加实用。ReadString每次获取一行，但不获取每行末尾的\r\n，使用起来非常方便。读取正常的话，rString每次都能获取一行字符，如果到达文件末尾，rString会得到NULL，函数返回False。</p>
<p>例：读取每行信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CStdioFile <span class="built_in">log</span>;</span><br><span class="line">CString Line, str;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">log</span>.Open(<span class="string">&quot;H:\\log.dat&quot;</span>,CFile::modeRead))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>.ReadString(Line);</span><br><span class="line">    str.Format(<span class="string">&quot;%d&quot;</span>,Line.GetLength());<span class="comment">//不包括\r\n</span></span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">log</span>.ReadString(Line))	<span class="comment">//抵达末尾，返回空</span></span><br><span class="line">        AfxMessageBox(Line);</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;抵达文件末尾&quot;</span>);</span><br><span class="line">    <span class="built_in">log</span>.Close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessage(<span class="string">&quot;log打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>二 写入一行</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteString</span><span class="params">(LPCTSTR lpsz)</span></span>;</span><br></pre></td></tr></table></figure>
<p>WriteString没有什么特别之处，与CFile的Write类似，将lpsz缓冲区内的字符串直接写入文件，并没有在末尾自动添加\r\n这类东西。</p>
<p>例：写入三行信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//log文件以modeWrite打开</span></span><br><span class="line"><span class="built_in">log</span>.WriteString(<span class="string">&quot;张三\t123456\r\n&quot;</span>);    <span class="comment">//写入时同样不会添加\r\n</span></span><br><span class="line"><span class="built_in">log</span>.WriteString(<span class="string">&quot;李四\t123456\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">log</span>.WriteString(<span class="string">&quot;王五\t123456&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 容器</title>
    <url>/2016/03/23/VC%E7%BC%96%E7%A8%8B%20%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>编程离不开数据结构，在MFC下也不例外，我们需要能够保存各种数据类型的容器，以方便存取。数组和单链表是最基本的容器，通常利用编程语言自带的中括号和结构体、指针等语法自行实现。但是，使用这些技术无法处理自定义类型（class）的数据，故而需要系统提供的CArray和CList。</p>
<a id="more"></a>

<h4 id="CArray"><a href="#CArray" class="headerlink" title="CArray"></a>CArray</h4><p>CArray实现了数组功能，从位置0开始计数，能够动态减少和增长。定义一个CArray数组如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CArray&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; iData;              <span class="comment">//定义一个int数组</span></span><br><span class="line">CArray&lt;CString,CString&amp;&gt; strData;   <span class="comment">//定义一个CString数组</span></span><br><span class="line">CArray&lt;CPoint&gt; pointData;           <span class="comment">//定义一个CPoint数组</span></span><br></pre></td></tr></table></figure>
<p>尖括号内信息指定了数据类型的模版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">TYPE</span>, <span class="keyword">class</span> <span class="title">ARG_TYPE</span> =</span> <span class="keyword">const</span> TYPE&amp;&gt;</span><br></pre></td></tr></table></figure>
<p>TYPE指定了存储在数组中的数据类型。ARG_TYPE指定了CArray对象作为参数时传递的是数据还是地址。我们通常只填充TYPE，就像第三个例子那样定义CArray对象。</p>
<p>一 基本操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">INT_PTR <span class="title">Add</span><span class="params">(ARG_TYPE newElement)</span></span>;   <span class="comment">//添加对应类型的数据到数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(<span class="keyword">const</span> CArray&amp; src)</span></span>;       <span class="comment">//复制src数组内容到调用者</span></span><br><span class="line"><span class="function">INT_PTR <span class="title">Append</span><span class="params">(<span class="keyword">const</span> CArray&amp; src)</span></span>;  <span class="comment">//将src数组内容附加到调用者的末尾</span></span><br><span class="line"><span class="function">INT_PTR <span class="title">GetCount</span><span class="params">()</span> <span class="keyword">const</span></span>;           <span class="comment">//得到数组元素个数</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;               <span class="comment">//判断数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveAll</span><span class="params">()</span></span>;                   <span class="comment">//移除所有的元素</span></span><br></pre></td></tr></table></figure>
<p>在这里，Add函数起到了分配内存并赋值的作用。CArray重载了方括号[]，可以像操作普通数组那样，通过索引直接访问每个数组变量。</p>
<p>例：基本操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString str;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">CArray&lt;<span class="keyword">int</span>&gt; arr1,arr2;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)	<span class="comment">//分配10个空间</span></span><br><span class="line">    arr1.Add(<span class="number">0</span>);</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">arr2.Add(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">if</span> (arr2.IsEmpty())</span><br><span class="line">    arr2.Copy(arr1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    arr2.Append(arr1);</span><br><span class="line">arr2[<span class="number">10</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;arr2.GetCount(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    str.Format(<span class="string">&quot;%d&quot;</span>,arr2[i]);</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CList"><a href="#CList" class="headerlink" title="CList"></a>CList</h4><p>CList实现了链表功能，定义一个CList链表如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CList&lt;CString,CString&amp;&gt; strData;   <span class="comment">//定义一个CString链表</span></span><br><span class="line">CList&lt;CPoint&gt; pointData;           <span class="comment">//定义一个CPoint链表</span></span><br></pre></td></tr></table></figure>
<p>尖括号内信息指定了数据类型的模版，这个与CArray的模版相同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">TYPE</span>, <span class="keyword">class</span> <span class="title">ARG_TYPE</span> =</span> <span class="keyword">const</span> TYPE&amp;&gt;</span><br></pre></td></tr></table></figure>
<p>TYPE指定了存储在链表中的数据类型。ARG_TYPE指定了用于引用列表中对象的类型。通常，我们只填充TYPE。</p>
<p>一 添加与删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">POSITION <span class="title">AddHead</span><span class="params">(ARG_TYPE newElement)</span></span>;<span class="comment">//添加指定类型的元素到链表头部</span></span><br><span class="line"><span class="function">POSITION <span class="title">AddTail</span><span class="params">(ARG_TYPE newElement)</span></span>;<span class="comment">//添加指定类型的元素到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveAll</span><span class="params">()</span></span>;         <span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveAt</span><span class="params">(POSITION position)</span></span>;<span class="comment">//移除指定位置的元素</span></span><br><span class="line"><span class="function">TYPE <span class="title">RemoveHead</span><span class="params">()</span></span>;        <span class="comment">//移除链表头</span></span><br><span class="line"><span class="function">TYPE <span class="title">RemoveTail</span><span class="params">()</span></span>;        <span class="comment">//移除链表尾</span></span><br></pre></td></tr></table></figure>
<p>例：添加删除元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CList&lt;CPoint&gt; Li;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">5</span>; i&lt;<span class="number">10</span>; i++)<span class="comment">//5-9顺序存放</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">CPoint <span class="title">p</span><span class="params">(i,i+<span class="number">1</span>)</span></span>;</span><br><span class="line">    Li.AddTail(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)<span class="comment">//0-4逆序存放</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">CPoint <span class="title">p</span><span class="params">(i,i+<span class="number">1</span>)</span></span>;</span><br><span class="line">    Li.AddHead(p);</span><br><span class="line">&#125;</span><br><span class="line">Li.RemoveHead();<span class="comment">//删除4</span></span><br><span class="line">Li.RemoveTail();<span class="comment">//删除9</span></span><br></pre></td></tr></table></figure>
<p>二 查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">POSITION <span class="title">Find</span><span class="params">(                <span class="comment">//找到首个匹配searchValue元素的位置</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ARG_TYPE searchValue,     <span class="comment">//链表中的值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    POSITION startAfter = <span class="literal">NULL</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//查找的起始位置，默认从头开始</span></span><br><span class="line"></span><br><span class="line"><span class="function">POSITION <span class="title">FindIndex</span><span class="params">(INT_PTR nIndex)</span> <span class="keyword">const</span></span>;<span class="comment">//用值的索引获取位置，基于0</span></span><br></pre></td></tr></table></figure>
<p>上述两个函数当未发现指定值时，返回NULL。</p>
<p>例：查找元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString str;</span><br><span class="line"><span class="function">CPoint <span class="title">cp</span><span class="params">(<span class="number">6</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">POSITION p1 = Li.Find(cp);</span><br><span class="line">p1 = Li.FindIndex(<span class="number">5</span>);</span><br><span class="line">str.Format(<span class="string">&quot;%d&quot;</span>,Li.GetAt(p1).x);</span><br><span class="line">AfxMessageBox(str);</span><br></pre></td></tr></table></figure>
<p>三 获取与设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TYPE&amp; <span class="title">GetHead</span><span class="params">()</span></span>;        <span class="comment">//得到链表头元素</span></span><br><span class="line"><span class="function">TYPE&amp; <span class="title">GetTail</span><span class="params">()</span></span>;        <span class="comment">//得到链表尾元素</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function">TYPE&amp; <span class="title">GetAt</span><span class="params">(POSITION position)</span></span>;        <span class="comment">//根据position获取值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetAt</span><span class="params">(POSITION pos, ARG_TYPE newElement)</span></span>;<span class="comment">//将pos位置的值设置为newElement</span></span><br><span class="line"><span class="function">INT_PTR <span class="title">GetCount</span><span class="params">()</span> <span class="keyword">const</span></span>;              <span class="comment">//获取链表中元素的个数</span></span><br></pre></td></tr></table></figure>
<p>例：设置链表中元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CPoint <span class="title">cp</span><span class="params">(<span class="number">6</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">CPoint <span class="title">po</span><span class="params">(<span class="number">60</span>,<span class="number">70</span>)</span></span>;</span><br><span class="line">Li.SetAt(Li.Find(cp),po);</span><br></pre></td></tr></table></figure>
<p>四 遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">POSITION <span class="title">GetHeadPosition</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//得到链表头的位置，如果链表为空则返回NULL</span></span><br><span class="line"><span class="function">TYPE&amp; <span class="title">GetNext</span><span class="params">(POSITION&amp; rPosition)</span></span>;  <span class="comment">//得到rPosition位置的值，然后设置rPosition到后一项</span></span><br><span class="line"></span><br><span class="line"><span class="function">POSITION <span class="title">GetTailPosition</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//得到链表尾的位置，如果链表为空则返回NULL</span></span><br><span class="line"><span class="function">TYPE&amp; <span class="title">GetPrev</span><span class="params">(POSITION&amp; rPosition)</span></span>;  <span class="comment">//得到rPosition位置的值，然后设置rPosition到前一项</span></span><br></pre></td></tr></table></figure>
<p>当GetNext遍历到链表末尾，其参数rPosition被设置为NULL。</p>
<p>例：遍历链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">POSITION p2 = Li.GetHeadPosition();</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;Li.GetCount(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    str.Format(<span class="string">&quot;%d&quot;</span>,Li.GetNext(p2).x);</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五 插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">POSITION <span class="title">InsertAfter</span><span class="params">(POSITION position, ARG_TYPE newElement)</span></span>;<span class="comment">//添加newElement到position位置之后</span></span><br><span class="line"><span class="function">POSITION <span class="title">InsertBefore</span><span class="params">(POSITION position, ARG_TYPE newElement)</span></span>;<span class="comment">//添加newElement到position位置之前</span></span><br></pre></td></tr></table></figure>
<p>例：插入元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CPoint <span class="title">cp</span><span class="params">(<span class="number">6</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">CPoint <span class="title">po</span><span class="params">(<span class="number">60</span>,<span class="number">70</span>)</span></span>;</span><br><span class="line">Li.InsertAfter(Li.Find(cp),po);</span><br></pre></td></tr></table></figure>
<h4 id="CPtrList"><a href="#CPtrList" class="headerlink" title="CPtrList"></a>CPtrList</h4><p>CPtrList链表用于保存void指针，其成员函数与CObList类似。因为是专用于保存各种指针的链表，所以定义CPtrList对象无须填充模版。其包含的成员函数与CList基本相同，使用方法也基本一致。</p>
<p>例：自定义结构对象的入队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LocateInfo</span>&#123;</span></span><br><span class="line">    CString Serial;     <span class="comment">//序列号</span></span><br><span class="line">    CString Factory;    <span class="comment">//厂家</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CString ser,fac;</span><br><span class="line">CPtrList cpl;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)    <span class="comment">//将5个LocateInfo指针放入链表</span></span><br><span class="line">&#123;</span><br><span class="line">    ser += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    fac += <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    LocateInfo* locInfo = <span class="keyword">new</span> LocateInfo;<span class="comment">//用malloc不能有效的为CString成员分配空间</span></span><br><span class="line">    locInfo-&gt;Serial = ser;</span><br><span class="line">    locInfo-&gt;Factory = fac;</span><br><span class="line">    cpl.AddTail(locInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LocateInfo *info;</span><br><span class="line">CString str;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;	</span><br><span class="line">    info = (LocateInfo *)cpl.GetAt(cpl.FindIndex(i));<span class="comment">//需要强制转换</span></span><br><span class="line">    AfxMessageBox(info-&gt;Serial + <span class="string">&quot; &quot;</span> + info-&gt;Factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通常使用CPtrLisp对象保存自定义结构指针。值得注意的是，每次从CPtrLisp链表获取指针时，需要进行强制转换，将void指针转化为实际的指针类型。</p>
<h4 id="CMap"><a href="#CMap" class="headerlink" title="CMap"></a>CMap</h4><p>CMap实现了映射（Key，value）集合，定义一个CMap字典如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, CPoint, CPoint&gt; myData;    <span class="comment">//(int CPoint)</span></span><br></pre></td></tr></table></figure>
<p>尖括号内信息指定了数据类型的模版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY</span>, <span class="keyword">class</span> <span class="title">ARG_KEY</span>, <span class="keyword">class</span> <span class="title">VALUE</span>, <span class="keyword">class</span> <span class="title">ARG_VALUE</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">CMap</span> :</span> <span class="keyword">public</span> CObject</span><br></pre></td></tr></table></figure>
<p>KEY表示映射中的key。ARG_KEY指定了KEY作为参数时的类型。VALUE表示映射中的value。ARG_VALUE指定了VALUE作为参数时的类型。</p>
<p>一 基本函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitHashTable</span><span class="params">(UINT hashSize, BOOL  bAllocNow = TRUE)</span></span>;<span class="comment">//初始化，hashSize为容量</span></span><br><span class="line"><span class="function">INT_PTR <span class="title">GetCount</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//得到元素数</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveAll</span><span class="params">()</span></span>;            <span class="comment">//移除全部元素</span></span><br><span class="line"><span class="function">BOOL <span class="title">RemoveKey</span><span class="params">(ARG_KEY key)</span></span>; <span class="comment">//移除指定key的项</span></span><br></pre></td></tr></table></figure>
<p>定义CMap对象后，应使用InitHashTable初始化，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, CPoint, CPoint&gt; myMap;</span><br><span class="line">myMap.InitHashTable(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//添加10个元素</span></span><br><span class="line">    myMap[i] = CPoint(i, i);</span><br></pre></td></tr></table></figure>
<p>二 插入与检索</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Lookup</span><span class="params">(ARG_KEY key, VALUE&amp; rValue)</span> <span class="keyword">const</span></span>;    <span class="comment">//根据key获得指定值到rValue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetAt</span><span class="params">(ARG_KEY key, ARG_VALUE newValue)</span></span>;      <span class="comment">//将key位置的值设置为newValue</span></span><br></pre></td></tr></table></figure>
<p>通常我们可以通过[]访问指定key的值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接前面代码</span></span><br><span class="line">CPoint pt;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; myMap.Lookup(i, pt); i += <span class="number">2</span>)<span class="comment">//移除偶数key的元素</span></span><br><span class="line">    myMap.RemoveKey(i);</span><br><span class="line">myMap.SetAt(<span class="number">2</span>,CPoint(<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">CString str;</span><br><span class="line">str.Format(<span class="string">&quot;%d&quot;</span>,myMap[<span class="number">2</span>].x);</span><br><span class="line">AfxMessageBox(str);</span><br></pre></td></tr></table></figure>
<p>三 遍历函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">POSITION <span class="title">GetStartPosition</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//返回起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextAssoc</span><span class="params">(            <span class="comment">//获取每个映射的key和value</span></span></span></span><br><span class="line"><span class="function"><span class="params">    POSITION&amp; rNextPosition,  <span class="comment">//每次获取，自动更新到下一个位置。到达末尾，会被设置为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    KEY&amp; rKey,                <span class="comment">//返回key到这里</span></span></span></span><br><span class="line"><span class="function"><span class="params">    VALUE&amp; rValue)</span> <span class="keyword">const</span></span>;     <span class="comment">//返回value到这里</span></span><br></pre></td></tr></table></figure>
<p>下面是一个例子，在遍历过程中并不是按照索引顺序进行访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">POSITION pos = myMap.GetStartPosition();</span><br><span class="line"><span class="keyword">int</span> nKey;</span><br><span class="line">CPoint pt;</span><br><span class="line"><span class="keyword">while</span> (pos != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    myMap.GetNextAssoc(pos, nKey, pt);</span><br><span class="line">    str.Format(<span class="string">&quot;%d %d %d&quot;</span>,nKey,pt.x,pt.y);</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 对话框框架</title>
    <url>/2015/07/28/VC%E7%BC%96%E7%A8%8B%20%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>对话框框架是最基本的框架模版，通常的个人项目都选择这个。需要注意的是，在向导中最好不要勾选“使用Unicode库”，否则处理字符类型会很麻烦。</p>
<a id="more"></a>

<p>新创建的对话框程序默认有三个类：CNameDlg、CNameApp、CAboutDlg。其中标黑的Name为工程名。每个类对应两个文件，例如：</p>
<ul>
<li>C<strong>Name</strong>Dlg对应于<strong>Name</strong>Dlg.h和<strong>Name</strong>Dlg.cpp；</li>
<li>C<strong>Name</strong>App对应于<strong>Name</strong>.h和<strong>Name</strong>.cpp。</li>
</ul>
<h4 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h4><p>一、运行机制</p>
<ol>
<li>C<strong>Name</strong>App类中会定义全局对象theApp。theApp代表当前建立的应用程序。</li>
<li>C<strong>Name</strong>App类的构造函数被调用，但在此之前，它的父类CWinApp的构造函数先被执行。</li>
<li>C<strong>Name</strong>App类的InitInstance()进行对话框创建前的初始化工作，在其中会定义C<strong>Name</strong>Dlg对象来建立对话框。</li>
</ol>
<p>二、成员函数<br>1.CNameApp是CWinApp类的派生类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">InitInstance()    <span class="comment">//初始化程序，可以将某些初始化代码放在此处。</span></span><br></pre></td></tr></table></figure>
<p>2.CNameDlg是CDialog类的派生类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DoDataExchange(CDataExchange* pDX)<span class="comment">//控件与变量之间的数据交换。</span></span><br><span class="line">OnInitDialog()    <span class="comment">//初始化对话框。</span></span><br><span class="line">OnPaint()         <span class="comment">//重绘处理，响应WM_PAINT消息。</span></span><br><span class="line">OnSysCommand(UINT nID, LPARAM lParam)<span class="comment">//WM_SYSCOMMAND消息的响应。</span></span><br><span class="line">DECLARE_MESSAGE_MAP()    <span class="comment">//处理消息映射</span></span><br></pre></td></tr></table></figure>
<h4 id="顶端显示"><a href="#顶端显示" class="headerlink" title="顶端显示"></a>顶端显示</h4><p>在C<strong>Name</strong>Dlg类的OnInitDialog()中添加下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRect rect;</span><br><span class="line">GetClientRect(&amp;rect);</span><br><span class="line">::SetWindowPos(AfxGetMainWnd()-&gt;m_hWnd,HWND_TOPMOST,rect.left,rect.top,</span><br><span class="line">        rect.right,rect.bottom,SWP_NOMOVE);</span><br></pre></td></tr></table></figure>
<h4 id="仅运行一个实例"><a href="#仅运行一个实例" class="headerlink" title="仅运行一个实例"></a>仅运行一个实例</h4><p>在C<strong>Name</strong>App类的InitInstance()最开始处下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">::CreateMutex(<span class="literal">NULL</span>,TRUE,<span class="string">&quot;CHECK&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS)</span><br><span class="line">&#123;</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;本软件已经运行！&quot;</span>);<span class="comment">//弹出对话框确认不能运行第二个实例。</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="放置背景图片"><a href="#放置背景图片" class="headerlink" title="放置背景图片"></a>放置背景图片</h4><p>找一张bmp图片，然后在资源视图中右键导入。然后响应WM_CTLCOLOR消息，在处理函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Change any attributes of the DC here</span></span><br><span class="line"><span class="keyword">if</span> (nCtlColor==CTLCOLOR_STATIC)<span class="comment">//静态文本显示</span></span><br><span class="line">&#123;</span><br><span class="line">    pDC-&gt;SetBkColor(RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>));<span class="comment">//黄底</span></span><br><span class="line">    pDC-&gt;SetTextColor(RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>));<span class="comment">//粉字</span></span><br><span class="line">&#125;</span><br><span class="line">CBitmap m_groud;</span><br><span class="line">m_groud.LoadBitmap(IDB_BITMAP1);<span class="comment">//背景bmp的ID</span></span><br><span class="line"><span class="keyword">if</span> (nCtlColor==CTLCOLOR_DLG)	<span class="comment">//对话框背景</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">CBrush <span class="title">m_Brush</span><span class="params">(&amp;m_groud)</span></span>;</span><br><span class="line">    CRect rect;</span><br><span class="line">    GetClientRect(rect);</span><br><span class="line">    pDC-&gt;SelectObject(&amp;m_Brush);</span><br><span class="line">    pDC-&gt;FillRect(rect,&amp;m_Brush);</span><br><span class="line">    <span class="keyword">return</span> m_Brush;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Return a different brush if the default is not desired</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h4 id="屏蔽Esc、Enter退出"><a href="#屏蔽Esc、Enter退出" class="headerlink" title="屏蔽Esc、Enter退出"></a>屏蔽Esc、Enter退出</h4><p>在<strong>Name</strong>Dlg.h中重载如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">PreTranslateMessage</span><span class="params">(MSG* pMsg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<strong>Name</strong>Dlg.cpp中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CNameDlg::PreTranslateMessage</span><span class="params">(MSG* pMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    <span class="keyword">if</span>(pMsg-&gt;message==WM_KEYDOWN &amp;&amp; pMsg-&gt;wParam==VK_ESCAPE)</span><br><span class="line">    &#123;   <span class="comment">//屏蔽esc</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;    <span class="comment">//不作任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pMsg-&gt;message==WM_KEYDOWN &amp;&amp; pMsg-&gt;wParam==VK_RETURN)</span><br><span class="line">    &#123;   <span class="comment">//屏蔽enter</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;    <span class="comment">//不作任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CDialog::PreTranslateMessage(pMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="屏蔽Alt-F4"><a href="#屏蔽Alt-F4" class="headerlink" title="屏蔽Alt+F4"></a>屏蔽Alt+F4</h4><p>在C<strong>Name</strong>Dlg的OnSysCommand的else分支中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CNameDlg::OnSysCommand</span><span class="params">(UINT nID, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>( SC_CLOSE == nID || SC_MOVE == nID ) <span class="comment">//屏蔽系统菜单“关闭”和“移动” </span></span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        CDialog::OnSysCommand(nID, lParam); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动隐藏窗口"><a href="#启动隐藏窗口" class="headerlink" title="启动隐藏窗口"></a>启动隐藏窗口</h4><p>在C<strong>Name</strong>Dlg类的OnInitDialog()中添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SetTimer(<span class="number">1</span>,<span class="number">1</span>,<span class="literal">NULL</span>);  <span class="comment">//设置定时器</span></span><br></pre></td></tr></table></figure>
<p>响应WM_TIMER消息，在处理函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nIDEvent == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    KillTimer(<span class="number">1</span>);    <span class="comment">//关闭定时器</span></span><br><span class="line">    ShowWindow(SW_HIDE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ShowWindow的参数：</p>
<ul>
<li>SW_SHOWMAXIMIZED 激活并最大化</li>
<li>SW_SHOWMINIMIZED 激活并最小化</li>
<li>SW_RESTORE 激活并恢复原大小</li>
<li>SW_SHOW 显示窗口</li>
<li>SW_HIDE 隐藏窗口</li>
</ul>
<p>隐藏状态栏</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ModifyStyleEx(WS_EX_APPWINDOW, WS_EX_TOOLWINDOW);<span class="comment">//隐藏状态栏</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭对话框"><a href="#关闭对话框" class="headerlink" title="关闭对话框"></a>关闭对话框</h4><p>直接调用OnOK();或OnCancel();即可，但它们的返回值不同，分别返回IDOK和IDCANCEL。</p>
<h4 id="添加菜单"><a href="#添加菜单" class="headerlink" title="添加菜单"></a>添加菜单</h4><p>在资源视图下，右键资源顶层目录-&gt;添加资源-&gt;Menu，即可插入菜单资源。菜单项的属性项Popup，用来设置是否可以弹出菜单。将菜单加载到对话框框架有两种方法：</p>
<ol>
<li>修改对话框资源的Menu属性项，选择刚建立的菜单资源ID。</li>
<li>为对话框添加CMenu成员变量，然后在对话框初始化函数中输入如下代码：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_Menu = <span class="keyword">new</span> CMenu();</span><br><span class="line">m_Menu-&gt;LoadMenu(IDR_MENU1);</span><br><span class="line"><span class="keyword">this</span>-&gt;SetMenu(m_Menu);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在菜单资源中，可以直接写入文本插入菜单项，输入“-”可以显示横杠，输入“&amp;字母”可以显示快捷键。更多的设置通过代码完成，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;CheckMenuItem(<span class="number">0</span>,MF_BYPOSITION|MF_CHECKED);</span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">1</span>)-&gt;SetDefaultItem(<span class="number">0</span>,TRUE);  <span class="comment">//默认菜单项，0为项号。</span></span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">1</span>)-&gt;EnableMenuItem(ID_MENU_COLOR,MF_BYCOMMAND|MF_GRAYED);<span class="comment">//灰化菜单项</span></span><br></pre></td></tr></table></figure>
<p>每个顶层菜单项及其子菜单项称为一个菜单。例如通常所使用的程序，“文件”顶层菜单项及其下的“打开”、“保存”等菜单项构成一个菜单。“编辑”顶层菜单项及其子菜单项构成另一个菜单。</p>
<p>上面第一行代码，通过CWnd类成员GetMenu获得菜单资源指针。然后，调用CMenu类成员GetSubMenu获取每个菜单的指针，其参数为菜单编号，从0计数。最后，调用CMenu类成员CheckMenuItem，根据菜单内子项号（从0计数），对菜单项进行设置：</p>
<ul>
<li>MF_BYCOMMAND</li>
<li>MF_BYPOSITION</li>
<li>MF_CHECKED 添加选中标记</li>
<li>MF_UNCHECKED 去掉选中标记</li>
</ul>
<p>要让菜单有所动作，需要让菜单项响应COMMAND消息。在类向导中，选择对话框类，找到菜单项ID，添加COMMAND消息处理函数。菜单项ID在资源建立时默认是一窜数字，最好修改为有意义的字符。</p>
<h4 id="添加右键菜单"><a href="#添加右键菜单" class="headerlink" title="添加右键菜单"></a>添加右键菜单</h4><p>在资源视图下插入一个Menu资源，只需编辑首个菜单即可，顶层菜单项文字随意。打开类向导，选择对话框类，响应WM_RBUTTONDOWN消息。在响应函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMenu menu;</span><br><span class="line">menu.LoadMenu(IDR_MENU2);            <span class="comment">//加载新建的菜单</span></span><br><span class="line">CMenu* Popup = menu.GetSubMenu(<span class="number">0</span>);   <span class="comment">//右键菜单只有首个菜单</span></span><br><span class="line">ClientToScreen(&amp;point);              <span class="comment">//将客户区坐标转换为屏幕坐标</span></span><br><span class="line">Popup-&gt;TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON,point.x,point.y,<span class="keyword">this</span>);<span class="comment">//显示右键菜单</span></span><br></pre></td></tr></table></figure>
<h4 id="添加工具栏"><a href="#添加工具栏" class="headerlink" title="添加工具栏"></a>添加工具栏</h4><p>在对话框中添加工具栏有三种方法：</p>
<p>一、在资源视图下，插入ToolBar资源，其中的每个按钮需要自行绘画。如果要删除某个按钮，选中后拖出工具栏。每个按钮都有ID，可以将其设置为对应的菜单项ID，使得响应命令一致。</p>
<p>在对话框类头文件中添加CToolBar类型成员变量，然后在初始化函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_ToolBar.CreateEx(<span class="keyword">this</span>,TBSTYLE_FLAT,WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_GRIPPER|CBRS_TOOLTIPS|CBRS_SIZE_DYNAMIC|CBRS_BORDER_TOP);</span><br><span class="line">m_ToolBar.LoadToolBar(IDR_TOOLBAR1);</span><br><span class="line">m_ToolBar.GetToolBarCtrl().SetBitmapSize(CSize(<span class="number">16</span>,<span class="number">16</span>));</span><br><span class="line">m_ToolBar.GetToolBarCtrl().SetButtonSize(CSize(<span class="number">24</span>,<span class="number">24</span>));</span><br><span class="line">RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>其中，CreateEx最重要的是第一个参数，应该指定当前对话框类为父窗口，其他参数可以缺省。GetToolBarCtrl返回一个CToolBarCtrl类引用，然后通过它调用SetBitmapSize和SetButtonSize设置位图与按钮的尺寸。按钮尺寸必须大于位图尺寸。</p>
<p>二、在资源视图下，插入现成的bmp工具条。同样在对话框类头文件中添加CToolBar类型成员变量，然后在初始化函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UINT cell[<span class="number">11</span>];                  <span class="comment">//用于保存按钮ID</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1</span>; i++)             <span class="comment">//初始化ID</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>||i==<span class="number">7</span>||i==<span class="number">9</span>)        <span class="comment">//4，8，10为分割线</span></span><br><span class="line">        cell[i] = ID_SEPARATOR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cell[i] = i+<span class="number">1001</span>;       <span class="comment">//这个ID赋值可以参考菜单ID</span></span><br><span class="line">&#125;</span><br><span class="line">m_ToolBar.Create(<span class="keyword">this</span>);</span><br><span class="line">m_ToolBar.SetButtons(cell,<span class="number">11</span>);  <span class="comment">//设置工具栏按钮ID</span></span><br><span class="line">m_ToolBar.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">m_ToolBar.SetSizes(CSize(<span class="number">24</span>,<span class="number">24</span>),CSize(<span class="number">16</span>,<span class="number">16</span>));<span class="comment">//按钮尺寸、位图尺寸</span></span><br><span class="line">RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>三、在资源视图下，插入零散的ico图标。在对话框类头文件中添加CToolBar和CImageList成员变量，然后在初始化函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_ImageList.Create(<span class="number">32</span>,<span class="number">32</span>,ILC_COLOR24|ILC_MASK,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON1));<span class="comment">//向图像列表中添加图标</span></span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON2));</span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON3));</span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON4));</span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON5));</span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON6));</span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON7));</span><br><span class="line">m_ImageList.Add(AfxGetApp()-&gt;LoadIconW(IDI_ICON8));</span><br><span class="line">UINT cell[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">11</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>||i==<span class="number">7</span>||i==<span class="number">9</span>)</span><br><span class="line">        cell[i] = ID_SEPARATOR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cell[i] = i+<span class="number">1001</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_ToolBar.Create(<span class="keyword">this</span>);</span><br><span class="line">m_ToolBar.SetButtons(cell,<span class="number">11</span>);</span><br><span class="line">m_ToolBar.GetToolBarCtrl().SetImageList(&amp;m_ImageList);<span class="comment">//关联图像列表</span></span><br><span class="line">m_ToolBar.SetSizes(CSize(<span class="number">40</span>,<span class="number">40</span>),CSize(<span class="number">32</span>,<span class="number">32</span>));</span><br><span class="line">RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="添加状态栏"><a href="#添加状态栏" class="headerlink" title="添加状态栏"></a>添加状态栏</h4><p>在对话框类头文件中添加CStatusBar类型成员变量，并在初始化函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UINT col[<span class="number">5</span>];            <span class="comment">//状态栏被定义为4格</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    col[i] = <span class="number">1011</span> + i;  <span class="comment">//状态栏每一格的ID</span></span><br><span class="line">m_StatusBar.Create(<span class="keyword">this</span>);</span><br><span class="line">m_StatusBar.SetIndicators(col,<span class="keyword">sizeof</span>(col)/<span class="keyword">sizeof</span>(UINT));<span class="comment">//为状态栏每一格设置ID</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    m_StatusBar.SetPaneInfo(i,col[i],<span class="number">0</span>,<span class="number">100</span>);    <span class="comment">//设置每格尺寸</span></span><br><span class="line">CTime time = CTime::GetCurrentTime();           <span class="comment">//获得当前时间</span></span><br><span class="line">m_StatusBar.SetPaneText(<span class="number">0</span>,<span class="string">&quot;当前用户：&quot;</span>);         <span class="comment">//每部分的显示的内容</span></span><br><span class="line">m_StatusBar.SetPaneText(<span class="number">1</span>,<span class="string">&quot;TM&quot;</span>);</span><br><span class="line">m_StatusBar.SetPaneText(<span class="number">2</span>,<span class="string">&quot;当前日期：&quot;</span>);</span><br><span class="line">m_StatusBar.SetPaneText(<span class="number">3</span>,time.Format(<span class="string">&quot;%Y-%m-%d&quot;</span>));</span><br><span class="line">RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,<span class="number">0</span>);<span class="comment">//不能放末尾</span></span><br><span class="line">CRect rect;</span><br><span class="line">m_StatusBar.GetItemRect(<span class="number">4</span>,&amp;rect);    <span class="comment">//获取状态栏的某一块区域</span></span><br><span class="line">m_Progress.SetParent(&amp;m_StatusBar);  <span class="comment">//进度条的父窗口设置为状态栏</span></span><br><span class="line">m_Progress.MoveWindow(&amp;rect);        <span class="comment">//把进度条移动到状态栏</span></span><br><span class="line">m_Progress.ShowWindow(SW_SHOW);      <span class="comment">//显示进度条</span></span><br><span class="line">m_Progress.SetRange(<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">m_Progress.SetPos(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>状态栏最后一格内显示了一个进度条，这需要先在对话框资源上添加进度条，再关联CProgressCtrl类型变量。</p>
</blockquote>
]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 文件查找</title>
    <url>/2016/03/17/VC%E7%BC%96%E7%A8%8B%20%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>经过对文件操作（CFile）的系统学习后，觉得也应该再看看文件查找（CFindFile）的相关资料，现将学习过程记录如下。</p>
<a id="more"></a>

<h4 id="查找框架"><a href="#查找框架" class="headerlink" title="查找框架"></a>查找框架</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">FindFile</span><span class="params">(          <span class="comment">//查找成功，返回非0，否则0</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pstrName = <span class="literal">NULL</span>,    <span class="comment">//文件名，如果为NULL，以通配符*.*搜索</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwUnused = <span class="number">0</span>)</span></span>;        <span class="comment">//必须为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">FindNextFile</span><span class="params">()</span></span>;    <span class="comment">//在调用FindFile后，实际检索文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span>;                   <span class="comment">//结束搜索，释放CFindFile对象</span></span><br></pre></td></tr></table></figure>
<p>我们在查找文件或目录时，应先给出搜索路径，路径可以使用CString对象表示。在路径中可以使用通配符，比如.（检索目录内的所有文件）。</p>
<p>例：检索当前目录所有文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFileFind fi;</span><br><span class="line"><span class="keyword">bool</span> bWorking = fi.FindFile(<span class="string">&quot;*.*&quot;</span>);<span class="comment">//检索当前目录</span></span><br><span class="line"><span class="keyword">while</span> (bWorking)</span><br><span class="line">&#123;</span><br><span class="line">    bWorking = fi.FindNextFile();</span><br><span class="line">    AfxMessageBox(fi.GetFileName());</span><br><span class="line">&#125;</span><br><span class="line">fi.Close();</span><br></pre></td></tr></table></figure>
<p>上述程序会显示当前程序所在目录内的所有文件名，包括它自己的。程序调用FindFile开始查找，而FindNextFile真正去完成检索工作，所以在使用CFindFile对象调用Get和Is函数前必须先调用FindNextFile获取文件。</p>
<blockquote>
<p>每个目录中隐藏的 . 和 .. 目录也会被遍历到。</p>
</blockquote>
<h4 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">GetCreationTime</span><span class="params">(CTime&amp; refTime)</span> <span class="keyword">const</span></span>;  <span class="comment">//得到文件创建时间</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> CString <span class="title">GetFileName</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//得到文件名，包含扩展名。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> CString <span class="title">GetFilePath</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//得到发现文件的完整路径</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> CString <span class="title">GetFileTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">//得到文件名，不包括扩展名</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> CString <span class="title">GetFileURL</span><span class="params">()</span> <span class="keyword">const</span></span>;     <span class="comment">//结果类似于文件路径，在路径前加上了file://。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">GetLastAccessTime</span><span class="params">(CTime&amp; refTime)</span> <span class="keyword">const</span></span>;   <span class="comment">//得到文件最后访问时间</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">GetLastWriteTime</span><span class="params">(CTime&amp; refTime)</span> <span class="keyword">const</span></span>;    <span class="comment">//得到文件最后被改变的时间</span></span><br><span class="line"><span class="function">ULONGLONG <span class="title">GetLength</span><span class="params">()</span> <span class="keyword">const</span></span>;            <span class="comment">//得到文件字节长度</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> CString <span class="title">GetRoot</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">//得到发现文件的目录</span></span><br></pre></td></tr></table></figure>
<p>这些函数的使用都很简单，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bWorking = fi.FindFile(CurrentFile);</span><br><span class="line"><span class="keyword">if</span> (bWorking)</span><br><span class="line">&#123;</span><br><span class="line">    fi.FindNextFile();</span><br><span class="line">    CTime time;</span><br><span class="line">    CString str;</span><br><span class="line">    fi.GetCreationTime(time);</span><br><span class="line">    str.Format(<span class="string">&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">        time.GetYear(),time.GetMonth(),time.GetDay(),</span><br><span class="line">        time.GetHour(),time.GetMinute(),time.GetSecond());</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    str = fi.GetFileName();</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    str = fi.GetFilePath();</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    str = fi.GetFileTitle();</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    str = fi.GetFileURL();</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    str.Format(<span class="string">&quot;%d&quot;</span>,fi.GetLength());</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">    str = fi.GetRoot();</span><br><span class="line">    AfxMessageBox(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断文件属性"><a href="#判断文件属性" class="headerlink" title="判断文件属性"></a>判断文件属性</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsArchived</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//判断是否是文档</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsCompressed</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//判断是否被压缩</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsDirectory</span><span class="params">()</span> <span class="keyword">const</span></span>;     <span class="comment">//判断是否是目录</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">IsDots</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//判断是否是&quot;.&quot;或&quot;..&quot;</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsHidden</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">//判断是否隐藏</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsNormal</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">//判断是否是普通的（没有其他属性）</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsReadOnly</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//判断是否只读</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsSystem</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">//判断是否是系统文件</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsTemporary</span><span class="params">()</span> <span class="keyword">const</span></span>;     <span class="comment">//判断是否是临时文件</span></span><br></pre></td></tr></table></figure>
<p>例：深度遍历一个目录内的所有文档</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFindFileDlg:: TraDirAll(CString dir)</span><br><span class="line">&#123;</span><br><span class="line">    CFileFind fi;</span><br><span class="line">    dir += <span class="string">&quot;\\*.*&quot;</span>;</span><br><span class="line">    CString FileName,subDir;</span><br><span class="line">    <span class="keyword">bool</span> bWorking = fi.FindFile(dir);</span><br><span class="line">    <span class="keyword">while</span> (bWorking)</span><br><span class="line">    &#123;</span><br><span class="line">        bWorking = fi.FindNextFile();</span><br><span class="line">        <span class="keyword">if</span> (fi.IsDots())        <span class="comment">//划过.和..</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (fi.IsArchived())    <span class="comment">//文档则打印文件名</span></span><br><span class="line">        &#123;</span><br><span class="line">            FileName = fi.GetFileName();</span><br><span class="line">            AfxMessageBox(FileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fi.IsDirectory())   <span class="comment">//目录则递归</span></span><br><span class="line">        &#123;</span><br><span class="line">            subDir = fi.GetFilePath();</span><br><span class="line">            TraDirAll(subDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fi.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断文件属性（另一种形式）"><a href="#判断文件属性（另一种形式）" class="headerlink" title="判断文件属性（另一种形式）"></a>判断文件属性（另一种形式）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">MatchesMask</span><span class="params">(DWORD dwMask)</span> <span class="keyword">const</span></span>;	<span class="comment">//根据dwMask标识的属性判断文件</span></span><br></pre></td></tr></table></figure>
<p>参数dwMask用来标识属性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE_ATTRIBUTE_ARCHIVE        <span class="comment">//文档</span></span><br><span class="line">FILE_ATTRIBUTE_COMPRESSED     <span class="comment">//压缩</span></span><br><span class="line">FILE_ATTRIBUTE_DIRECTORY      <span class="comment">//目录</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL         <span class="comment">//普通，其他属性覆盖这个属性</span></span><br><span class="line">FILE_ATTRIBUTE_HIDDEN         <span class="comment">//隐藏</span></span><br><span class="line">FILE_ATTRIBUTE_READONLY       <span class="comment">//只读</span></span><br><span class="line">FILE_ATTRIBUTE_SYSTEM         <span class="comment">//系统</span></span><br><span class="line">FILE_ATTRIBUTE_TEMPORARY      <span class="comment">//临时</span></span><br></pre></td></tr></table></figure>
<p>这里面的属性与前面的判断函数是一一对应的，属性之间可以用位或 | 连接。</p>
<p>例：搜索C盘根目录下隐藏的系统文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFileFind fi;</span><br><span class="line">BOOL bWorking = fi.FindFile(<span class="string">&quot;C:\\*.*&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (bWorking)</span><br><span class="line">&#123;</span><br><span class="line">    bWorking = fi.FindNextFile();</span><br><span class="line">    <span class="keyword">if</span> (fi.MatchesMask(FILE_ATTRIBUTE_HIDDEN | </span><br><span class="line">        FILE_ATTRIBUTE_SYSTEM))</span><br><span class="line">        AfxMessageBox(fi.GetFileName());</span><br><span class="line">&#125;</span><br><span class="line">fi.Close();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 绘图</title>
    <url>/2015/08/19/VC%E7%BC%96%E7%A8%8B%20%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<p>设备上下文（Device Context）简称DC，是一种Windows数据结构，包括了各种绘制属性信息。DC类似于画板，编程绘制的图像都是绘制到DC。</p>
<p>绘图不仅需要画布，还需要画笔，一般会使用CPen、CBrush、CBitmap。编程绘制图像还需考虑重绘。重绘是VC编程层面上的概念，现实绘画没有这个。</p>
<a id="more"></a>

<h4 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h4><p>DC是windows上的一个概念，MFC对其进行了封装，如下所示：</p>
<ul>
<li>CDC 所有设备上下类的基类。</li>
<li>CClientDC 客户区图形绘制，需要直接在客户区绘图时使用，比如响应非窗口重绘消息（鼠标）绘图。调用GetDC获得DC，调用ReleaseDC释放DC。</li>
<li>CWindowDC 客户区和非客户区图形绘制。</li>
<li>CPaintDC 用于响应窗口重绘消息（WM_PAINT）时的绘图。调用BeginPaint获得DC，调用EndPaint释放DC，结束重绘。</li>
<li>CMetaFileDC 图元文件绘制。</li>
</ul>
<p>将图形绘制到DC的工具如下：</p>
<ul>
<li>CPen 绘制线条</li>
<li>CBrush 填充内部</li>
<li>CBitmap 操作位图</li>
<li>CFont 绘制文本</li>
</ul>
<p>绘图编程侧一般过程：</p>
<ol>
<li>创建合适的DC和绘图工具</li>
<li>使用SelectObject把工具选入DC（关联画布与画笔）</li>
<li>使用DC的图形函数绘制图像</li>
</ol>
<blockquote>
<p>编程绘图有个天然的难点，就是不能所见即所得，需要在头脑中勾勒出完整的图景，然后根据坐标将图画片段按序放到指定位置拼凑出最终画像。</p>
</blockquote>
<p>例：在对话框内绘制一个绿芯蓝边框圆形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在OnPaint函数的else分支，添加如下代码：</span></span><br><span class="line">    <span class="function">CClientDC <span class="title">cdc</span><span class="params">(<span class="keyword">this</span>)</span></span>;    <span class="comment">//当前窗口客户区dc</span></span><br><span class="line">    CPen newpen,*oldpen;    <span class="comment">//创建画笔</span></span><br><span class="line">    newpen.CreatePen(PS_SOLID, <span class="number">5</span>, RGB(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">    CRect rect;             <span class="comment">//绘画区域</span></span><br><span class="line">    rect.left = <span class="number">20</span>;</span><br><span class="line">    rect.top = <span class="number">20</span>;</span><br><span class="line">    rect.right = <span class="number">200</span>;</span><br><span class="line">    rect.bottom = <span class="number">200</span>;</span><br><span class="line">    oldpen = cdc.SelectObject(&amp;newpen);<span class="comment">//选择画笔</span></span><br><span class="line">    cdc.Ellipse(rect);           <span class="comment">//在区域内画圆</span></span><br><span class="line">    cdc.SelectObject(oldpen);    <span class="comment">//恢复画笔</span></span><br><span class="line"></span><br><span class="line">    CBrush newbrush,*oldbrush;</span><br><span class="line">    newbrush.CreateSolidBrush(RGB(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>));<span class="comment">//实心画刷</span></span><br><span class="line"><span class="comment">//  newbrush.CreateHatchBrush(HS_BDIAGONAL,RGB(0,255,0));//网格线画刷</span></span><br><span class="line"><span class="comment">//  CBitmap bmp;                 //位图画刷</span></span><br><span class="line"><span class="comment">//  bmp.LoadBitmap(IDB_BITMAP1);</span></span><br><span class="line"><span class="comment">//  newbrush.CreatePatternBrush(&amp;bmp);</span></span><br><span class="line">    oldbrush = cdc.SelectObject(&amp;newbrush);</span><br><span class="line">    cdc.Ellipse(rect);</span><br><span class="line">    cdc.SelectObject(oldbrush);</span><br></pre></td></tr></table></figure>
<p>值得一提就是rect四个坐标的赋值。这里是以对话框客户区左上角为源点，向右为x轴，向下为y轴。一个rect的left和right分别对应左边和右边到y轴的距离；rect的top和bottom分别对应上边和下边到x轴的距离。</p>
<h4 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h4><p>如果要将多个位图显示到对话框中，按照上面的方法需要一个一个的放到客户区，这会导致显示上的抖动。解决方法是将所有位图放到内存DC合适的位置，然后将整个内存DC显示到设备DC。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateCompatibleDC</span><span class="params">(CDC* pDC)</span></span>;    <span class="comment">//CDC：创建与pDC指定的设备DC兼容的内存DC</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CreateCompatibleBitmap</span><span class="params">(          <span class="comment">//CBitmap：初始化一个位图，兼容于pDC</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CDC* pDC,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nHeight)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">BitBlt</span><span class="params">(         <span class="comment">//CDC：从pSrcDC指向的DC复制bitmap到调用此函数的DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> x,           <span class="comment">//位图在目标DC中，左上角x坐标值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> y,           <span class="comment">//位图在目标DC中，左上角y坐标值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nWidth,      <span class="comment">//宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nHeight,     <span class="comment">//高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CDC* pSrcDC,     <span class="comment">//包含位图的DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> xSrc,        <span class="comment">//位图在源DC中，左上角x坐标值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> ySrc,        <span class="comment">//位图在源DC中，左上角y坐标值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwRop)</span></span>;    <span class="comment">//指定raster操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TransparentBlt</span><span class="params">(  <span class="comment">//CDC：将位图从pSrcDc传输到调用此函数的DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> xDest,        <span class="comment">//位图在目标DC中，左上角x坐标值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> yDest,        <span class="comment">//位图在目标DC中，左上角y坐标值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nDestWidth,   <span class="comment">//宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nDestHeight,  <span class="comment">//高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CDC* pSrcDC,      <span class="comment">//包含位图的DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> xSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> ySrc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nSrcWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nSrcHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT clrTransparent)</span></span>;<span class="comment">//RGB</span></span><br></pre></td></tr></table></figure>
<p>例：在程序客户区显示三幅图（含一个背景）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在初始化函数中添加</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>, y = <span class="number">20</span>;    <span class="comment">//初始x坐标，y坐标不变</span></span><br><span class="line"><span class="keyword">int</span> w = <span class="number">80</span>, h = <span class="number">60</span>;    <span class="comment">//宽度和高度</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++)    <span class="comment">//图1、图2的摆放位置</span></span><br><span class="line">&#123;</span><br><span class="line">    b[i].rect.left = x;</span><br><span class="line">    b[i].rect.top = y;</span><br><span class="line">    b[i].rect.right = b[i].rect.left + w;</span><br><span class="line">    b[i].rect.bottom = b[i].rect.top + h;</span><br><span class="line">    x = x + w + <span class="number">25</span>;    <span class="comment">//下一个图片位置</span></span><br><span class="line">&#125;</span><br><span class="line">b[<span class="number">0</span>].bmp.LoadBitmap(IDB_BITMAP3);<span class="comment">//背景</span></span><br><span class="line">b[<span class="number">1</span>].bmp.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">b[<span class="number">2</span>].bmp.LoadBitmap(IDB_BITMAP2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OnPaint的else分支</span></span><br><span class="line">CRect WndRect;</span><br><span class="line"><span class="keyword">this</span>-&gt;GetWindowRect(&amp;WndRect);</span><br><span class="line"><span class="keyword">this</span>-&gt;ScreenToClient(&amp;WndRect); <span class="comment">//获得客户区</span></span><br><span class="line"></span><br><span class="line"><span class="function">CClientDC <span class="title">cdc</span><span class="params">(<span class="keyword">this</span>)</span></span>;            <span class="comment">//客户区设备dc</span></span><br><span class="line">CDC mdc, tmpdc;                 <span class="comment">//内存dc和临时内存dc</span></span><br><span class="line">mdc.CreateCompatibleDC(&amp;cdc);   <span class="comment">//创建客户区dc的兼容内存dc</span></span><br><span class="line">CBitmap ClientBmp;              <span class="comment">//创建兼容客户区dc的位图</span></span><br><span class="line">ClientBmp.CreateCompatibleBitmap(&amp;cdc,WndRect.right,WndRect.bottom);</span><br><span class="line">mdc.SelectObject(&amp;ClientBmp);   <span class="comment">//将这个兼容位图选入内存dc，作为总位图</span></span><br><span class="line"></span><br><span class="line">tmpdc.CreateCompatibleDC(&amp;cdc); <span class="comment">//内存dc</span></span><br><span class="line">BITMAP bmpInfo;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) <span class="comment">//三个图片</span></span><br><span class="line">&#123;</span><br><span class="line">    tmpdc.SelectObject(&amp;b[i].bmp);  <span class="comment">//将每个图片选入tmpdc</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)     <span class="comment">//放入背景</span></span><br><span class="line">        mdc.BitBlt(<span class="number">0</span>,<span class="number">0</span>,WndRect.Width(),WndRect.Height(),&amp;tmpdc,<span class="number">0</span>,<span class="number">0</span>,SRCCOPY);</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">//放入两个图片</span></span><br><span class="line">    &#123;</span><br><span class="line">        b[i].bmp.GetBitmap(&amp;bmpInfo);</span><br><span class="line">        mdc.TransparentBlt(b[i].rect.left, b[i].rect.top, bmpInfo.bmWidth,</span><br><span class="line">            bmpInfo.bmHeight, &amp;tmpdc, <span class="number">0</span>, <span class="number">0</span>, bmpInfo.bmWidth, bmpInfo.bmHeight,</span><br><span class="line">            RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cdc.BitBlt(<span class="number">0</span>,<span class="number">0</span>,WndRect.right,WndRect.bottom,&amp;mdc,<span class="number">0</span>,<span class="number">0</span>,SRCCOPY);<span class="comment">//将mdc中总位图放到客户区dc</span></span><br><span class="line"></span><br><span class="line">ClientBmp.DeleteObject();</span><br><span class="line">mdc.DeleteDC();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要在资源中插入三个位图</p>
</blockquote>
]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 综述</title>
    <url>/2015/07/24/VC%E7%BC%96%E7%A8%8B%20%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<p>记录在这里的是VC2010下的MFC编程，其它版本的使用与此类似。控制台和win32结构清晰，但一般只在学习中使用，所以不在此赘述。</p>
<p>MFC近十余年来在各个版本的Visual Studio中没有什么本质变化。像VC、VB这种PC端可执行程序开发工具在当前中国呈明显衰落趋势，更可悲的是它们在中国软件行业从来也没有像web开发那样强势的发展过。这与国情有一定关系，软件厂商要想靠市场活下去，就不能广泛存在盗版，而天然具备反盗版特性的软件行业当前只有两个：</p>
<a id="more"></a>

<ol>
<li>主要程序在服务端的web开发行业，面向的用户都是企业，而且开发后的程序经常需要更新，随着当前电商的极大发展，web行业吸纳了大量程序员。</li>
<li>依赖硬件的嵌入式开发行业。这个行业通常都是电子厂，以机械、电子专业人员居多。当然，这里没包括那些在移动智能设备上开发应用的企业，因为它们跟在PC端开发程序的企业面临的问题一样。</li>
</ol>
<p>像使用MFC这类工具，开发端可执行程序的企业要想在市场中活下去，一般要具备如下两种特性之一：</p>
<ol>
<li>拥有强大的专业实力，比如Microsoft、Adobe。当前基本都是欧美企业。</li>
<li>软件给用户免费用，靠服务挣钱，比如各种网游。</li>
</ol>
<p>总的来说在当前中国，学习MFC开发的职业前景较窄，但没人否认，MFC仍旧是windows下可执行程序开发的主要选择。作为个人，学习一些这方面的技能可提高工作效率。</p>
<p>学习MFC编程，最重要的资料就是MSDN，可通过登录<a href="https://docs.microsoft.com/zh-cn/?view=vs-2019">https://docs.microsoft.com/zh-cn/?view=vs-2019</a>查询各种API函数和Class的信息。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一、跟随Visual Studio向导一步一步安装即可，中间可选择不安装VB、C#等工具。</p>
<blockquote>
<p>与VS2010配套的数据库是SQL server 2008 R2。如果想要安装数据库，最好在安装VS2010之前先安装它。</p>
</blockquote>
<p>二、安装配套的MSDN<br>VS2010不再有单独的MSDN Library安装选项，在其安装光盘中包含MSDN Library，安装方法为，打开VS2010，选择帮助菜单，点击“管理帮助设置”进入向导：</p>
<ul>
<li>第一次打开时会让你选择一个路径，用来保存MSDN Library的内容。</li>
<li>点击“选择联机帮助或本地帮助”，然后选择“我要使用本地帮助”</li>
<li>点击“从磁盘安装内容”，然后添加VS2010安装光盘下的ProductDocumentation\HelpContentSetup.msha。挑选想要安装的MSDN内容，确定后开始安装。</li>
<li>通过“联机检查更新”可以在线更新本地MSDN Library文档。</li>
<li>在VS2010里按F1，即可打开安装的文档。第一次打开时会额外运行一个Help Library Agent进程，它会调用默认浏览器显示Help Library。</li>
</ul>
<blockquote>
<p>这样安装的MSDN，内容可能不是很全。</p>
</blockquote>
<p>三、安装Visual Assist辅助软件<br>按照向导安装即可。初始会开启拼写检查，关闭方法：去掉勾选Underlines中的“Underline spelling errors in comments and strings”。</p>
<h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><p>一、error LNK1123: failure during conversion to COFF: file invalid or corrupt<br>原因是当前系统存在两个版本不同的cvtres.exe。解决方法：重命名或删除（VS2010安装的位置）Microsoft Visual Studio 10.0\VC\bin\cvtres.exe。这样C:\Windows\Microsoft.NET\Framework\v4.0.30319 (.NET 4.5)中的cvtres.exe就可以被VS2010使用了。</p>
<p>二、VSTS for Database Professionals Sql Server Data-tier Application’包”<br>方法1：C:\Users\lenovo\AppData\Roaming\Microsoft下的visualstdio文件删掉。<br>方法2：开始 -&gt; 所有程序 -&gt; Microsoft visual studio 2010 -&gt; visual studio tools -&gt; visual studio 2010命令提示，输入devenv /resetskippkgs回车即可。</p>
<p>三、资源在另一个编辑器中打开<br>点击菜单“窗口” -&gt; “关闭所有文档”即可。</p>
<h4 id="开发环境设置"><a href="#开发环境设置" class="headerlink" title="开发环境设置"></a>开发环境设置</h4><p>一、暗色主题<br>在微软官网下载名为ThemeManagerPackage.vsix的插件。安装后，便可在菜单栏看到Theme。</p>
<p>选择Theme -&gt; Customize Colors -&gt; New Theme，弹出新建主题对话框：Name可以随便取，Based On选择“Default”，点击”Create”便建立了一个新的主题。</p>
<p>选中刚才建立的主题的Name，然后”Ctrl+A”全选右侧颜色列表，点击对话框上面的“Modify Huse/Saturation/Lightness”按钮，把“S”条拖到最小“-100”，“Apply”确认。</p>
<p>网站Studio Styles上有很多别人做好的样式，下载Son of Obsidian。工具 -&gt; 导入和导出设置 -&gt; 导入选定的环境设置 -&gt; 否,仅导入新设置… -&gt; 浏览，选中刚才下载的son-of-obsidian样式文件，确认即可。</p>
<p>VAssistX -&gt; Visual Assist X Options… -&gt; Advanced-&gt;Fonts and Colors -&gt; Enabled Enhanced Syntax Coloring，点击“Use Defaults”按钮，这时左边的颜色框会变成样式相应的颜色，“Apply Coloring to”复选框中只勾选“Text Editors”，不然会导致其它地方颜色太浅。“Advanced-&gt;Display”，把第一个颜色项设置为天蓝色。</p>
<p>在VS的“工具 -&gt; 选项 -&gt; 环境 -&gt; 字体和颜色”中，把“选中的文本”的项背景色设成“紫色”；“指示器边距”的项背景色设为“银色”；“VA X Find Reference”和“VA X Find Reference(Modified)”的项前景色设为“蓝色”，项背景色设为“默认值”。另外还有“XML属性引号”，这个“项前景色”要调成“银色”，以在XML文件中清楚地显示引号。</p>
<p>二、设置字体<br>点击VS菜单，工具 -&gt; 选项 -&gt; 环境 -&gt; 字体和颜色，在“字体”下拉框中选择字体。</p>
<p>三、显示行号<br>工具 -&gt; 选项，文本编辑器 -&gt; C/C++ -&gt; 常规，勾选行号即可。设置制表符也在这里，在C/C++下选择“制表符”，可设置其大小。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>一、转换文件编码<br>中文VC2010默认保存文本文件的编码是GBK。这种编码可能在某些情况下会出现乱码，所以最好转换为UTF8编码。方法为：“文件”菜单 -&gt; 高级保存选项，在编码下拉列表中选择“Unicode(UTF-8带签名）-代码页65001”，点击确定。然后，照常保存文件即可。</p>
<p>二、快捷注释<br>选中一块代码按/，即可批量注释；相反，选中后再按/就取消了注释。</p>
<p>三、设置程序以管理员身份运行<br>右键“当前项目名称” -&gt; 属性 -&gt; 链接器 -&gt; 清单文件 -&gt; UAC执行级别，选择requireAdministrator，确定后重新编译即可。</p>
<p>四、调整代码格式<br>选中凌乱的代码，按下Alt+F8，即可整理代码格式。</p>
<p>五、调整控件的Tab序和显示层次<br>在资源视图，按CTRL+D会显示Tab序，用鼠标点击可调整Tab序。Tab号越小越底层。</p>
<p>六、让VC2010编译出64位程序<br>在工具栏中“解决方案平台”下拉列表中选择“配置管理器”。在弹出的对话框右上角“活动解决方案平台”下拉列表中选择“新建”。在“键入或选择新平台”下拉列表中选择x64即可。当这个由新建选项编译出的程序运行时，在任务管理器中会看到没有*32。</p>
<p>七、改变程序的图标<br>在网上找一个256*256的ico图标，使用ArtIcon软件打开，然后选择“新建图像格式”，分别建立48*48、32*32、24*24、16*16，均选择256色，256*256可以选择真彩色。</p>
<p>在VC2010中插入新建的图标，删除原图标IDR_MAINFRAME，再把刚插入的图标ID改成这个ID即可。</p>
<blockquote>
<p>还有一种更简单的方法就是把原*.ico文件替换成想要的图标即可。</p>
</blockquote>
<h4 id="MFC基本框架"><a href="#MFC基本框架" class="headerlink" title="MFC基本框架"></a>MFC基本框架</h4><p>MFC程序有三个框架：多文档、单文档、对话框。作为个人开发者，最常用的就是对话框。</p>
]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 消息响应</title>
    <url>/2015/08/17/VC%E7%BC%96%E7%A8%8B%20%E6%B6%88%E6%81%AF%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<p>消息传递、处理机制是图形化程序的基础。图形化程序为用户提供了便利，但也使得程序的实际运行变得非线性。所有的消息都是由用户触发的，我们只能根据系统提供的消息类型，选择需要处理的消息编写处理代码。</p>
<p>Windows消息分为三类：标准消息、命令消息和通告消息。像工具栏、菜单项发出的消息属于命令消息；按钮、列表框控件发出的消息属于通告消息。</p>
<a id="more"></a>

<h4 id="消息处理机制"><a href="#消息处理机制" class="headerlink" title="消息处理机制"></a>消息处理机制</h4><p>我们可以让某个类或某个控件ID响应消息。在类向导中，选择想要响应消息的类和控件ID，再在“消息”标签下选择所要响应的消息。确认后MFC会自动添加三块代码：</p>
<p>一、类头文件中的消息响应函数声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnMenuPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnRButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span>;</span><br></pre></td></tr></table></figure>
<p>二、类函数定义文件中的消息映射</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BEGIN_MESSAGE_MAP(CGeraDlgDlg, CDialogEx)</span><br><span class="line">    ON_WM_SYSCOMMAND()           <span class="comment">//框架自带</span></span><br><span class="line">    ON_WM_PAINT()                <span class="comment">//框架自带</span></span><br><span class="line">    ON_WM_QUERYDRAGICON()        <span class="comment">//框架自带</span></span><br><span class="line">    ON_COMMAND(ID_MENU_PRINT, &amp;CGeraDlgDlg::OnMenuPrint)  <span class="comment">//点击菜单</span></span><br><span class="line">    ON_WM_RBUTTONDOWN()          <span class="comment">//右键菜单</span></span><br><span class="line">END_MESSAGE_MAP()</span><br></pre></td></tr></table></figure>
<p>三、类函数定义文件中的消息响应函数定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CGeraDlgDlg::OnMenuPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CGeraDlgDlg::OnRButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    CDialogEx::OnRButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h4><ol>
<li>在类向导中，选择待响应消息的类，在消息属性页下方点击“添加自定义消息”按钮，在弹出的对话框中输入消息名和响应函数名。</li>
<li>在类函数定义文件中，添加#define WM_MYMESSAGE WM_USER+1。</li>
<li>在响应函数中写入代码。</li>
</ol>
<p>例：系统托盘菜单<br>一、添加NOTIFYICONDATA类型成员变量nid，在初始化函数中设置NOTIFYICONDATA结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nid.cbSize = (DWORD)<span class="keyword">sizeof</span>(NOTIFYICONDATA); </span><br><span class="line">nid.hWnd = <span class="keyword">this</span>-&gt;m_hWnd; </span><br><span class="line">nid.uID = IDR_MAINFRAME; </span><br><span class="line">nid.uFlags = NIF_ICON|NIF_MESSAGE|NIF_TIP; </span><br><span class="line">nid.uCallbackMessage = WM_SYSTRAY;  <span class="comment">//自定义的消息名称 </span></span><br><span class="line">nid.hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME)); </span><br><span class="line"><span class="built_in">strcpy</span>(nid.szTip,<span class="string">&quot;管理&quot;</span>);           <span class="comment">//信息提示内容 </span></span><br><span class="line"></span><br><span class="line">Shell_NotifyIcon(NIM_ADD,&amp;nid);     <span class="comment">//在托盘区添加图标，NIM_DELETE为删托盘。</span></span><br></pre></td></tr></table></figure>
<p>二、在类向导中，添加自定义消息相关信息，并在响应函数文件内添加#define WM_MYMESSAGE WM_USER+1。然后，在响应函数中键入如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">afx_msg LRESULT <span class="title">CNameDlg::OnSystray</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wParam != IDR_MAINFRAME) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(lParam)</span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">case</span> WM_RBUTTONUP:    <span class="comment">//右键起来时弹出快捷菜单 </span></span><br><span class="line">        &#123;</span><br><span class="line">            LPPOINT lpoint = <span class="keyword">new</span> tagPOINT; </span><br><span class="line">            ::GetCursorPos(lpoint);<span class="comment">//得到鼠标位置</span></span><br><span class="line">            CMenu menu; </span><br><span class="line">            menu.CreatePopupMenu();<span class="comment">//声明一个弹出式菜单</span></span><br><span class="line">            menu.AppendMenu(MF_STRING,ID_OFFLINE,<span class="string">&quot;下线&quot;</span>);<span class="comment">//添加自定义菜单项</span></span><br><span class="line">            menu.AppendMenu(MF_STRING,ID_ABOUT,<span class="string">&quot;关于&quot;</span>);</span><br><span class="line">            menu.TrackPopupMenu(TPM_LEFTALIGN,lpoint-&gt;x,lpoint-&gt;y,<span class="keyword">this</span>);<span class="comment">//确定弹出式菜单的位置 </span></span><br><span class="line">            HMENU hmenu = menu.Detach();<span class="comment">//资源回收 </span></span><br><span class="line">            menu.DestroyMenu(); </span><br><span class="line">            <span class="keyword">delete</span> lpoint;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、为添加的菜单项添加响应函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Resource.h中添加：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_CLOSE    32001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_OPEN     32002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_ABOUT    32003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在主对话框类头文件中添加响应函数声明：</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnOpen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnAbout</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在消息映射中添加：</span></span><br><span class="line">BEGIN_MESSAGE_MAP(CWebEnterDlg, CDialogEx)</span><br><span class="line">    ON_COMMAND(ID_OPEN, &amp;CUsbcheckDlg::OnUSBSerial)</span><br><span class="line">    ON_COMMAND(ID_ABOUT, &amp;CUsbcheckDlg::OnAbout)</span><br><span class="line">    ON_COMMAND(ID_CLOSE, &amp;CUsbcheckDlg::OnClose)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在主对话框类函数定义文件中添加响应函数定义：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CNameDlg::OnOpen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CNameDlg::OnAbout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CNameDlg::OnClose</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h4 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h4><p>键盘上的每一个键都对应一个唯一扫描码，并在按下和释放时产生通知。有4种基本键盘消息：</p>
<ul>
<li>WM_KEYDOWN 按下非系统键产生的消息</li>
<li>WM_KEYUP 释放非系统键产生的消息</li>
<li>WM_SYSKEYDOWN 按下系统键产生的消息</li>
<li>WM_SYSKEYUP 释放系统键产生的消息</li>
</ul>
<p>让基于对话框框架的程序响应按键消息，直接让主对话框类响应上述消息是无效的，可以采用重载虚函数PreTranslateMessage的方法。打开类向导，选择主对话框类，在虚函数页内找到PreTranslateMessage，添加函数。然后，在这个函数定义中键入如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (pMsg-&gt;message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:             <span class="comment">//响应进程内按键消息</span></span><br><span class="line">    <span class="keyword">switch</span> (pMsg-&gt;wParam)    <span class="comment">//获得按键</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:                <span class="comment">//小写字符a无法接收到</span></span><br><span class="line">        m_Radio1.SetCheck(BST_CHECKED);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        m_Radio2.SetCheck(BST_CHECKED);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_HOTKEY:              <span class="comment">//响应全局按键消息</span></span><br><span class="line">    <span class="keyword">switch</span> (pMsg-&gt;wParam)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> HOTKEY_UP:</span><br><span class="line">        m_Radio1.SetCheck(BST_UNCHECKED);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HOTKEY_DOWN:</span><br><span class="line">        m_Radio2.SetCheck(BST_UNCHECKED);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应进程内按键，只需要上述代码即可，如果要响应全局按键，需要定义并注册热键：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主对话框cpp文件开头</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOTKEY_UP       1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOTKEY_DOWN     1002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line">RegisterHotKey(m_hWnd,HOTKEY_UP,<span class="number">0</span>,VK_UP);</span><br><span class="line">RegisterHotKey(m_hWnd,HOTKEY_DOWN,<span class="number">0</span>,VK_DOWN);</span><br></pre></td></tr></table></figure>
<p>RegisterHotKey函数的说明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RegisterHotKey</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd,           <span class="comment">//接收WM_HOTKEY消息的窗体句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> id,              <span class="comment">//快捷键ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT fsModifiers,    <span class="comment">//组合键</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT vk              <span class="comment">//虚拟键</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p>fsModifiers：MOD_ALT、MOD_CONTROL、MOD_SHIFT、MOD_WIN，设置了哪个组合键，将来使用快捷键时必须同时按下那个组合键。虚拟键值表如下：</p>
<table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">虚拟键</th>
<th align="center">按键</th>
<th align="center">虚拟键</th>
</tr>
</thead>
<tbody><tr>
<td align="center">←</td>
<td align="center">VK_LEFT</td>
<td align="center">退格</td>
<td align="center">VK_BACK</td>
</tr>
<tr>
<td align="center">→</td>
<td align="center">VK_RIGHT</td>
<td align="center">制表符</td>
<td align="center">VK_TAB</td>
</tr>
<tr>
<td align="center">↑</td>
<td align="center">VK_UP</td>
<td align="center">回车</td>
<td align="center">VK_RETURN</td>
</tr>
<tr>
<td align="center">↓</td>
<td align="center">VK_DOWN</td>
<td align="center">Ctrl</td>
<td align="center">VK_CONTORL</td>
</tr>
<tr>
<td align="center">Shift</td>
<td align="center">VK_SHIFT</td>
<td align="center">Pause</td>
<td align="center">VK_PAUSE</td>
</tr>
<tr>
<td align="center">Alt</td>
<td align="center">VK_MENU</td>
<td align="center">Esc</td>
<td align="center">VK_ESCAPE</td>
</tr>
<tr>
<td align="center">Caps Lock</td>
<td align="center">VK_CAPITAL</td>
<td align="center">Home</td>
<td align="center">VK_HOME</td>
</tr>
<tr>
<td align="center">左系统键</td>
<td align="center">VK_LWIN</td>
<td align="center">右系统键</td>
<td align="center">VK_RWIN</td>
</tr>
<tr>
<td align="center">数字0~9</td>
<td align="center">VK_0~VK_9</td>
<td align="center">字母A~Z</td>
<td align="center">VK_A~VK_Z</td>
</tr>
</tbody></table>
<blockquote>
<p>数字和字母的虚拟键好像未定义</p>
</blockquote>
<p><strong>模拟按键</strong><br>一、使用keybd_event模拟按键</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keybd_event</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BYTE bVk,         <span class="comment">//虚拟键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BYTE bScan,       <span class="comment">//未使用</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwFlags,    <span class="comment">//功能选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">    PTR dwExtraInfo   <span class="comment">//附加信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p>在对话框资源上添加两个按钮，并添加响应函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CkeyboardDlg::OnBnClickedButton1</span><span class="params">()</span> <span class="comment">//Win+R</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    keybd_event(VK_LWIN,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);         <span class="comment">//按压win</span></span><br><span class="line">    keybd_event(<span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);             <span class="comment">//按压R</span></span><br><span class="line">    keybd_event(<span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);        <span class="comment">//释放R</span></span><br><span class="line">    keybd_event(VK_LWIN,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);    <span class="comment">//释放win</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CkeyboardDlg::OnBnClickedButton2</span><span class="params">()</span> <span class="comment">//Ctrl+Shift</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    keybd_event(VK_CONTROL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    keybd_event(VK_SHIFT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    keybd_event(VK_SHIFT, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);</span><br><span class="line">    keybd_event(VK_CONTROL, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用keybd_event模拟键盘消息，每个按键必须成对使用。keybd_event只是用于产生键盘事件，并不关心由谁处理。系统捕捉到键盘事件后，会转化为键盘消息并派发给当前系统中拥有键盘输入焦点的应用程序。</p>
<p>二、使用PostMessage发送按键消息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd,        <span class="comment">//目标窗体或控件</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UINT Msg,         <span class="comment">//消息标识</span></span></span></span><br><span class="line"><span class="function"><span class="params">    WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p>在对话框上添加一个按钮，并添加响应函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CkeyboardDlg::OnBnClickedButton3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    PostMessage(WM_KEYDOWN,VK_RIGHT,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在PreTranslateMessage中，添加响应VK_RIGHT的分支：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (pMsg-&gt;message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:            <span class="comment">//响应进程内按键消息</span></span><br><span class="line">    <span class="keyword">switch</span> (pMsg-&gt;wParam)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//其他按键响应</span></span><br><span class="line">    <span class="keyword">case</span> VK_RIGHT:          <span class="comment">//响应右箭头</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;按压了右键头&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>PostMessage把消息发送到指定句柄所在线程的消息队列，再由线程派发；SendMessage直接把消息发送到指定句柄的窗体或控件。</p>
<h4 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h4><p>鼠标动作无非就是点击、释放、移动、拖拽，这些都是如下消息组合实现的。</p>
<table>
<thead>
<tr>
<th align="left">鼠标消息</th>
<th align="center">意义</th>
<th align="left">鼠标消息</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WM_LBUTTONDOWN</td>
<td align="center">单击左键</td>
<td align="left">WM_RBUTTONDOWN</td>
<td align="center">单击右键</td>
</tr>
<tr>
<td align="left">WM_LBUTTONUP</td>
<td align="center">释放左键</td>
<td align="left">WM_RBUTTONUP</td>
<td align="center">释放右键</td>
</tr>
<tr>
<td align="left">WM_LBUTTONDBLCLK</td>
<td align="center">左键双击</td>
<td align="left">WM_RBUTTONDBLCLK</td>
<td align="center">双击右键</td>
</tr>
<tr>
<td align="left">WM_MBUTTONDOWN</td>
<td align="center">单击中键</td>
<td align="left">WM_MBUTTONUP</td>
<td align="center">释放中键</td>
</tr>
<tr>
<td align="left">WM_MBUTTONDBLCLK</td>
<td align="center">双击中键</td>
<td align="left">WM_MOUSEMOVE</td>
<td align="center">移动鼠标</td>
</tr>
</tbody></table>
<p>让基于对话框框架的程序响应鼠标消息，直接让主对话框类响应上述消息即可。模拟鼠标消息的方法与模拟键盘类似，也有两种方法：</p>
<p>一、使用mouse_event模拟鼠标动作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_event</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwFlags,           <span class="comment">//鼠标动作</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dx,                <span class="comment">//鼠标的X位置</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dy,                <span class="comment">//鼠标的Y位置</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwData,            <span class="comment">//一般为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG_PTR dwExtraInfo    <span class="comment">//一般为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p>添加按钮并关联响应函数，然后添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CPoint <span class="title">p</span><span class="params">(<span class="number">50</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">ClientToScreen(&amp;p);		</span><br><span class="line">SetCursorPos(p.x,p.y);  <span class="comment">//移动鼠标的位置到对话框区域（离开按钮）</span></span><br><span class="line">mouse_event(MOUSEEVENTF_MIDDLEDOWN,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);    <span class="comment">//按压中键</span></span><br><span class="line">mouse_event(MOUSEEVENTF_MIDDLEUP,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>打开类向导，让主对话框响应中键单击消息，并添加响应代码。mouse_event与keybd_event一样，只是触发鼠标事件，不管谁来响应。如果不将鼠标设置到对话框区域，就无法看到中键单击的效果。</p>
<p>二、使用PostMessage发送鼠标消息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按钮响应函数中添加</span></span><br><span class="line">PostMessage(WM_RBUTTONDOWN,<span class="number">0</span>,<span class="number">0</span>);    <span class="comment">//右键消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在类向导中对主对话框添加右键响应消息</span></span><br></pre></td></tr></table></figure>
<h4 id="WM-DEVICECHANGE"><a href="#WM-DEVICECHANGE" class="headerlink" title="WM_DEVICECHANGE"></a>WM_DEVICECHANGE</h4><p>这个消息可用于检测USB移动存储设备的插拔，当用户接插USB设备到计算机时，系统会触发这个消息，并将其发送给所有程序，失去焦点的窗口依然可以处理该消息。</p>
<p>这个消息只能手动添加响应函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对话框类头文件中</span></span><br><span class="line"><span class="function">afx_msg BOOL <span class="title">OnDeviceChange</span><span class="params">(UINT nEventType,DWORD dwData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对话框类函数定义文件中</span></span><br><span class="line">BEGIN_MESSAGE_MAP(CFileCopyDlg, CDialog)</span><br><span class="line">    ON_WM_DEVICECHANGE()</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应函数定义</span></span><br><span class="line"><span class="function">BOOL <span class="title">CUsbcheckDlg::OnDeviceChange</span><span class="params">(UINT nEventType,DWORD dwData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(nEventType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DBT_DEVICEARRIVAL:        <span class="comment">//有设备插入且可用</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;USB插入&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DBT_DEVICEREMOVECOMPLETE: <span class="comment">//移除某一设备</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;USB拔出&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中nEventType就是WM_DEVICECHANGE消息的wParam参数。必须在文件开头引入#include “Dbt.h”，否则无法识别DBT系列值。</p>
</blockquote>
]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware的基本使用</title>
    <url>/2007/11/18/VMware%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>先关闭虚拟机，在窗口左侧右键选择虚拟机，快照-&gt;快照管理器。在弹出的窗口上部箭头图中选择某个点，按压“拍摄快照”按钮即可。可以建立多个快照。</p>
<p>如果要回到某个快照点，选择箭头图中的快照点，点击“转到”按钮即可（当前虚拟机状态会丢失）。此时的“当前位置”会另起一个分支。</p>
<a id="more"></a>

<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>所有的快照都处于一个虚拟机中，有时需要多台虚拟机，这时就要使用克隆功能。进入快照管理器，在上面箭头图中选择快照点，点击“克隆”按钮，弹出克隆向导对话框，按照如下步骤建立克隆：</p>
<ol>
<li>选择克隆点；</li>
<li>选择创建克隆链接，还是完整克隆；</li>
<li>选择克隆机名字和保存位置，点击“完成”按钮。</li>
</ol>
<p>回到快照管理器会发现快照点多了锁型标志。返回VMware主界面，在左侧选择新创建的克隆机，打开电源即可使用。</p>
<h4 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h4><p>VMware默认会创建两块虚拟网卡，分别为VMnet0 ~ VMnet8。在“虚拟网络编辑器”中可添加更多的网卡。每块网卡有三种选择：桥接网络、仅主机网络、NAT网络。</p>
<p>如果想让各个虚拟机之间能互相通信，需要把它们都连接到同一个虚拟交换机下。具体方法：</p>
<ol>
<li>在“虚拟网络编辑器”中设置某个VMnet，特别要注意填写子网IP和子网掩码，这是虚拟交换机的地址。</li>
<li>在主界面左侧选中虚拟机，在右侧点击“网络适配器”，会弹出虚拟机设置对话框，在右侧“网络连接”中设置为那个VMnet。所有想要联网的虚拟机都要统一设置为那个VMnet。</li>
<li>打开每个想要通信的虚拟机，设置它们的IP地址为这个虚拟子网的合法地址，即可通信。</li>
</ol>
]]></content>
      <categories>
        <category>PC</category>
      </categories>
      <tags>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title>什么样的人容易成功？</title>
    <url>/2018/11/18/%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E8%83%BD%E6%88%90%E5%8A%9F%EF%BC%9F/</url>
    <content><![CDATA[<p>傍晚下班回家，看到一只黑白花色的小狗溜进楼门。我随后进入，等待电梯，发现它坐在电梯门前真诚的看着我。电梯到达一楼，它先跑进去，蹲在角落里；到达我家那一层，它提前走到电梯门前。电梯门开，它直接跑到楼层门前，等着我开门，然后又先跑进去，堵在我家门前。全程就像我养了它多年一样。</p>
<p>我跺脚吓它离开，它不为所动；我用手拽它，它四条腿使劲向后把住地面。没办法，我只能将其抱起放到了楼层门外。回到家中，我心里竟然觉的有点对不起它，过了一小会儿，忍不住出去看看，发现它已经不在了。</p>
<a id="more"></a>

<p>随后，我将上述故事讲述给父母。据我父亲回忆，这只小狗前几天就围着他转，想趁机溜进家中。我这才明白，狗狗是如何知道我住在哪里的。</p>
<p>过了几天，再发现它时——仰着尾巴，吐着舌头，痴痴地跟在一位大妈身后。大妈还时不时的招手，怕它跟不上跑丢了。此情此景，让人感慨万千，我真的理解了<strong>什么是舔狗</strong>。</p>
<p>舔狗做事不看事看人，不以逻辑规律和自身能力办事，而是顺着人际关系行事。</p>
<ol>
<li>与人打交道前，做好调查工作；</li>
<li>与人打交道时，态度真诚且坦然居下；</li>
<li>与人打交道失败后，快速抛弃心理包袱，积极地迎接下一次人际交往；</li>
<li>如果无法渗透目标人物，转换目标为他的家人。</li>
</ol>
<p>现在想想，我们身边的动物中，活得最好的可能就是狗狗们。而且大多数养宠物的人都选择狗。人们都说狗忠诚，但现实中也没有多少救主的机会，倒是主人们需要付出大量精力来照顾它们——喂食、洗澡、遛狗、乃至处理家中的粪便。主人们不认为这是负担，通常都觉得这是义务。</p>
<p>有的时候，真不知道是“人”离不开“狗”，还是“狗”离不开“人”。</p>
<blockquote>
<p>强大处下，柔弱处上。——《道德经》</p>
</blockquote>
<p>通常认为猫是独立的动物，狗依赖于人，这都是从人的角度看问题，其实每种动物都是独立的，只是它们的<strong>道</strong>不同，导致与“人”建立关系的方式和程度不同。</p>
<p>狗：甘心处于辅位，能够看家护院（叫和咬人），极其擅长与人互动。即便失去主人变为野狗，仍旧能心怀诚意的找下一家主人，走一家忠诚于一家。这些特性深受人类认可。</p>
<p>猫：淡然接受人类宠爱，淡然接受失去宠爱，能与人类互动，但又不完全按照人类节奏活着。我家楼下住户喜欢喂野猫，野猫也不白吃，偶尔叼只大老鼠放到楼口。这种特性通常被认为是孤高无情。</p>
<p>鸡鸭鹅：猫和狗都能与人互动。鸡鸭鹅与人互动较差，失去主人极难在城市生存下去，对人类来说，唯一的价值就是它们的肉体和后代（蛋）。</p>
<p>刺猬：我家附近公园里有不少刺猬。它们昼伏夜出，虽然生活在人类身边，但平行于人类生存。如果人类生活环境扩张，刺猬们的生活环境会相对缩小，属于此消彼长的关系。</p>
<p>上述几种动物对应于在城市的几种打工人。能<strong>独立</strong>靠脸、靠嘴生存的人是城市打工人的顶端；能独立靠技能活着的人就是所谓的中产阶级；靠消耗生命活着的人没有<strong>自由</strong>，是大多数人；不进入<strong>社会大生产</strong>，特立独行的人虽然自由，但缺乏物质资源，随着社会发展，结局不是被同化，就是自我绝育出局，但是又会有少数新的“隐士”加入或被社会排除到这个行列。</p>
<p>那么，上述的“人”对应的是谁呢？阶级社会中的权贵，或者称为稳拿，例如：官僚、地主和资本家。</p>
<p>凡是打工人，无论职位高低，技能高低，实际上都是依靠老板发的工资生活，辅佐他人成就事业。不存在什么所谓的自食其力，靠自己的劳动生活不求人，只要你在打工，就是在依靠他人，就是在求人。</p>
<p>按照阶级社会的规则，打工人处于辅位，可不要错将老板的事业当作自己的事业，哪怕混的越高，能力越强，越要注意这一点。</p>
<blockquote>
<p>坤卦 上六：龙战于野，其血玄黄。——《易经》</p>
</blockquote>
<p>我们到底要做哪种人呢？这个是我们自己可以决定的吗？大多数权贵是生出来的，后天成为权贵得靠运气。作为打工之王的舔狗也不是谁都能当的，这个需要一定的天赋。可以选择的范围貌似只有剩下的三种人：擅长学习的人成为了“中产”，进而鄙视底层的“鸡鸭鹅”，不愿意与其为伍；“鸡鸭鹅”不是选择出来的，要能选择没人愿意处于这一类，但恰恰大多数人都属于这一类；当“隐士”要有决心，跳出“三界”是需要付出代价的。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github</title>
    <url>/2017/01/20/%E4%BD%BF%E7%94%A8Github/</url>
    <content><![CDATA[<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ol>
<li>建立本地目录，放入待上传文件，进入此目录，右键菜单-&gt;Git Bash Here。</li>
<li>键入<code>git init</code>。</li>
<li>查看状态：<code>git status</code>。<a id="more"></a></li>
<li>添加文件：<code>git add 文件名</code>，或者<code>git add .</code>添加全部文件。</li>
<li>提交：<code>git commit -m &quot;显示的注释&quot;</code>。</li>
<li>钩挂地址：<code>git remote add origin https://github.com/代码仓库地址</code>。</li>
<li>上传：<code>git push -u origin master</code>，中途会提示输入用户名和密码。</li>
<li>如果报错，可能是由于本地没有README.md的缘故，可以合并代码到本地：<code>git pull --rebase origin master</code>。</li>
</ol>
<h4 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h4><ol>
<li>查看状态<code>git status</code></li>
<li>视情况<code>git add .</code></li>
<li><code>git commit -m &quot;更新说明&quot;</code></li>
<li><code>git pull</code></li>
<li><code>git push -u origin master</code></li>
<li>查看文件时间确认</li>
</ol>
]]></content>
      <categories>
        <category>PC</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo建立博客三 发布文章</title>
    <url>/2017/10/08/%E4%BD%BF%E7%94%A8Hexo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E4%B8%89%20%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="实现分类、标签和关于链接"><a href="#实现分类、标签和关于链接" class="headerlink" title="实现分类、标签和关于链接"></a>实现分类、标签和关于链接</h4><p>进入Hexo目录，右键选择Git Bash，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&#x27;categories&#x27;</span></span><br><span class="line">$ hexo new page <span class="string">&#x27;tags&#x27;</span></span><br><span class="line">$ hexo new page <span class="string">&#x27;about&#x27;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>执行这三条命令后，在hexo\source下多了三个目录：categories，tags，about，每个目录中都有一个index.md文件。打开这三个目录中的index.md，分别添加<code>type: &quot;categories&quot;</code>、<code>type: &quot;tags&quot;</code>、<code>type: &quot;about&quot;</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2017-09-29 09:51:55</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个字段后面的冒号是英文格式，而且其后要加一个空格。</p>
</blockquote>
<p>我们可以修改title项为对应中文。在about目录下的index.md中，可以写入一些介绍性文字。</p>
<h4 id="正式文章的写作"><a href="#正式文章的写作" class="headerlink" title="正式文章的写作"></a>正式文章的写作</h4><p>新建文章：<code>hexo new &#39;Name&#39;</code>，Name不带扩展名md。进入source\_posts目录，找到Name.md文件，用一个你喜欢的文本编辑器打开它，以Markdown语法进行写作。</p>
<p>新建文章台头已有title、date、tags等属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标题名</span><br><span class="line">date: 2017-9-26 15:08:20</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>tags字段是文章的标签，如果要指定多个标签需要这样做：tags: [Java,html,web]。添加categories字段，对博客进行分类管理。如果需要多级分类，按照如下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Algorithm</span><br><span class="line">- TAOCP</span><br></pre></td></tr></table></figure>
<p>这样，TAOCP就成了Algorithm的子类。</p>
<p>在博客主页面只显示部分文字，并添加“阅读全文”按钮：在文章适当的位置添加<code>&lt;!--more--&gt;</code>。</p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>本地方法：在hexo\source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为img\picName。</p>
<p>图床（一般做法）：本博客使用SM.MS图床，网址为：<a href="https://sm.ms/">https://sm.ms</a>。该图床有5G的免费空间，图片链接支持https，上传单个图片最大5M，每次最多上传10张。最好注册个账号，然后再上传图片，便于管理。</p>
<p>先把图片保存到图床，复制Markdown框中的链接，形如<code>![name.jpg](https://i.loli.net/year/month/date/encode.jpg)</code>，然后在文章中粘贴即可引入图片。</p>
<h4 id="插入音乐"><a href="#插入音乐" class="headerlink" title="插入音乐"></a>插入音乐</h4><p>网易云音乐可以生成内嵌音乐的html代码，在其网页端找到喜欢的歌曲，点击“生成外链播放器”，把里面的html代码复制下来，直接粘贴到博文中即可，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe</span><br><span class="line">   frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86</span><br><span class="line">   src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;2529461&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;</span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>
<h4 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h4><p>将优酷、B站等视频平台提供的视频外链（点击分享即可看到）或者自己制作的视频外链替换掉如下src的值即可，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe</span><br><span class="line">  src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;41672570&amp;cid&#x3D;73094526&amp;page&#x3D;1&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot;</span><br><span class="line">  frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot;&gt;</span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始安装hexo时，_posts目录下会创建一个hello-world.md，当已经具有我们自己的文章时，可将其删除。如果只有这一个文件时，不要删除它，因为_posts目录不能为空。</p>
</blockquote>
<h4 id="测试并上传"><a href="#测试并上传" class="headerlink" title="测试并上传"></a>测试并上传</h4><p>仍旧是老一套：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean        <span class="comment">#用于清除缓存</span></span><br><span class="line">$ hexo g            <span class="comment">#生成静态网页</span></span><br><span class="line">$ hexo s -p 5000    <span class="comment">#开启本地预览</span></span><br></pre></td></tr></table></figure>
<p>打开浏览器，访问localhost:5000，根据实际情况对源文件进行修改。调整完毕可上传到Github：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>此时分类和标签页就会自动出现文章的索引。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo建立博客一 安装部署</title>
    <url>/2017/10/03/%E4%BD%BF%E7%94%A8Hexo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E4%B8%80%20%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="GitHub-Hexo"><a href="#GitHub-Hexo" class="headerlink" title="GitHub + Hexo"></a>GitHub + Hexo</h4><ol>
<li>GitHub Pages有300M免费空间，而且是世界知名门户，用户可稳定使用。</li>
<li>Hexo是基于node.js的静态博客。<a id="more"></a>

</li>
</ol>
<h4 id="安装部署Git"><a href="#安装部署Git" class="headerlink" title="安装部署Git"></a>安装部署Git</h4><p>一、申请账户-&gt;New repository-&gt;输入名字<code>yourname.github.io</code>。需要注意的是仓库名必须是<code>账户名.github.io</code>。进入新建的<code>yourname.github.io</code>仓库，点击菜单栏最右侧的setting，下拉找到Github Pages，随意选择一个主题后，界面跳转回仓库，会看到多了两个文件。此时再点击Setting，在Github Pages处会显示这个域名。</p>
<p>二、下载Git：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>，选择路径后，一路next安装完成。测试是否安装成功：cmd-&gt;git –version。</p>
<p>三、检查本机的SSH KEY设置：打开Git Bash，输入cd ~/.ssh或cd .ssh，如果提示：No such file or directory，则开始配置，否则删除此目录下所有文件。配置并生成SSH KEY：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~  <span class="comment">#保证当前路径在”~”下</span></span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;邮箱地址&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/xxxx_000/.ssh/id_rsa): <span class="comment">#不填直接回车</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment">#输入密码（可以不填，回车）</span></span><br><span class="line">Enter same passphrase again: <span class="comment">#再次确认密码（可以不填，回车）</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/xxxx_000/.ssh/id_rsa. <span class="comment">#生成的密钥</span></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/xxxx_000/.ssh/id_rsa.pub. <span class="comment">#生成的公钥</span></span><br></pre></td></tr></table></figure>
<p>四、钩挂Github：在C:\Users\computer account\.ssh\中找到id_rsa.pub(公钥)，复制它的内容到Github-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH key中。</p>
<p>五、在Git Bash中配置账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name “your_username”</span><br><span class="line">$ git config --global user.email “your_registered_github_Email”</span><br></pre></td></tr></table></figure>
<p>六、测试SSH KEY是否设置成功：<code>$ssh -T git@github.com</code>，接下来会返回一些信息，并需要输入一次yes，若生成ssh key时设置有密码则还会让你输入生成ssh key时设置的密码。如果出现Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.说明设置成功。</p>
<h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p>下载node.js：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>，选择路径，一路next安装完成。测试是否安装成功：cmd-&gt;node -v。</p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>一、新建目录用于存放hexo，进入目录后右键点击Git Bash，输入<code>$ npm install -g hexo-cli</code>进行安装。如果长时间未安装成功，则更改为国内镜像<code>npm config set registry https://registry.npm.taobao.org</code>进行安装。</p>
<p>二、初始化hexo，键入<code>$hexo init</code>，这将会从官网clone下hexo，到当前目录。初始化成功，会在最后一行打印：INFO Start blogging with Hexo!</p>
<p>三、在hexo的目录，安装依赖文件：<code>npm install</code>。完成后，所有文件和目录如下：</p>
<ul>
<li>node_modules：存放依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：命令生成文章等的模板</li>
<li>source：存放创建的文章</li>
<li>themes：存放主题</li>
<li>_config.yml：整个博客的配置</li>
<li>db.json：source解析所得到的</li>
<li>package.json：项目所需模块的配置信息</li>
</ul>
<p>四、本地测试博客：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> clean</span><br><span class="line"><span class="variable">$hexo</span> generate <span class="comment">#生成网页</span></span><br><span class="line"><span class="variable">$hexo</span> server   <span class="comment">#启动本机服务</span></span><br></pre></td></tr></table></figure>
<p>打开浏览器键入：<a href="http://localhost:4000/">http://localhost:4000/</a>，如果长时间不能显示，则更改端口：<code>$hexo s -p 5000</code>。键入新网址，即可看见hexo默认主页。</p>
<h4 id="将本地hexo项目托管到Github"><a href="#将本地hexo项目托管到Github" class="headerlink" title="将本地hexo项目托管到Github"></a>将本地hexo项目托管到Github</h4><p>一、修改hexo目录下的全局配置文件_config.yml，在其中的deploy:后添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: git@github.com:YourGithubName&#x2F;YourGithubName.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每行前必须有个tab，冒号后必须有个空格。</p>
</blockquote>
<p>二、安装hexo-deployer-git插件：<code>$npm install hexo-deployer-git --save</code>。<br>这个工具用于将本地博客上传到Github，安装有可能失败，导致不能上传。可以先卸载再从master分支安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$npm</span> un hexo-deployer-git</span><br><span class="line"><span class="variable">$npm</span> i hexojs/hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>三、部署到Github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> clean     <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line"><span class="variable">$hexo</span> generate  <span class="comment">#生成静态页面至public目录</span></span><br><span class="line"><span class="variable">$hexo</span> deploy    <span class="comment">#将.deploy目录部署到GitHub</span></span><br></pre></td></tr></table></figure>
<p>如果最后一行打印出INFO Deploy done: git，则表示部署成功。</p>
<p>四、打开浏览器登录YourGithubName.github.io，就能看到那个默认hexo网页。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo建立博客二 配置博客</title>
    <url>/2017/10/05/%E4%BD%BF%E7%94%A8Hexo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E4%BA%8C%20%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>Hexo默认使用landscape主题，我们可以在<a href="https://hexo.io/themes/">https://hexo.io/themes/</a>下载其他主题。NexT主题界面简洁推荐使用，其官方主页为<a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a>。</p>
<a id="more"></a>

<h4 id="Hexo全局设置"><a href="#Hexo全局设置" class="headerlink" title="Hexo全局设置"></a>Hexo全局设置</h4><p>打开Hexo全局配置文件_config.yml，按如下注释进行设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Programmer&#39;s Speak           #站点名</span><br><span class="line">subtitle: 理论+实践&#x3D;真知+时间&#x3D;睿智    #副标题</span><br><span class="line">description: &#39;&#39;                     #对站点的描述，用于SEO</span><br><span class="line">keywords: Program                   #用于SEO</span><br><span class="line">author: Devastator                  #博主昵称</span><br><span class="line">language: zh-CN                     #博客语言</span><br><span class="line">timezone: Asia&#x2F;Shanghai             #时区</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">url: https:&#x2F;&#x2F;YourGithubName.github.io&#x2F;      #博客地址，与申请的GitHub一致</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># Directory                 目录设置，一般不修改</span><br><span class="line">source_dir: source          #源文件夹，存放文章</span><br><span class="line">public_dir: public          #公共文件夹，存放生成的静态文件</span><br><span class="line">tag_dir: tags               #标签文件夹，默认是tags。实际存放在source&#x2F;tags中。</span><br><span class="line">archive_dir: archives       #档案文件夹，默认是archives。</span><br><span class="line">category_dir: categories    #分类文件夹，默认是categories。实际存放在source&#x2F;categories中。</span><br><span class="line">code_dir: downloads&#x2F;code    #代码文件夹，默认是downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang             #国际化文件夹，默认跟language相同</span><br><span class="line">skip_render:                #跳过指定文件的渲染</span><br><span class="line"></span><br><span class="line"># Writing                   文章布局、写作格式的定义，一般不修改</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#39;&#39;</span><br><span class="line">  per_page: 10          #每页显示的Post数</span><br><span class="line">  order_by: -date       #Post的顺序（按日期从后向前排序）</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag        分类和标签，一般不修改</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format    日期、时间格式，一般不修改</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next            #博客主题，默认是landscape</span><br><span class="line"></span><br><span class="line"># Deployment           部署到Github</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: git@github.com:YourGithubName&#x2F;YourGithubName.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<h4 id="NexT主题设置"><a href="#NexT主题设置" class="headerlink" title="NexT主题设置"></a>NexT主题设置</h4><p>从NexT的github下载，解压缩后改名为next，放入theme目录。按下面注释修改NexT配置文件themes\next\_config.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes           选择样式</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line"># Dark Mode</span><br><span class="line">darkmode: false</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Site Information Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;robot_16px.png   #网站图标，存放于\next\source\images</span><br><span class="line">  medium: &#x2F;images&#x2F;robot_32px.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">menu:               # 去掉注释就可以显示，顺序可调整</span><br><span class="line">  home: &#x2F; || fa fa-home                  #首页</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th   #分类</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user           #关于</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags             #标签</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Sidebar Settings</span><br><span class="line"># See: https:&#x2F;&#x2F;theme-next.js.org&#x2F;docs&#x2F;theme-settings&#x2F;sidebar</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: &#x2F;images&#x2F;name.jpg     #头像，存放于\next\source\images</span><br><span class="line">  ......</span><br><span class="line"># Social Links              个人链接</span><br><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;name || fab fa-github</span><br><span class="line">  ......</span><br><span class="line"># Blog rolls                </span><br><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-globe</span><br><span class="line">  title: Recommend          #输入链接区域的标题</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: block</span><br><span class="line"></span><br><span class="line">links:                      #名：地址</span><br><span class="line">  Racket: https:&#x2F;&#x2F;www.racket-lang.org&#x2F;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Footer Settings</span><br><span class="line"># See: https:&#x2F;&#x2F;theme-next.js.org&#x2F;docs&#x2F;theme-settings&#x2F;footer</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">footer:</span><br><span class="line">  since: 2017       #起始年</span><br><span class="line">  ......</span><br><span class="line"># Powered by Hexo &amp; NexT</span><br><span class="line">  powered: false    #不显示“强力驱动”</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Post Settings</span><br><span class="line"># See: https:&#x2F;&#x2F;theme-next.js.org&#x2F;docs&#x2F;theme-settings&#x2F;posts</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"># Post meta display settings</span><br><span class="line">post_meta:          #文章标题内容</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true  #发表日期</span><br><span class="line">  updated_at:       #更新日期</span><br><span class="line">    enable: false</span><br><span class="line">    another_day: true</span><br><span class="line">  categories: true  #分类于</span><br><span class="line">  ......</span><br><span class="line"># Donate (Sponsor) settings</span><br><span class="line"># Front-matter variable (unsupport animation).</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, a donate button will be displayed in every article by default.</span><br><span class="line">  enable: true      #显示打赏按钮</span><br><span class="line">  animation: true</span><br><span class="line">  #comment: Buy me a coffee</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechat.png   #微信收款，存放于\next\source\images</span><br><span class="line">  alipay: &#x2F;images&#x2F;pay.jpg         #支付宝收款</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Misc Theme Settings</span><br><span class="line"># See: https:&#x2F;&#x2F;theme-next.js.org&#x2F;docs&#x2F;theme-settings&#x2F;miscellaneous</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # All available themes: https:&#x2F;&#x2F;theme-next.js.org&#x2F;highlight&#x2F;</span><br><span class="line">  theme:        #代码块高亮主题设置</span><br><span class="line">    light: atom-one-dark #railscasts</span><br><span class="line">    dark: tomorrow-night</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Third Party Plugins &amp; Services Settings</span><br><span class="line"># See: https:&#x2F;&#x2F;theme-next.js.org&#x2F;docs&#x2F;third-party-services&#x2F;</span><br><span class="line"># More plugins: https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;awesome-next</span><br><span class="line"># You may need to install the corresponding dependency packages</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 这一部分的设置在下一节说明</span><br></pre></td></tr></table></figure>
<h4 id="第三方插件和服务"><a href="#第三方插件和服务" class="headerlink" title="第三方插件和服务"></a>第三方插件和服务</h4><p>NexT支持众多第三方插件，方便用户扩展功能。在上一节中的末尾部分，就是关于插件的设置。</p>
<p>一、使用Latex数学公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (false) will load mathjax &#x2F; katex script on demand.</span><br><span class="line">  # That is it only render those page which has &#96;mathjax: true&#96; in front-matter.</span><br><span class="line">  # If you set it to true, it will load mathjax &#x2F; katex srcipt EVERY PAGE.</span><br><span class="line">  every_page: false     #一般设置为false，我们只在需要时渲染数学公式</span><br><span class="line"></span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true        #开启功能</span><br><span class="line">    # Available values: none | ams | all</span><br><span class="line">    tags: none</span><br></pre></td></tr></table></figure>
<p>按照上面设置后，每当需要在文章中使用Latex数学公式时，在文章标题中添加mathjax项：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章名</span><br><span class="line">date: 2017-9-30 11:15:36</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>二、不蒜子统计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:           #将下面的三项设置为true即可</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>
<p>设置后如果没反应，则进入next\layout\_third-party\analytics目录，打开busuanzi-counter.njk，修正其中的地址即可。</p>
<p>三、添加搜索<br>在Next的配置文件中启用搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true       #设置为true，即可启用</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br></pre></td></tr></table></figure>
<p>进入Hexo根目录，右键打开Git Bash，键入<code>$ npm install hexo-generator-searchdb --save</code>安装搜索模块。然后，在Hexo的全局配置文件_config.yml中任意位置添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>通过如下命令可以看到效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean    <span class="comment"># 用于清除缓存</span></span><br><span class="line">$ hexo generate <span class="comment"># 生成静态网页</span></span><br><span class="line">$ hexo server   <span class="comment"># 访问localhost:4000。</span></span><br></pre></td></tr></table></figure>
<p>此时点击页面中的分类、关于、标签，没有任何反应。下一篇文章会说明如何添加这些内容。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>养生的重要性</title>
    <url>/2020/09/10/%E5%85%BB%E7%94%9F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
    <content><![CDATA[<p>年龄越大越知道健康的重要性。记得刚毕业做第一份工作时，与领导的一次闲谈——他吸了一口烟，幽幽的说：“现在能活到60退休不容易！”那时，他才33岁！</p>
<p>我当时就觉得他说的是对的。在市场经济环境下，作为一个被剥削者，年轻时不爱惜身体，等到年龄大了，顶不住了，按照中国企业家推崇的“狼性”法则，会毫不犹豫地淘汰你，还得杀人诛心的说你落后产能。</p>
<a id="more"></a>

<blockquote>
<p>天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗。天地之间，其犹橐(tuó)籥(yuè)乎？虚而不屈，动而愈出。多闻数穷，不如守中。——《道德经》</p>
</blockquote>
<p>如果自己都不珍惜自己，活该短命！</p>
<h4 id="防电磁辐射"><a href="#防电磁辐射" class="headerlink" title="防电磁辐射"></a>防电磁辐射</h4><p>这个有点玄乎，比吃转基因食品还玄，毕竟没有直接证据证明对人体有伤害。不过从中国传统养生思想的角度看，非自然的东西注意点没坏处。</p>
<p>解决方案：喝绿茶，吃胡萝卜、豆芽，在计算机旁放香蕉、仙人掌。</p>
<h4 id="颈椎视力"><a href="#颈椎视力" class="headerlink" title="颈椎视力"></a>颈椎视力</h4><p>久坐伤腰，当然颈椎也好不到哪去，视力也是个问题，毕竟现在办公室工作都使用计算机。目前对于视力伤害最大的是手机，一般人总是利用边角时间玩手机，对于距离、光线往往不在意。</p>
<p>解决方案：在工作过程中保持正确的坐姿</p>
<p><img src="https://i.loli.net/2021/08/22/nNLxXYDQGO8qtSJ.png" alt="1坐姿.png"></p>
<ol>
<li>身体向后倾，颈部有扶托</li>
<li>手臂自然下垂，放置椅子托手</li>
<li>手与键盘平行</li>
<li>膝盖微高于座椅，血液顺畅运行</li>
<li>屏幕略低于视线</li>
</ol>
<blockquote>
<p>正确的姿势也替代不了定时休息</p>
</blockquote>
<p>当前人们对手机有种依赖，就像烟民抽烟一样，是个心理问题，不好解决。我觉得通过减少使用手机的机会比较有效，平时少在家里待着，增加户外活动时间。枸杞子和决明子泡茶对眼睛有好处，眼睛干涩可用冰袋冷敷15分钟。</p>
<h4 id="肠胃病"><a href="#肠胃病" class="headerlink" title="肠胃病"></a>肠胃病</h4><p>在中国小微企业工作，凡是岗位重要点的，几乎可以说没有肠胃好的人。通常小企业领导都没有按时吃饭的概念，作为下属自然也得陪着，实在饿得不行了，随便吃口凉饭对付一下。晚上熬夜吃垃圾食品，早晨起不来自然不吃早饭。小饭馆的饭菜卫生也靠不住。</p>
<p>平时上班压力就不小，公司业绩不好还得变本加厉，绩效有没有放一边，瞎折腾是少不了的。人在折腾的环境中很难平复心情：不动心思人倒霉，动心思心累伤脾，老胃病容易复发。</p>
<p>解决方案：正常工作，按时吃饭，吃饭不要过快，尽量吃热饭，只有凉饭时一定要细嚼慢咽。苹果含鞣酸，对肠胃有好处，我个人非常推荐。在公司准备一些饼干、面包（一定得是<strong>干</strong>粮，馒头不行）以备不测。</p>
<h4 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h4><p>在当前中国，作为一个打工人，心态的重要性无须多讲。小企业不讲理是赤裸裸的，尤其是在公司业绩不好的时候，老板不爽直接开骂，中层为自保策划一堆“不可能实现”任务，基层员工憋气窝火是家常便饭。</p>
<p>大企业内部体系结构已建立，每个岗位实际上都变得不那么重要了。公司每个人的命运并不决定于他的业务能力，而是领导的信任程度。现实往往是人以类聚，不同性格的人走不到一起，派系林立是必然的。没有派系，没有领导的信任就不要大展拳脚，自作聪明没有好下场。</p>
<p>人一定要顺应自然，以实际环境为基础灵活做事，不要有思维定式，即使作为公司高层也不行。如果是管理工作，凡事一定要将自己从事件中摘出来（至少心态要出的来）。技术工作也得有自知之明，要知道这年头的世界是围着资本转的。</p>
<p>如果在一份工作中，既感到身体劳累，又感到憋气窝火时，说明你与这份工作已经无缘了，结果不是你主动离职，就是企业逼你离职。三十六计，走为上计，主动离职才能有充裕的时间摆好“着陆”姿势。</p>
<h4 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h4><p>身体是心理的基础，没有好身体，不会有自信，心态自然好不了。当前打工人大部分都处于亚健康状态，身体需要锻炼是大家的共识。于是，大家纷纷痛下决心，先后买了健身房年卡，以为有个圈子就能将健身坚持下去，但是去过一两次之后……</p>
<p>其实这也是可以理解的，毕竟大家上班幸苦一天，回到家中就不想再出去折腾了。如果连晚上遛弯都做不到的话，怎么能指望出门健身。我觉得徒手健身，是打工人最合理的选择，至多买根跳绳、买对哑铃就可以了。</p>
<p>今年年初，武汉爆发新型冠状病毒疫情，公司不得已放了个长假，也就有了一些精力。我从5月开始跳绳，第一天就伤到了膝盖。这可不是肌肉酸疼，而是骨头缝隐痛……岁月不饶人啊 :)</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>正所谓“工欲善其事，必先利其器”，千万不要在生产力工具上省钱，因为长期使用劣质工具会影响身心健康。在兴趣爱好上，最好也不要在工具上马虎，质量差的工具有时就是劝退工具，尤其是在入门阶段，一旦放弃即使花钱再少也是浪费。</p>
<p>我们在做事前最好想清楚，下决心后就得哄着自己前进，购买<strong>正确</strong>的工具就是对自己最好的激励。所谓“正确”，就是要站在合理的角度上考虑价格：购买设备要综合考虑质量和用途，没必要为自己不需要的功能买单；购买耗材不妨尝试一些高端的，毕竟耗材的单价不会太高。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>变形金刚玩具</title>
    <url>/2017/11/18/%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A%E7%8E%A9%E5%85%B7/</url>
    <content><![CDATA[<p>时隔多年，再次想到玩变形金刚玩具不是因为几部电影。2008年，看过第一部电影，只记住了一个片段——眩晕登场，当时确实被眩晕的变形过程惊艳到了，气氛烘托的也不错，变形后的打斗——黑夜、晃镜——瞬间失望。</p>
<p>2016年，在玩过《变形金刚：赛博坦之战》和《变形金刚：赛博坦陨落》后，又重新感受到了童年的兴奋。这两部游戏的人设、剧情很到位，强烈推荐给变形金刚爱好者。</p>
<p>于是呢——萌生了买几个模型的意愿。经过网上查阅对比，在今年双十一购买了MPP10擎天柱（Optimus Prime），一方面圆了童年的愿念，但也为自己开了一个花钱的新坑:D</p>
<a id="more"></a>

<p>整体造型还原，变形合理，车窗、脚板、领导模块等处使用了合金件，32厘米高的玩具拿在手里沉甸甸的。虽然变形手感没官方MP10好，但胸部添加卡扣合缝更紧实，手指添加金属轴不会脱落，而且价格远远低于MP10。</p>
<p><img src="https://i.loli.net/2021/11/06/dKSqb1Vv5QztXOI.png" alt="1擎天柱.png"><br><img src="https://i.loli.net/2020/02/02/trgl6jQcuMOWkio.jpg" alt="擎天柱-3.jpg"></p>
<p>小时候最喜欢的变形金刚就是擎天柱、大力神、声波；最讨厌的是铁皮、大黄蜂、威震天。擎天柱作为正义的主角，最先受到关注。每次柱子出场，我都激动万分。具体剧情虽然都不记得了，但在印象里总有一个擎天柱的形象：博派一堆小车被打的七零八落，一辆大卡车开过来——变形——干趴狂派所有坏蛋:D</p>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Transformers</category>
      </categories>
      <tags>
        <tag>Transformers</tag>
      </tags>
  </entry>
  <entry>
    <title>声波（Soundwave）</title>
    <url>/2020/12/20/%E5%A3%B0%E6%B3%A2%EF%BC%88Soundwave%EF%BC%89/</url>
    <content><![CDATA[<p>在我的记忆里，声波几乎每一集都会出现，而且实力强悍鲜有败绩。它的磁带部队除了战斗，还具有多种特殊能力。虽说这支磁带部队的个体是独立的，但通常都会被当作是声波能力的延申。声波的人设很低调，长期如此容易被“遗忘”。其实，大众总是被表面光鲜的角色所吸引，低调做事即使能力再强也会被熟视无睹。</p>
<a id="more"></a>

<p>游戏“赛博坦陨落”中的声波比在动画中还要低调，几乎没有台词。当猛大帅锤扁威震天后，声波暗中将散落的零件找了回来，充分体现了声波的忠诚；在游戏的最后一节，声波作为追击方舟的先锋，非常还原T1动画。</p>
<p>电影里的声波就差强人意了。“变型金刚2”中的间谍卫星给人一定的期待，但只出现了几分钟。“变型金刚3”中的奔驰轿车不符合声波的常规人设，辨识度极低且全场酱油，最扯淡的是，最后竟然被大黄蜂打爆了！！！</p>
<p><img src="https://i.loli.net/2021/11/07/aFhngIKrWS7vzLG.png" alt="1声波.png"></p>
<p>如图，整体造型还是不错的，非常还原T1动画，胸口磁带仓可以放三盘磁带，每一盘磁带都可以变形。主体背后有个机关，可以将里面的磁带弹射出去。</p>
<p>在拥有了所有喜欢的角色后，我有点脱坑了。对于一个成年人来说，我不是把玩党，时间上就不允许，购买玩具就是因为情怀。这些玩具买来后也就变形一两次，然后就放柜子里摆着了，闲暇之余隔着柜子玻璃看看它们^o^</p>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Transformers</category>
      </categories>
      <tags>
        <tag>Transformers</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机一 起点</title>
    <url>/2011/09/26/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%80%20%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>学习计算机技术要动手，只看书学不会真功夫。学习单片机也不例外，买一块开发板是必须的，所幸价格不贵。</p>
<p>对于一个学“软件”的人来说，Web编程就是操作网页；VC++编程就是操作各种系统资源；单片机编程操作的是什么呢？我觉得就是操作各种电子器件。</p>
<a id="more"></a>

<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>一 开发工具<br>开发板随书光盘附带的是Keil uVision2 v2.38a，按照向导选择默认安装到C盘，其他参照向导一路向下即可。</p>
<p>二 烧录工具<br>先在PC上安装“USB转串口”驱动CH341SER.exe到默认路径。将“USB转串口”线连接到PC（不连接开发板），会弹出发现新硬件向导，选择自动安装。完成后，打开“设备管理器”，记下“端口（COM和LPT）”下CH340设备的COM号。</p>
<p>安装STC_ISP_V3.1比较烦人，总是报错，尤其是在win7环境下。一路忽略、确定后，程序安装成功。启动程序可能报错，提示“部件*.ocx不能正确注册”，此时将STC解压版目录下的所有ocx文件复制到C:\Windows\System32内。再不行，将STC解压版目录下所有dll文件复制到System32。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>一 新建项目<br>打开Keil，新建工程通过菜单Project-&gt;New Project，选择路径，填写工程名保存，弹出对话框，让你选择单片机型号。我们根据实际开发板所使用的单片机，选择Atmel的AT89C52。</p>
<p>然后，新建文件通过菜单File-&gt;New，保存这个文件，填入文件名.c。在左侧窗口，右键Source group 1，选择Add File to Group ‘Source Group 1’，添加刚才新建的.c文件。</p>
<p>此时，我们就可以开始编写代码了。如果觉得代码字体不好看，可以通过菜单View-&gt;Options，选择Color&amp;Fonts属性页，选中Editor C files，调整字体、字号、颜色。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit P1_4 = P1^<span class="number">4</span>;   <span class="comment">//不能放在main函数内</span></span><br><span class="line">sbit P1_6 = P1^<span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P1_4 = P1_6 = <span class="number">0</span>;<span class="comment">//形成压差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单片机初始上电时，所有I/O口默认都是高电平。</p>
</blockquote>
<p>在工具栏点击Options for Target图标，</p>
<p><img src="https://i.loli.net/2020/08/01/WtcOLanw8EejXUy.png" alt="工具栏.png"></p>
<p>在弹出的对话框中，找到Target属性页，键入开发板的频率11.0592，</p>
<p><img src="https://i.loli.net/2020/08/01/OjRbZBLk3HoCyT8.png" alt="target.png"></p>
<p>在Output属性页勾选“Create HEX File”，确定。</p>
<p><img src="https://i.loli.net/2020/08/01/42k9v6pOWMhyL5Q.png" alt="output.png"></p>
<p>在工具栏点击Rebuild all target files图标进行编译。</p>
<p>二 下载程序<br>将开发板连接到PC，占用两个USB接口，一个提供电力，一个用于数据下载。我们启动STC_ISP_V3.1程序，选择MCU Type为STC89C52RC，选择COM为我们的COM口，选择Max Buad为115200。点击Open File按钮，选择我们编译成功的HEX文件。点击Download/下载按钮，然后再打开开发板电源，即可下载程序，显示结果。</p>
<p><img src="https://i.loli.net/2020/08/01/DTJCc6YLeRudjty.png" alt="烧录.png"></p>
<p>按照上述程序，应该是八只发光二极管中的第5、第7只常亮。</p>
<h4 id="51芯片"><a href="#51芯片" class="headerlink" title="51芯片"></a>51芯片</h4><p>STC89C52RC是STC公司生产的一种低功耗、高性能CMOS8位微控制器，使用经典的MCS-51内核，具有特性：8k字节Flash，512字节RAM，32位I/O口线，3个16位定时器/计数器，4个外部中断，全双工串行口。</p>
<p><img src="https://i.loli.net/2020/07/27/XhEenFCVYTkGJBI.png" alt="STC89C52RC.jpg"></p>
<p>一般在芯片表面会有一个圆坑，代表第1引脚，其他按逆时针顺延。40个引脚分为三类：</p>
<ol>
<li>电源和时钟：Vcc、GND、XTAL1、XTAL2。</li>
<li>控制引脚：RST、$\overline{PSEN}$、ALE/$\overline{PROG}$、$\overline{EA}$/Vpp。</li>
<li>I/O引脚：P0、P1、P2、P3。</li>
</ol>
<h4 id="C51语言"><a href="#C51语言" class="headerlink" title="C51语言"></a>C51语言</h4><p>C51语言其实就是C语言，只不过是单片机平台的C语言。C语言其实就是一个标准，其描述能力以CPU为基础。C语言只会实现CPU支持的功能，不会做“多余”的事情。</p>
<p>一 数据类型</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="center">位数</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unsigned char</td>
<td align="center">8</td>
<td align="center">0~255</td>
</tr>
<tr>
<td align="left">char</td>
<td align="center">8</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="center">16</td>
<td align="center">0~65535</td>
</tr>
<tr>
<td align="left">int</td>
<td align="center">16</td>
<td align="center">-32768~32767</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="center">32</td>
<td align="center">0~$2^{32}$-1</td>
</tr>
<tr>
<td align="left">long</td>
<td align="center">32</td>
<td align="center">−$2^{31}$~$2^{31}$-1</td>
</tr>
<tr>
<td align="left">float</td>
<td align="center">32</td>
<td align="center">3.4e-38~3.4e38</td>
</tr>
<tr>
<td align="left">double</td>
<td align="center">64</td>
<td align="center">1.7e-308~1.7e308</td>
</tr>
<tr>
<td align="left">bit</td>
<td align="center">1</td>
<td align="center">0~1</td>
</tr>
</tbody></table>
<p>上述基本类型是C语言通用的，还有一些C51特有的数据类型：</p>
<ul>
<li>sfr 8位特殊功能寄存器声明</li>
<li>sfr16 16位特殊功能寄存器声明</li>
<li>sbit 特殊功能位声明</li>
<li>bit 1位变量声明</li>
</ul>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sfr P1 = <span class="number">0x88</span>; 		<span class="comment">//8位寄存器直接赋值</span></span><br><span class="line">sbit P1_6 = P1^<span class="number">6</span>; 	<span class="comment">//定义P1_6为P1寄存器的第7位</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>像P1这种表示单片机寄存器的变量都被定义在reg52.h中。</p>
</blockquote>
<p>二 运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+ - * / %</td>
<td align="center">加减乘除余</td>
</tr>
<tr>
<td align="left">&gt; &gt;= &lt; &lt;=</td>
<td align="center">大小比较</td>
</tr>
<tr>
<td align="left">== !=</td>
<td align="center">等于 不等</td>
</tr>
<tr>
<td align="left">&amp;&amp; || !</td>
<td align="center">与或非</td>
</tr>
<tr>
<td align="left">&amp; | ~</td>
<td align="center">位与 位或 位反</td>
</tr>
<tr>
<td align="left">^</td>
<td align="center">异或</td>
</tr>
<tr>
<td align="left">&gt;&gt; &lt;&lt;</td>
<td align="center">右移 左移</td>
</tr>
</tbody></table>
<p>三 表达式</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">if</td>
<td align="center">分支</td>
</tr>
<tr>
<td align="left">switch case</td>
<td align="center">多分支</td>
</tr>
<tr>
<td align="left">while</td>
<td align="center">循环</td>
</tr>
<tr>
<td align="left">do while</td>
<td align="center">循环</td>
</tr>
<tr>
<td align="left">for</td>
<td align="center">循环</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机七 IIC总线</title>
    <url>/2011/10/15/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%83%20IIC%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><p>$I^2C$总线（Inter IC Bus）是由PHILIPS公司制定的一种总线标准，是同步通信的一种方式，具有控制简单、器件封装小、通信速率较高等优点。</p>
<p>$I^2C$总线由数据线SDA和时钟线SCL组成，可在CPU和IC之间、IC和IC之间进行双向通信，最高传送速率为400Kbps。各种器件并联在总线上，通过唯一硬件地址寻址。</p>
<a id="more"></a>

<p>$I^2C$总线的一般连接逻辑如图：</p>
<p><img src="https://i.loli.net/2020/09/22/Z1JKb2D45OjNqUk.png" alt="1基本结构.png"></p>
<p>如图，SDA和SCL接10K上拉电阻。当总线空闲时，两根线均为高电平。连接到总线上的任一器件输出低电平，都将使总线的信号变低，即各器件都是线“与”关系。</p>
<p>$I^2C$总线支持多主机方式和主从方式。多主机方式需要总线仲裁，以决定由哪个主机控制总线。主从方式就是主机通过总线控制从机，开发板采用的就是这一方式。</p>
<p><img src="https://i.loli.net/2020/09/22/GWpjmgykA7xFEsM.png" alt="2EEPROM电路.PNG"></p>
<p>STC80C52本身没有$I^2C$总线，开发板使用I/O管脚P2.0作为SDA，P2.1作为SCL，然后通过编程控制管脚的值来模拟$I^2C$总线的时序。</p>
<h4 id="IIC通信与模拟"><a href="#IIC通信与模拟" class="headerlink" title="IIC通信与模拟"></a>IIC通信与模拟</h4><p>所谓模拟，就是通过编程控制作为SDA和SCL的管脚来模拟总线时序，以此控制$I^2C$设备。</p>
<p>当总线空闲时，两根线均为高电平，用C语言模拟如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay();    <span class="comment">//&gt;4us</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有数据传输时，时钟线SCL以固定周期输出高低电平。我们主要考虑如何通过对数据线SDA的操作来顺应SCL周期变化来传输数据。</p>
<p>一、起始终止信号<br>SCL在高电平期间，SDA由高转低表示起始，SDA由低转高表示终止。</p>
<p><img src="https://i.loli.net/2020/09/22/AnRseor3Gam5Tu9.png" alt="3起始结束.png"></p>
<p>如图，所有延时的时间应大于4us。使用代码模拟这种时序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDA = <span class="number">1</span>;    <span class="comment">//维持高电平&gt;4.7us</span></span><br><span class="line">    SCL = <span class="number">1</span>;    <span class="comment">//保持高电平</span></span><br><span class="line">    delay();</span><br><span class="line">    SDA = <span class="number">0</span>;    <span class="comment">//维持低电平&gt;4us</span></span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDA = <span class="number">0</span>;    <span class="comment">//维持低电平&gt;4us</span></span><br><span class="line">    SCL = <span class="number">1</span>;    <span class="comment">//保持高电平</span></span><br><span class="line">    delay();</span><br><span class="line">    SDA = <span class="number">1</span>;    <span class="comment">//维持高电平&gt;4.7us</span></span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SDA应该在SCL前赋值。因为在SCL为1时，SDA应该保持稳定。另外，对于start函数，如果先将SCL赋值为1，再将SDA赋值为1，可能会导致一个上升沿，因为之前SDA可能为0。同理stop函数。</p>
</blockquote>
<p>二、读写数据与应答<br>在$I^2C$总线传送有效数据时，SDL为高电平，SDA必须保持稳定，SDL为低电平，SDA才允许变化。</p>
<p><img src="https://i.loli.net/2020/09/22/Jt3MODdjFbs7IgX.png" alt="4数据传输与应答.png"></p>
<p>地址有7位和10位两种。7位从机地址加上1位方向位构成一个字节有效数据。从机地址由固定部分和可编程部分组成，可编程部分决定了同一种器件可接入数目。方向位为0表示主机对从机进行写操作；方向位为1表示主机对从机进行读操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writebyte</span><span class="params">(uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i, temp;</span><br><span class="line">    temp = date;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp &lt;&lt; <span class="number">1</span>;   <span class="comment">//从高到低传送</span></span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        delay();</span><br><span class="line">        SDA = CY;   <span class="comment">//SCL为低电平时改变SDA</span></span><br><span class="line">        delay();</span><br><span class="line">        SCL = <span class="number">1</span>;    <span class="comment">//SCL为高电平时SDA数据稳定</span></span><br><span class="line">        delay();</span><br><span class="line">    &#125;</span><br><span class="line">    SCL = <span class="number">0</span>;        <span class="comment">//释放总线</span></span><br><span class="line">    delay();</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uchar <span class="title">readbyte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i, result=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*  SCL = 0;        //释放总线</span></span><br><span class="line"><span class="comment">    delay();</span></span><br><span class="line"><span class="comment">    SDA = 1;</span></span><br><span class="line"><span class="comment">    delay();*/</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SCL = <span class="number">1</span>;    <span class="comment">//SCL为高电平时SDA数据稳定</span></span><br><span class="line">        delay();</span><br><span class="line">        result = (result&lt;&lt;<span class="number">1</span>)|SDA;   <span class="comment">//稳定后获取SDA</span></span><br><span class="line">        SCL = <span class="number">0</span>;    <span class="comment">//SCL为低电平，使得SDA得到新数据</span></span><br><span class="line">        delay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每传送一个字节有效数据，都要有一个应答信号，以确定数据被对方收到。应答信号就是在SCL为高电平时，由接收设备将SDA置为低电平。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">respond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay();</span><br><span class="line">    <span class="keyword">while</span> ((SDA==<span class="number">1</span>) &amp;&amp; (i&lt;<span class="number">255</span>))<span class="comment">//等待从机应答</span></span><br><span class="line">        i++;</span><br><span class="line">    delay();    <span class="comment">//SDA=0超过4us</span></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码融合了应答和非应答。</p>
</blockquote>
<h4 id="使用IIC与EEPROM通信"><a href="#使用IIC与EEPROM通信" class="headerlink" title="使用IIC与EEPROM通信"></a>使用IIC与EEPROM通信</h4><p>开发板上安装的EEPROM是ATMEL公司的AT24C02，具有2K容量，能保存数据100年，擦写次数可达10万次以上。</p>
<p><img src="https://i.loli.net/2020/09/22/SzyF3NUtVRvIWqw.png" alt="5AT24C02A.PNG"></p>
<ol>
<li>A0、A1、A2可编程地址输入端。</li>
<li>GND电源地，Vcc电源。</li>
<li>SDA串行数据输入/输出端；SCL串行时钟输入端。</li>
<li>WP写保护输入端，低电平正常读写，高电平只读。</li>
</ol>
<p>AT24C02的硬件地址：</p>
<p><img src="https://i.loli.net/2020/09/22/He6oXmlbEgvfsai.png" alt="6硬件地址.PNG"></p>
<p>AT24C02容量为2K，如图硬件地址固定部分为1010，后三位A2A1A0为可编程部分，$R/\overline{W}$为方向位。按照当前开发板接法，后三位皆为0。方向位为0，表示对从机写操作，为1表示对从机读操作。</p>
<p>串行EEPROM一般有两种写入方式：字节写入方式和页写入方式。AT24C系列芯片在页写入方式下，接收到每一个字节数据后地址自动加1。如果写到页内最后一个字节，主机继续发送数据，数据将重新从该页首地址写入（上卷）。解决方法是在第8个数据后，将地址强制加1。下面是AT24C系列芯片的读写时序：</p>
<p>一、主机向从机写入一个字节</p>
<p><img src="https://i.loli.net/2020/09/22/B7btceWovgdPhIT.png" alt="7字节写.PNG"></p>
<p>利用模拟函数，实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_date</span><span class="params">(uchar address,uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    start();</span><br><span class="line">    writebyte(<span class="number">0xa0</span>);    <span class="comment">//硬件地址</span></span><br><span class="line">    respond();</span><br><span class="line">    writebyte(address); <span class="comment">//存储单元地址</span></span><br><span class="line">    respond();</span><br><span class="line">    writebyte(date);    <span class="comment">//写一个字节数据</span></span><br><span class="line">    respond();</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、主机向从机写入多个字节</p>
<p><img src="https://i.loli.net/2020/09/22/WnveyoaPU5fdJDk.png" alt="8页写.PNG"></p>
<p>三、主机向从机读取当前地址数据</p>
<p><img src="https://i.loli.net/2020/09/22/QeTy5hrnJUcl8fu.png" alt="9当前读.PNG"></p>
<p>四、主机向从机读取随机地址数据</p>
<p><img src="https://i.loli.net/2020/09/22/kINVmu9dsQELgYK.png" alt="10随机读.PNG"></p>
<p>利用模拟函数，实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uchar <span class="title">read_date</span><span class="params">(uchar address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar date;</span><br><span class="line">    start();</span><br><span class="line">    writebyte(<span class="number">0xa0</span>);    <span class="comment">//硬件地址，写</span></span><br><span class="line">    respond();</span><br><span class="line">    writebyte(address); <span class="comment">//存储单元地址</span></span><br><span class="line">    respond();</span><br><span class="line">    start();</span><br><span class="line">    writebyte(<span class="number">0xa1</span>);    <span class="comment">//硬件地址，读</span></span><br><span class="line">    respond();</span><br><span class="line">    date = readbyte();  <span class="comment">//读一个字节</span></span><br><span class="line">    stop();</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、主机向从机连续读取数据</p>
<p><img src="https://i.loli.net/2020/09/22/w8d2Cj6LGpi1WR9.png" alt="11连续读.PNG"></p>
<p>例：保存秒数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line">sbit SDA = P2^<span class="number">0</span>;</span><br><span class="line">sbit SCL = P2^<span class="number">1</span>;</span><br><span class="line">sbit duan = P2^<span class="number">6</span>;</span><br><span class="line">sbit wei = P2^<span class="number">7</span>;</span><br><span class="line">uchar code table[]=&#123;</span><br><span class="line"><span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;;;&#125;   <span class="comment">//4us-5us延时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">respons</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writebyte</span><span class="params">(uchar)</span></span>;</span><br><span class="line"><span class="function">uchar <span class="title">readbyte</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_date</span><span class="params">(uchar address,uchar date)</span></span>;</span><br><span class="line"><span class="function">uchar <span class="title">read_date</span><span class="params">(uchar address)</span></span>;</span><br><span class="line">uchar write=<span class="number">0</span>, sec=<span class="number">0</span>, t=<span class="number">0</span>;  <span class="comment">//存储标志，秒，计数器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    sec = read_date(<span class="number">6</span>); <span class="comment">//首次运行先读取sec存储区</span></span><br><span class="line">    <span class="keyword">if</span> (sec &gt; <span class="number">100</span>)      <span class="comment">//保存在地址6处</span></span><br><span class="line">        sec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>;             <span class="comment">//启动定时器0中断</span></span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    TMOD = <span class="number">0x01</span>;        <span class="comment">//方式1</span></span><br><span class="line">    TH0 = (<span class="number">65535</span><span class="number">-50000</span>)/<span class="number">256</span>;    <span class="comment">//50ms</span></span><br><span class="line">    TH0 = (<span class="number">65535</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        display(sec);   <span class="comment">//以两位显示秒</span></span><br><span class="line">        <span class="keyword">if</span> (write == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write = <span class="number">0</span>;  <span class="comment">//标志清0</span></span><br><span class="line">            write_date(<span class="number">6</span>,sec);<span class="comment">//保存当前秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time0</span><span class="params">()</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = (<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">20</span>)    <span class="comment">//1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        sec++;      <span class="comment">//累积秒</span></span><br><span class="line">        write = <span class="number">1</span>;  <span class="comment">//显示并保存秒</span></span><br><span class="line">        <span class="keyword">if</span> (sec == <span class="number">100</span>)</span><br><span class="line">            sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uchar n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay();    <span class="comment">//&gt;4us</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDA = <span class="number">1</span>;    <span class="comment">//维持高电平&gt;4.7us</span></span><br><span class="line">    SCL = <span class="number">1</span>;    <span class="comment">//保持高电平</span></span><br><span class="line">    delay();</span><br><span class="line">    SDA = <span class="number">0</span>;    <span class="comment">//维持低电平&gt;4us</span></span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDA = <span class="number">0</span>;    <span class="comment">//维持低电平&gt;4us</span></span><br><span class="line">    SCL = <span class="number">1</span>;    <span class="comment">//保持高电平</span></span><br><span class="line">    delay();</span><br><span class="line">    SDA = <span class="number">1</span>;    <span class="comment">//维持高电平&gt;4.7us</span></span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">respond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay();</span><br><span class="line">    <span class="keyword">while</span> ((SDA==<span class="number">1</span>) &amp;&amp; (i&lt;<span class="number">255</span>))<span class="comment">//等待从机应答</span></span><br><span class="line">        i++;</span><br><span class="line">    delay();        <span class="comment">//SDA=0超过4us</span></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writebyte</span><span class="params">(uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i, temp;</span><br><span class="line">    temp = date;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp &lt;&lt; <span class="number">1</span>;   <span class="comment">//从高到低传送</span></span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">        delay();</span><br><span class="line">        SDA = CY;   <span class="comment">//SCL为低电平时改变SDA</span></span><br><span class="line">        delay();</span><br><span class="line">        SCL = <span class="number">1</span>;    <span class="comment">//SCL为高电平时SDA数据稳定</span></span><br><span class="line">        delay();</span><br><span class="line">    &#125;</span><br><span class="line">    SCL = <span class="number">0</span>;        <span class="comment">//释放总线</span></span><br><span class="line">    delay();</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uchar <span class="title">readbyte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i, result=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*  SCL = 0;        //释放总线</span></span><br><span class="line"><span class="comment">    delay();</span></span><br><span class="line"><span class="comment">    SDA = 1;</span></span><br><span class="line"><span class="comment">    delay();*/</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SCL = <span class="number">1</span>;    <span class="comment">//SCL为高电平时SDA数据稳定</span></span><br><span class="line">        delay();</span><br><span class="line">        result = (result&lt;&lt;<span class="number">1</span>)|SDA;   <span class="comment">//稳定后获取SDA</span></span><br><span class="line">        SCL = <span class="number">0</span>;    <span class="comment">//SCL为低电平，使得SDA得到新数据</span></span><br><span class="line">        delay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_date</span><span class="params">(uchar address,uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    start();</span><br><span class="line">    writebyte(<span class="number">0xa0</span>);    <span class="comment">//硬件地址</span></span><br><span class="line">    respond();</span><br><span class="line">    writebyte(address); <span class="comment">//存储单元地址</span></span><br><span class="line">    respond();</span><br><span class="line">    writebyte(date);    <span class="comment">//写一个字节数据</span></span><br><span class="line">    respond();</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uchar <span class="title">read_date</span><span class="params">(uchar address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar date;</span><br><span class="line">    start();</span><br><span class="line">    writebyte(<span class="number">0xa0</span>);    <span class="comment">//硬件地址，写</span></span><br><span class="line">    respond();</span><br><span class="line">    writebyte(address); <span class="comment">//存储单元地址</span></span><br><span class="line">    respond();</span><br><span class="line"></span><br><span class="line">    start();</span><br><span class="line">    writebyte(<span class="number">0xa1</span>);    <span class="comment">//硬件地址，读</span></span><br><span class="line">    respond();</span><br><span class="line">    date = readbyte();  <span class="comment">//读一个字节</span></span><br><span class="line">    stop();</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uchar n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar d = n % <span class="number">10</span>;    <span class="comment">//得到个位</span></span><br><span class="line">    uchar t = n / <span class="number">10</span>;    <span class="comment">//得到十位</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[d];       <span class="comment">//显示个位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0xfd</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delayms(<span class="number">5</span>);          <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[t];       <span class="comment">//显示十位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0xfe</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delayms(<span class="number">5</span>);          <span class="comment">//延时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机三 外部中断和定时器中断</title>
    <url>/2011/09/30/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%89%20%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h4 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h4><p>中断的概念很简单，完整的过程分为中断请求、中断响应、中断处理、中断返回。这四个步骤的主体不同，中断请求是由外围设备发出，中断响应、中断处理和中断返回是单片机的工作。中断很有用，是实时处理的基础。</p>
<a id="more"></a>

<p>8052有6个中断源，2个优先级。2个外部中断（INT0、INT1），3个定时器中断（T0、T1、T2），1个串口中断（TI/RI）。默认优先级如下：</p>
<table>
<thead>
<tr>
<th align="left">中断源</th>
<th align="center">中断级别</th>
<th align="center">序号</th>
<th align="center">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INT0</td>
<td align="center">最高</td>
<td align="center">0</td>
<td align="center">0003H</td>
</tr>
<tr>
<td align="left">T0</td>
<td align="center">第二</td>
<td align="center">1</td>
<td align="center">000BH</td>
</tr>
<tr>
<td align="left">INT1</td>
<td align="center">第三</td>
<td align="center">2</td>
<td align="center">0013H</td>
</tr>
<tr>
<td align="left">T1</td>
<td align="center">第四</td>
<td align="center">3</td>
<td align="center">001BH</td>
</tr>
<tr>
<td align="left">TI/RI</td>
<td align="center">第五</td>
<td align="center">4</td>
<td align="center">0023H</td>
</tr>
<tr>
<td align="left">T2</td>
<td align="center">最低</td>
<td align="center">5</td>
<td align="center">002BH</td>
</tr>
</tbody></table>
<blockquote>
<p>其中的序号，在编写中断处理程序时，用于标识中断源。</p>
</blockquote>
<p>要使用中断，需要设置两个寄存器：中断允许寄存器IE和中断优先级寄存器IP。单片机复位后，两寄存器清0。</p>
<p>一、IE寄存器用来设定各个中断源的开关，共有8位，位地址为A8H~AFH，所以IE的每一位可单独访问。</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全局</td>
<td align="center">–</td>
<td align="center">定时器2</td>
<td align="center">串口</td>
<td align="center">定时器1</td>
<td align="center">硬件1</td>
<td align="center">定时器0</td>
<td align="center">硬件0</td>
</tr>
<tr>
<td align="center">EA</td>
<td align="center">–</td>
<td align="center">ET2</td>
<td align="center">ES</td>
<td align="center">ET1</td>
<td align="center">EX1</td>
<td align="center">ET0</td>
<td align="center">EX0</td>
</tr>
<tr>
<td align="center">AFH</td>
<td align="center">–</td>
<td align="center">ADH</td>
<td align="center">ACH</td>
<td align="center">ABH</td>
<td align="center">AAH</td>
<td align="center">A9H</td>
<td align="center">A8H</td>
</tr>
</tbody></table>
<blockquote>
<p>对应位为1，对应中断打开；否则关闭中断。</p>
</blockquote>
<p>二、IP寄存器用来设置各个中断源的优先级，共有8位，位地址为B8H~BFH，所以IP的每一位可单独访问。</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">串口</td>
<td align="center">定时器1</td>
<td align="center">硬件1</td>
<td align="center">定时器0</td>
<td align="center">硬件0</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">PS</td>
<td align="center">PT1</td>
<td align="center">PX1</td>
<td align="center">PT0</td>
<td align="center">PX0</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">BCH</td>
<td align="center">BBH</td>
<td align="center">BAH</td>
<td align="center">B9H</td>
<td align="center">B8H</td>
</tr>
</tbody></table>
<blockquote>
<p>对应位为1，对应中断定义为高优先级；否则为低优先级中断。</p>
</blockquote>
<h4 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h4><p>外部中断靠硬件置位触发。STC89C52复用了两个I/O端口，分别是P3.2（$\overline{INT0}$）和P3.3（$\overline{INT1}$）。当有低电平进入这两个管脚，对应的中断会被触发。</p>
<p>例：外部中断0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a = <span class="number">0xF0</span>;<span class="comment">//全局变量方便中断处理函数访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//开启总中断</span></span><br><span class="line">    EX0 = <span class="number">1</span>;       <span class="comment">//开启INT0中断</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P1 = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int0</span><span class="params">()</span> interrupt 0</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">0x0F</span>;     <span class="comment">//改变全局变量a的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们将$\overline{INT0}$口接GND，即可触发INT0中断，int0中断处理函数执行，a被重新赋值。然后中断返回，程序回到while循环内。</p>
</blockquote>
<h4 id="定时器0、1"><a href="#定时器0、1" class="headerlink" title="定时器0、1"></a>定时器0、1</h4><p>TMOD是工作方式寄存器共8位，低4位用于设置T0，高4位用于设置T1。单片机复位时清0。</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">门控制1</td>
<td align="center">模式</td>
<td align="center">方式</td>
<td align="center">方式</td>
<td align="center">门控制0</td>
<td align="center">模式</td>
<td align="center">方式</td>
<td align="center">方式</td>
</tr>
<tr>
<td align="center">GATE</td>
<td align="center">C/$\overline{T}$</td>
<td align="center">M1</td>
<td align="center">M0</td>
<td align="center">GATE</td>
<td align="center">C/$\overline{T}$</td>
<td align="center">M1</td>
<td align="center">M0</td>
</tr>
</tbody></table>
<ol>
<li>GATE为1则定时器仅受TCON中的TRx（x=0,1）控制；为0则受TRx和$\overline{INTx}$控制。</li>
<li>C/$\overline{T}$为1则是计数器模式；为0则是定时器模式。</li>
<li>M1和M0用于设置工作方式。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">M1</th>
<th align="center">M0</th>
<th align="left">工作方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="left">方式0：为13位定时器/计数器</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="left">方式1：为16位定时器/计数器</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="left">方式2：8位初值自动重装的8位定时器/计数器</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="left">方式3：仅适用于T0，分成两个8位计数器，T1停止计数</td>
</tr>
</tbody></table>
<p>TCON是控制寄存器，共8位，位地址为88~8FH，每一位可单独访问。单片机复位时清0。</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TF1</td>
<td align="center">TR1</td>
<td align="center">TF0</td>
<td align="center">TR0</td>
<td align="center">IE1</td>
<td align="center">IT1</td>
<td align="center">IE0</td>
<td align="center">IT0</td>
</tr>
<tr>
<td align="center">8FH</td>
<td align="center">8EH</td>
<td align="center">8DH</td>
<td align="center">8CH</td>
<td align="center">8BH</td>
<td align="center">8AH</td>
<td align="center">89H</td>
<td align="center">88H</td>
</tr>
</tbody></table>
<ol>
<li>TF1和TF0是定时器溢出标志位。当对应的定时器计满溢出时自动置1，并且申请中断。进入中断服务程序后，由硬件自动清0。</li>
<li>TR1和TR0是定时器控制位。为1时开启对应的定时器，否则关闭定时器。</li>
<li>IE1和IE0是外部中断标志位。当有外部中断时置1，否则置0。</li>
<li>IT1和IT0是外部中断触发方式位。为0则对应外部中断为电平触发；为1则下降沿触发。</li>
</ol>
<p>一、定时器方式1<br>采用16位定时器，由高8位和低8位组成，分别对应两个寄存器THx和TLx（x为定时器号）。单片机启动时，THx和TLx被初始化为0。之后，每过1个单片机周期，计数器加1。当计数值为65536（$2^{16}$）时寄存器满，定时器执行中断处理函数，并重置THx和TLx。</p>
<p>1个单片机周期等于12个振荡周期。当前开发板晶振频率为11.0592Hz，为了方便计算将其算作12，那么1个单片机周期就是12×$\frac{1}{12}$μs。因此，计数值即为微秒数，就是定时时间。</p>
<p>定时的方法：1个单片机周期1微秒，THx和TLx装满则需要65536微秒。我们可以给THx和TLx一个初值来控制触发中断处理的时间。比如，想要30毫秒中断一次，那么需要装入的初值为25536微秒。装入方法：THx=(65536-30000)/256，TLx=(65536-30000)%256。</p>
<p>例：动态显示数码管（6个数码管分别显示0~5）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line">sbit duan=P2^<span class="number">6</span>;</span><br><span class="line">sbit wei=P2^<span class="number">7</span>;</span><br><span class="line">uchar code du[]=&#123;</span><br><span class="line"><span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line">uchar code we[]=</span><br><span class="line">&#123;<span class="number">0xfe</span>,<span class="number">0xfd</span>,<span class="number">0xfb</span>,<span class="number">0xf7</span>,<span class="number">0xef</span>,<span class="number">0xdf</span>&#125;;</span><br><span class="line"></span><br><span class="line">uchar count = <span class="number">0</span>;	<span class="comment">//默认也会被初始化为0</span></span><br><span class="line">uchar dunum = <span class="number">0</span>, wenum = <span class="number">0</span>;</span><br><span class="line">display();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ET1 = <span class="number">1</span>;        <span class="comment">//T1定时器</span></span><br><span class="line">    TMOD = <span class="number">0x10</span>;    <span class="comment">//T1方式1</span></span><br><span class="line">    TH1 = (<span class="number">65536</span><span class="number">-500</span>)/<span class="number">256</span>;<span class="comment">//500微秒</span></span><br><span class="line">    TL1 = (<span class="number">65536</span><span class="number">-500</span>)%<span class="number">256</span>;</span><br><span class="line">    TR1 = <span class="number">1</span>;	</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)    <span class="comment">//死循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>)     <span class="comment">//两次定时器中断进入（1毫秒）</span></span><br><span class="line">        &#123;	</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dunum == <span class="number">6</span>)  <span class="comment">//数字轮换，0-5</span></span><br><span class="line">                dunum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(wenum == <span class="number">6</span>)  <span class="comment">//论选位，共6位</span></span><br><span class="line">                wenum = <span class="number">0</span>;</span><br><span class="line">            display();</span><br><span class="line">            dunum++;        <span class="comment">//下一个数字</span></span><br><span class="line">            wenum++;        <span class="comment">//下一位</span></span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time1</span><span class="params">()</span> interrupt 3</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH1=(<span class="number">65536</span><span class="number">-500</span>)/<span class="number">256</span>;    <span class="comment">//重新装入</span></span><br><span class="line">    TL1=(<span class="number">65536</span><span class="number">-500</span>)%<span class="number">256</span>;</span><br><span class="line">    count++;                <span class="comment">//计数器</span></span><br><span class="line">&#125;</span><br><span class="line">display()</span><br><span class="line">&#123;</span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = du[dunum];</span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = we[wenum];</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般不要在中断服务程序中写入过多的语句。如果语句过多，中断程序还未执行完，第二次中断就会来临。此次中断就会丢失，导致程序失败。</p>
</blockquote>
<p>二、定时器方式0<br>方式0的特点是13位，使用TLx的低5位和TH0的高8位。13位能表示$2^{13}$=8192个数字。装入方法：THx=(8192-N)/32，TLx=(8192-N)%32。</p>
<p>总的来说，这种方式就是比方式1触发的更快一点，使用思路与方式1一致。</p>
<p>三、定时器方式2<br>方式2的特点是8位，只使用TLx。我们可以给THx赋一个初值，当TLx计数溢出时，TFx置1并自动将THx中常数装入TLx，然后TLx重新开始计数。</p>
<p>总的来说，这种方式就是牺牲了位数，换来了装填初值的效率，减少了程序员的负担。</p>
<p>四、定时器方式3<br>方式3仅适用于T0，启动方式3相当于启动两个8位定时器，TH0和TL0分别用于计数。当TL0满，TF0置1，执行1号中断处理程序；当TH0满，TF1置1，执行3号中断处理程序。</p>
<p>由此看出，T0工作在方式3时，TF1被占用，此时不能使用T1定时器中断。</p>
<p>例：两个二极管分别闪烁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line">sbit led1 = P1^<span class="number">3</span>;</span><br><span class="line">sbit led2 = P1^<span class="number">4</span>;</span><br><span class="line">uint n1,n2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>; </span><br><span class="line">    ET1 = <span class="number">1</span>;</span><br><span class="line">    TMOD = <span class="number">0x03</span>;<span class="comment">//方式3</span></span><br><span class="line">    TH0 = <span class="number">6</span>;    <span class="comment">//初值</span></span><br><span class="line">    TL0 = <span class="number">6</span>;    <span class="comment">//初值</span></span><br><span class="line">    TR0 = <span class="number">1</span>;	</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt;= <span class="number">3686</span>)<span class="comment">//1秒</span></span><br><span class="line">        &#123;</span><br><span class="line">            n1 = <span class="number">0</span>;</span><br><span class="line">            led1 = ~led1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n2 &gt;= <span class="number">1843</span>)<span class="comment">//0.5秒</span></span><br><span class="line">        &#123;</span><br><span class="line">            n2 = <span class="number">0</span>;</span><br><span class="line">            led2 = ~led2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TL</span><span class="params">()</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TL0 = <span class="number">6</span>;</span><br><span class="line">    n1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TH</span><span class="params">()</span> interrupt 3</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = <span class="number">6</span>;</span><br><span class="line">    n2++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽说是T0的方式3，但实际上仍旧需要启动T1。这个方式3实质就是启动了两个8位定时器。</p>
</blockquote>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>计数器是对外来脉冲信号计数，52单片机有T0（P3.4）、T1（P3.5）和T2（P1.0）三个输入引脚，每当外部输入的脉冲发生负跳变时，计数器加1，直到加满溢出，向CPU申请中断。</p>
<p>单片机的晶振频率限制了所测计数脉冲的最高频率。一个机器周期包含6个状态周期共12个节拍。51单片机除乘法、除法指令是4周期指令外，其余都是单周期指令和双周期指令。</p>
<p>确认一次负跳变需要花两个机器周期，即24个振荡周期，因此外部输入计数脉冲的最高频率为振荡器频率的1/24。如果选用12MHZ频率晶振，则最高可输入500kHz的外部脉冲。</p>
<p>例：接受信号数码累加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line">sbit duan = P2^<span class="number">6</span>;</span><br><span class="line">sbit wei = P2^<span class="number">7</span>;</span><br><span class="line">uchar code table[]=&#123;</span><br><span class="line"><span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TMOD = <span class="number">0x05</span>;<span class="comment">//设置计数器0的工作方式1</span></span><br><span class="line">    TH0 = <span class="number">0</span>;</span><br><span class="line">    TL0 = <span class="number">0</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        read();        <span class="comment">//更新num</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">100</span>)<span class="comment">//只能显示到99</span></span><br><span class="line">        &#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            TH0 = <span class="number">0</span>;   <span class="comment">//num的值基于这两个计数器</span></span><br><span class="line">            TL0 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        display(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> n)</span>      <span class="comment">//显示两位数码管</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar d = n % <span class="number">10</span>;    <span class="comment">//得到个位</span></span><br><span class="line">    uchar t = n / <span class="number">10</span>;    <span class="comment">//得到十位</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[d];       <span class="comment">//显示个位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0xfd</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">5</span>);            <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[t];       <span class="comment">//显示十位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0xfe</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">5</span>);            <span class="comment">//延时</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;ms; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar th1,th2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        th1 = TH0;</span><br><span class="line">        num = TL0;</span><br><span class="line">        th2 = TH0;         <span class="comment">//再次读取TH0</span></span><br><span class="line">        <span class="keyword">if</span> (th1 == th2)    <span class="comment">//防止进位时读错</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num = th1*<span class="number">256</span>+num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个程序只打开了计数器，但未启动中断，也没写中断处理函数。测试这个程序的方法：用一根接地的导线连接P3.4，会发现数码管的跳动范围巨大，这都是因为抖动。</p>
</blockquote>
<h4 id="定时器-计数器2"><a href="#定时器-计数器2" class="headerlink" title="定时器/计数器2"></a>定时器/计数器2</h4><p>52单片机比51多了一个定时器T2，通过一个8位寄存器T2CON设置：</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TF2</td>
<td align="center">EXF2</td>
<td align="center">RCLK</td>
<td align="center">TCLK</td>
<td align="center">EXEN2</td>
<td align="center">TR2</td>
<td align="center">C/$\overline{T2}$</td>
<td align="center">CP/RL2</td>
</tr>
</tbody></table>
<ol>
<li>TF2是溢出标志位，溢出时置1，必须由软件清0。当RCLK=1或TCLK=1时，TF2不会置位。</li>
<li>EXF2是外部标志，必须用软件清0。</li>
<li>RCLK接收时钟标志，TCLK发送时钟标志。</li>
<li>EXEN2外部使能标志。</li>
<li>TR2为1时，定时器2启动，为0则关闭。</li>
<li>C/$\overline{T2}$为1时，则作为外部事件计数器，为0则为内部定时器。</li>
<li>CP/RL2捕获/重装标志。</li>
</ol>
<p>定时器2三种工作模式：</p>
<table>
<thead>
<tr>
<th align="center">RCLK+TCLK</th>
<th align="center">CP/RL2</th>
<th align="center">TR2</th>
<th align="left">模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="left">16位自动重装</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="left">16位捕获</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">x</td>
<td align="center">1</td>
<td align="left">波特率发生器</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">0</td>
<td align="left">关闭</td>
</tr>
</tbody></table>
<p>定时器2模式控制寄存器T2MOD：</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">T2OE</td>
<td align="center">DCEN</td>
</tr>
</tbody></table>
<ol>
<li>T2OE定时器2输出使能位。</li>
<li>DCEN向下计数使能位。</li>
</ol>
<h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ol>
<li>定时器0、1的方式1最有用，方式2自动装填很实用，方式0和方式3没什么意义。</li>
<li>定时器2的使用不同于0和1，这个设计很不自然。</li>
<li>计数器的使用方式类似于外部中断，只不过计数器接受的是一组信号。</li>
</ol>
]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机二 I/O端口</title>
    <url>/2011/09/28/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E4%BA%8C%20IO%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>STC89C52输入输出端口共有4个，分别为P1~P4，每个端口8位，可用于接收或发送信号。信号只有两种：高电平和低电平，反映到编程层面就是0和1。</p>
<a id="more"></a>

<h4 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h4><p>流水灯是最基本的I/O端口控制实验。上一节的示例程序就是通过对P1进行赋值来控制P1.0~P1.7管脚的电平，使得对应连接的二极管亮灯。</p>
<p>P1共有8个管脚，一个两位十六进制数即可表示，例如0x77。我们也可以通过sbit P1_6 = P1^6;的方式独立控制P1的每一位。如此，我们的设计就很清楚了——用八个发光二极管连接到P1的每个管脚，如下：</p>
<p><img src="https://i.loli.net/2020/08/20/qsJlpHiBvtyr6Su.png" alt="1二极管.PNG"></p>
<p>上图中在单片机和二极管之间连接了一个锁存器74HC573。这是个数字芯片，真值表如下：</p>
<p><img src="https://i.loli.net/2020/08/20/lpameo9bjZ4O1Df.png" alt="2锁存器.PNG"></p>
<p>这个表说明了它的使用方式：</p>
<ol>
<li>$\overline{OE}$为H，输出必为高阻态，类似于绝缘体。</li>
<li>$\overline{OE}$为L，LE为H，输入什么，输出什么，类似于导线。</li>
<li>$\overline{OE}$为L，LE为L，无论输入什么，输出都是上一次的输入，这就是所谓的锁存。</li>
</ol>
<p>在这个实验，我们对锁存器的设置是基于2，就是把它当作一条导线，没有使用锁存功能。连接它的原因是开发板复用了P1口，使用它起到隔离功能的作用。</p>
<p>除此之外还连接了一个排阻用于分压。这里假设发光二极管是没有电阻的，要想保证二极管不烧毁，需要控制电流在二极管额定电流（3.5mA）以内。单片机每个管脚5v，通过欧姆定律，得到每个二极管需串联电阻大小为5÷0.0035≈1430。</p>
<blockquote>
<p>一般情况下都会假设电阻之外的器件是无电阻的。</p>
</blockquote>
<p>例：静态示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P1 = <span class="number">0x55</span>;  <span class="comment">//01010101</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单片机只要上电、连接晶振就会不停的获取下一条指令。为了严格控制单片机的执行，清楚的知道单片机到底运行在哪条指令之上，故而用一个死循环来结束程序。</p>
</blockquote>
<p>如果想要让灯动起来，需要不停的设置P1的8个管脚，这让我们想到C语言的循环。</p>
<p>例：动态示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P1 = <span class="number">0x55</span>;              <span class="comment">//01010101</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)  <span class="comment">//延时，控制转换的频率</span></span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">100</span>; j++);</span><br><span class="line">        P1 = <span class="number">0xAA</span>;              <span class="comment">//10101010</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)  <span class="comment">//不能在for内部定义i，j</span></span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">100</span>; j++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中间的for循环等同于空转，这叫延时，翻译成汇编语言就是一串nop（1个CPU周期）。使用两层for循环是为了精确控制延时的长短，因为两层for循环执行的次数是乘法关系，方便粗调和精调。</p>
</blockquote>
<p>例：流水灯</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d = <span class="number">0xFE</span>; <span class="comment">//管脚为0，灯亮</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P1 = d;</span><br><span class="line">        delay();            <span class="comment">//循环左移1位，相对的有d=_cror_(d,1);循环右移</span></span><br><span class="line">        d = _crol_(d,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1150</span>; i++)  <span class="comment">//不能在for内部定义i，j</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">100</span>; j++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接使用&gt;&gt;和&lt;&lt;运算符，不能实现流水灯。因为它们只是右移和左移，被移出的位进入了CY，缺失的位补0。</p>
</blockquote>
<p>相对准确的计算延时方法：进入调试模式（点击工具栏中“放大镜中有个d”的图标），关注左侧sec（秒）。运用单步执行，求执行“延时循环”前后的sec值之差，既是延时时长。</p>
<p><img src="https://i.loli.net/2020/08/20/PO3Zy5pJFaXvMxk.png" alt="3计算延时.PNG"></p>
<blockquote>
<p>一些调试窗口可以在菜单view中调出，点击菜单Peripherals-&gt;I/O-Ports可看到I/O口信息。</p>
</blockquote>
<h4 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h4><p><img src="https://i.loli.net/2020/08/20/ESxg28HpURBrc6i.png" alt="4蜂鸣器.PNG"></p>
<p>如上图，蜂鸣器一脚接Vcc，另一脚接三极管。三极管在这里的作用是开关，当接受P2_3为低电平时，蜂鸣器导通。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit beep = P2^<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)    <span class="comment">//响一秒，停一秒</span></span><br><span class="line">    &#123;</span><br><span class="line">        beep = <span class="number">0</span>;<span class="comment">//响铃</span></span><br><span class="line">        delay();</span><br><span class="line">        beep = <span class="number">1</span>;<span class="comment">//停止</span></span><br><span class="line">        delay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delay代码与“流水灯”一致</span></span><br></pre></td></tr></table></figure>
<h4 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h4><p>这里讨论的都是8段数码管，正好对应一个I/O端口的8个管脚。数码管还有一个公共端，须接地的是共阴极数码管，须接电压源的是共阳极数码管。开发板上的数码管都是共阴极的。</p>
<p>这里用一个锁存器的输出端连接所有数码管的8段，称为段选。用另一个锁存器的输出端连接所有数码管的位选。所谓位选，就是单个数码管的共阴极。两个锁存器的输入端连接单片机的P0口。</p>
<p><img src="https://i.loli.net/2020/08/20/cCa5iV8Rx43uken.png" alt="5数码管连线.PNG"></p>
<p>这种复用I/O端口的接法，节约了硬件，增加了软件负担。控制这个电路的基本思想是，在每次设置PO口进行段选或位选之后，都应进行锁存，然后再进行下一步段选或位选。以此来保证前后两次的选择不会相互干扰。</p>
<p>这里就需要利用到锁存器的第三种使用方式。</p>
<p>例：静态示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit duan = P2^<span class="number">6</span>;</span><br><span class="line">sbit wei = P2^<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    duan = <span class="number">1</span>;   <span class="comment">//保持段锁存器畅通</span></span><br><span class="line">    P0 = <span class="number">0x66</span>;  <span class="comment">//显示4</span></span><br><span class="line">    duan = <span class="number">0</span>;   <span class="comment">//锁存</span></span><br><span class="line">    wei = <span class="number">1</span>;    <span class="comment">//保持位锁存器畅通</span></span><br><span class="line">    P0 = <span class="number">0xfe</span>;  <span class="comment">//选中第1位</span></span><br><span class="line">    wei = <span class="number">0</span>;    <span class="comment">//锁存</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果先进行位选，初始可能先显示乱码，然后才正常显示。这是因为默认段选是打开的，位选对P0口的设置，影响了数码管的显示。</p>
</blockquote>
<p>例：动态示例（单个数码管）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit duan = P2^<span class="number">6</span>;   <span class="comment">//段选</span></span><br><span class="line">sbit wei = P2^<span class="number">7</span>;    <span class="comment">//位选</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line">uchar code table[] = &#123;  <span class="comment">//编码0-15</span></span><br><span class="line"><span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)       <span class="comment">//循环显示0-15</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            duan = <span class="number">1</span>;        <span class="comment">//保持段锁存器畅通</span></span><br><span class="line">            P0 = table[i];   <span class="comment">//显示数字</span></span><br><span class="line">            duan = <span class="number">0</span>;        <span class="comment">//锁存</span></span><br><span class="line">            wei = <span class="number">1</span>;         <span class="comment">//保持位锁存器畅通</span></span><br><span class="line">            P0 = <span class="number">0xfe</span>;       <span class="comment">//选中第1位，可选中多位</span></span><br><span class="line">            wei = <span class="number">0</span>;         <span class="comment">//锁存</span></span><br><span class="line">            delay();         <span class="comment">//延时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delay代码与“流水灯”一致</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>凡是动态显示，都要使用延时。</p>
</blockquote>
<h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>流水灯和数码管的操作属于I/O输出，而键盘操作属于I/O输入。最简单的连接按键方式如下：</p>
<p><img src="https://i.loli.net/2020/08/20/FWgsSqHh9xmMjN6.png" alt="6独立键盘.png"></p>
<p>如图，按键的一端接地，另一端连接某I/O管脚。当按键被按下时，会将对应I/O管脚置为0（默认启动时为1），松手后此管脚重新置为1。</p>
<p>因此，我们可以编程对此管脚进行检测，并以此进行某些动作。特别需要注意的是<strong>抖动</strong>。一个按键被按下和释放的瞬间会有抖动现象，输入的电压呈锯齿状，程序在判断时会出错。</p>
<p>抖动时间的长短和按键的机械特性有关，一般为5~10ms。最好通过硬件解决抖动，如果要求不是很高，通过编程延时略过抖动也能解决问题。要注意，延时时间不宜过长，因为人按下按键并释放的时间很短，一般稳定闭合时间在20ms左右。</p>
<p>例：数码管显示20以内加减</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line">uchar code table[] = &#123;  <span class="comment">//编码0-15</span></span><br><span class="line"><span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line">sbit key1 = P3^<span class="number">4</span>;   <span class="comment">//按键1</span></span><br><span class="line">sbit key2 = P3^<span class="number">5</span>;   <span class="comment">//按键2</span></span><br><span class="line">sbit duan = P2^<span class="number">6</span>;   <span class="comment">//段选</span></span><br><span class="line">sbit wei = P2^<span class="number">7</span>;    <span class="comment">//位选</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uchar)</span></span>;  <span class="comment">//延时ms</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyscan</span><span class="params">()</span></span>;     <span class="comment">//键盘扫描</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//数码管显示</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;        <span class="comment">//必须是有符号int</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        keyscan();</span><br><span class="line">        display(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uchar ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;ms; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyscan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key1 == <span class="number">0</span>)   <span class="comment">//加法</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">10</span>);   <span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (key1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">20</span>)</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!key1);<span class="comment">//按键释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key2 == <span class="number">0</span>)   <span class="comment">//减法</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (key2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num--;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>)<span class="comment">//如果是uint则无法判断负数</span></span><br><span class="line">                num = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">while</span> (!key2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> n)</span>      <span class="comment">//显示两个数码管</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar d = n % <span class="number">10</span>;    <span class="comment">//得到个位</span></span><br><span class="line">    uchar t = n / <span class="number">10</span>;    <span class="comment">//得到十位</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[d];       <span class="comment">//显示个位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0xfd</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">5</span>);            <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[t];       <span class="comment">//显示十位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0xfe</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">5</span>);            <span class="comment">//延时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>display先后显示了两个数码管，因为在main中是循环显示，速度非常快形成视觉暂留，故而让人觉得是两位同时显示。</p>
<p>keyscan消除抖动的方式是，检测到有按键按下后延时10ms，再次进行检测。每个按键处理的最后一条语句应是按键释放检测。</p>
<p>每个<strong>独立按键</strong>独自占用一个I/O管脚，另一端接地，测试起来比较容易。如果是多个按键，通常都是采用复用的方法，组成<strong>矩阵键盘</strong>。矩阵键盘的每个按键两端均接I/O管脚，比如4*4键盘：</p>
<p><img src="https://i.loli.net/2020/08/20/8KE2qDmi5rwTtxg.png" alt="7矩阵键盘.png"></p>
<p>如图，P3.0~P3.3连接每行按键的左端，P3.4~P3.7连接每列按键的右端。测试方法是以行为单位，先将第一行设置为0，其余行默认为1，然后测试P3.4~P3.7的值（默认为1），如果某个按键按下，对应的管脚（P3.4~P3.7）会置0。如此一行按键的检测完毕。以此类推，即可完成4行的检测。当然，以列为单位，扫描连接行的管脚也能完成所有按键的检测。</p>
<p>上述检测方法，其实仍旧是独立键盘的检测思路，只不过硬件接地变成了软设置行I/O管脚为0，然后测试后4位管脚的值，以判断一行的按键情况。这个过程重复4次，完成对每行的测试。</p>
<p>例：矩阵键盘显示0~F</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit duan = P2^<span class="number">6</span>;   <span class="comment">//段选</span></span><br><span class="line">sbit wei = P2^<span class="number">7</span>;    <span class="comment">//位选</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line">uchar code table[] = &#123;  <span class="comment">//编码0-15</span></span><br><span class="line"><span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uchar num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixScan</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">uchar <span class="title">Onkey</span><span class="params">(<span class="keyword">int</span> line,uchar temp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0x0</span>;    <span class="comment">//初始什么都不显示</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wei = <span class="number">1</span>;     <span class="comment">//直接选择第二位</span></span><br><span class="line">    P0 = <span class="number">0xfd</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MatrixScan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uchar num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[num];</span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uchar ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;ms; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixScan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar temp,key;</span><br><span class="line"></span><br><span class="line">    P3 = <span class="number">0xfe</span>;            <span class="comment">//第一行置0，低4位为1110</span></span><br><span class="line">    temp = P3;</span><br><span class="line">    temp = temp &amp; <span class="number">0xf0</span>;   <span class="comment">//消去第4位</span></span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0xf0</span>)     <span class="comment">//第一行有按键按下（高4位有变化）</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">10</span>);        <span class="comment">//延时消抖</span></span><br><span class="line">        temp = P3;        <span class="comment">//再次获取高4位</span></span><br><span class="line">        temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="number">0xf0</span>) <span class="comment">//证明确实有按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = Onkey(<span class="number">1</span>,temp);<span class="comment">//得到key</span></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0xf0</span>)<span class="comment">//释放检测</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = P3;      <span class="comment">//反复获取P3</span></span><br><span class="line">                temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            display(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P3 = <span class="number">0xfd</span>;            <span class="comment">//第二行置0，低4位为1101</span></span><br><span class="line">    temp = P3;</span><br><span class="line">    temp = temp &amp; <span class="number">0xf0</span>;   <span class="comment">//消去第4位</span></span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0xf0</span>)     <span class="comment">//第二行有按键按下（高4位有变化）</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">10</span>);        <span class="comment">//延时消抖</span></span><br><span class="line">        temp = P3;        <span class="comment">//再次获取高4位</span></span><br><span class="line">        temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="number">0xf0</span>) <span class="comment">//证明确实有按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = Onkey(<span class="number">2</span>,temp);<span class="comment">//得到key</span></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0xf0</span>)<span class="comment">//释放检测</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = P3;      <span class="comment">//反复获取P3</span></span><br><span class="line">                temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            display(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P3 = <span class="number">0xfb</span>;            <span class="comment">//第三行置0，低4位为1011</span></span><br><span class="line">    temp = P3;</span><br><span class="line">    temp = temp &amp; <span class="number">0xf0</span>;   <span class="comment">//消去第4位</span></span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0xf0</span>)     <span class="comment">//第三行有按键按下（高4位有变化）</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">10</span>);        <span class="comment">//延时消抖</span></span><br><span class="line">        temp = P3;        <span class="comment">//再次获取高4位</span></span><br><span class="line">        temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="number">0xf0</span>) <span class="comment">//证明确实有按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = Onkey(<span class="number">3</span>,temp);<span class="comment">//得到key</span></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0xf0</span>)<span class="comment">//释放检测</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = P3;      <span class="comment">//反复获取P3</span></span><br><span class="line">                temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            display(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P3 = <span class="number">0xf7</span>;            <span class="comment">//第四行置0，低4位为0111</span></span><br><span class="line">    temp = P3;</span><br><span class="line">    temp = temp &amp; <span class="number">0xf0</span>;   <span class="comment">//消去第4位</span></span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="number">0xf0</span>)     <span class="comment">//第四行有按键按下（高4位有变化）</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">10</span>);        <span class="comment">//延时消抖</span></span><br><span class="line">        temp = P3;        <span class="comment">//再次获取高4位</span></span><br><span class="line">        temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="number">0xf0</span>) <span class="comment">//证明确实有按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = Onkey(<span class="number">4</span>,temp);<span class="comment">//得到key</span></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0xf0</span>)<span class="comment">//释放检测</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = P3;      <span class="comment">//反复获取P3</span></span><br><span class="line">                temp = temp &amp; <span class="number">0xf0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            display(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uchar <span class="title">Onkey</span><span class="params">(<span class="keyword">int</span> line,uchar temp)</span><span class="comment">//根据line，得到key</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;    <span class="comment">//基数</span></span><br><span class="line">    uchar key;</span><br><span class="line">    <span class="keyword">switch</span> (line)  <span class="comment">//1、2、3、4</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:        <span class="comment">//第一行从0按键开始</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:        <span class="comment">//第二行从4按键开始</span></span><br><span class="line">        i = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        i = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        i = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (temp)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xe0</span>:        <span class="comment">//当前行第一个按钮被按下</span></span><br><span class="line">        key = i + <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xd0</span>:        <span class="comment">//当前行第二个按钮被按下</span></span><br><span class="line">        key = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xb0</span>:</span><br><span class="line">        key = i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x70</span>:</span><br><span class="line">        key = i + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ol>
<li><p>单片机的I/O端口的作用就是信号接收/发送。在编程层面上，其处理的数据只有0和1。这种可灵活控制I/O管脚的特性使得单片机能编程模拟众多数字芯片。</p>
</li>
<li><p>所有设备的输入输出在实际编程时，都是有先后顺序的。但由于单片机执行速度非常快，程序主体又是死循环执行，故而让人觉得是在同时执行。</p>
</li>
<li><p>蜂鸣器和二极管是很好的调试工具，我们可以搭建并编写单一功能的代码，使用它们测试结果。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机六 1602液晶屏</title>
    <url>/2011/10/08/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%AD%201602%E6%B6%B2%E6%99%B6%E5%B1%8F/</url>
    <content><![CDATA[<p>像液晶屏这种集成电路，通常会被当作一个整体应用到实际项目中。掌握1602液晶屏的使用方法，仍旧像使用芯片那样，学习其PDF说明书，掌握其典型连接方法和操作方法。</p>
<a id="more"></a>

<h4 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h4><p>1602液晶屏为5V电压驱动，带背光，可显示两行，每行16个字符，不能显示汉字，内置128个字符的ASCII字库，只有并行接口，无串行接口。其接口说明如下：</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">符号</th>
<th align="left">说明</th>
<th align="center">编号</th>
<th align="center">符号</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">$V_{SS}$</td>
<td align="left">电源地</td>
<td align="center">9</td>
<td align="center">D2</td>
<td align="left">数据口</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">$V_{DD}$</td>
<td align="left">电源正极</td>
<td align="center">10</td>
<td align="center">D3</td>
<td align="left">数据口</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">VO</td>
<td align="left">液晶显示对比度调节端</td>
<td align="center">11</td>
<td align="center">D4</td>
<td align="left">数据口</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">RS</td>
<td align="left">数据/命令选择端（H/L）</td>
<td align="center">12</td>
<td align="center">D5</td>
<td align="left">数据口</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">$R/\overline{W}$</td>
<td align="left">读写选择端（H/L）</td>
<td align="center">13</td>
<td align="center">D6</td>
<td align="left">数据口</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">E</td>
<td align="left">使能信号</td>
<td align="center">14</td>
<td align="center">D7</td>
<td align="left">数据口</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">D0</td>
<td align="left">数据口</td>
<td align="center">15</td>
<td align="center">BLA</td>
<td align="left">背光电源正极</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">D1</td>
<td align="left">数据口</td>
<td align="center">16</td>
<td align="center">BLK</td>
<td align="left">背光电源负极</td>
</tr>
</tbody></table>
<p>液晶屏的编号是按照行列数命名的，比如1602就是每行16个字符，共2行；12232就是每行122列，共32行。液晶的好处是功耗低、显示操作简单，缺点是使用温度范围窄。</p>
<h4 id="单片机与1602液晶屏的连接"><a href="#单片机与1602液晶屏的连接" class="headerlink" title="单片机与1602液晶屏的连接"></a>单片机与1602液晶屏的连接</h4><p>按照上述接口的特性，连接单片机如下：</p>
<p><img src="https://i.loli.net/2020/09/11/JyYRStaFZI319o7.png" alt="1602液晶屏.PNG"></p>
<p>液晶屏第4端口RS连接P3.5用于控制写命令/写数据。第6端口E连接P3.4用于控制命令/数据使能。第5端口$R/\overline{W}$连接P3.6用于控制读/写，由于液晶屏主要用于显示，一般只写不读，因此接GND。</p>
<p>另外，第3端口连接一个10k电位器来调节对比度。第15端口串接一个10欧电阻用于限流，以防止5V电压烧坏背光灯。</p>
<h4 id="编程操作"><a href="#编程操作" class="headerlink" title="编程操作"></a>编程操作</h4><p>1602液晶屏的操作时序如下：<br>读状态：RS=L，$R/\overline{W}$=H，E=H<br>读数据：RS=H，$R/\overline{W}$=H，E=H<br>写指令：RS=L，$R/\overline{W}$=L，D0~D7=指令码，E=高脉冲<br>写数据：RS=H，$R/\overline{W}$=L，D0~D7=数据，E=高脉冲</p>
<blockquote>
<p>大多数液晶屏的响应都是纳秒级的，单片机操作最小单位为微秒级，因此可以不做延时或做简短延时。</p>
</blockquote>
<p>1602液晶屏可接受的指令：<br>一、写数据指令：第一行写入指令0x80，第二行写入指令0xC0。<br>屏幕内置80B的RAM缓冲区，用于存放显示的数据。00~0F、40~4F地址中的任一处写入数据后，液晶都可立即显示；当写入10~27、50~67地址处时，只能通过移屏指令将它们移入可显示区域。</p>
<p>二、显示模式设置指令0x38，设置为16×2显示，5×7点阵，8位数据接口。</p>
<p>三、显示开关及光标</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00001DCB</td>
<td align="left">D=1开显示，D=0关显示；C=1显示光标，C=0不显示光标；B=1光标闪烁，B=0光标不显示</td>
</tr>
<tr>
<td align="center">000001NS</td>
<td align="left">N=1读写1个字符后指针加1，光标加1；N=0读写1个字符后指针减1，光标减1；S=1写1个字符时，整屏左移（N=1）或右移（N=0）；S=0写1个字符时整屏不移动</td>
</tr>
<tr>
<td align="center">00010000</td>
<td align="left">光标左移</td>
</tr>
<tr>
<td align="center">00010100</td>
<td align="left">光标右移</td>
</tr>
<tr>
<td align="center">00011000</td>
<td align="left">整屏左移，同时光标跟随移动</td>
</tr>
<tr>
<td align="center">00011100</td>
<td align="left">整屏右移，同时光标跟随移动</td>
</tr>
</tbody></table>
<p>例：滚屏显示文本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line">uchar code Line0[] = <span class="string">&quot;First line.&quot;</span>;</span><br><span class="line">uchar code Line1[] = <span class="string">&quot;Second line.&quot;</span>;</span><br><span class="line">sbit e = P3^<span class="number">4</span>;      <span class="comment">//使能</span></span><br><span class="line">sbit rs = P3^<span class="number">5</span>;     <span class="comment">//写命令/写数据</span></span><br><span class="line">sbit du = P2^<span class="number">6</span>;     <span class="comment">//为了关闭数码管</span></span><br><span class="line">sbit we = P2^<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>,uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    init();</span><br><span class="line">    write(<span class="string">&#x27;c&#x27;</span>,<span class="number">0x80</span>+<span class="number">0x10</span>);    <span class="comment">//在第一行写入</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">11</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="string">&#x27;s&#x27;</span>,Line0[i]); <span class="comment">//写数据</span></span><br><span class="line">        delay(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(<span class="string">&#x27;c&#x27;</span>,<span class="number">0x80</span>+<span class="number">0x50</span>);    <span class="comment">//在第二行写入</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="string">&#x27;s&#x27;</span>,Line1[i]);</span><br><span class="line">        delay(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)    <span class="comment">//整屏左移16个地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="string">&#x27;c&#x27;</span>,<span class="number">0x18</span>);</span><br><span class="line">        delay(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    du = <span class="number">0</span>; <span class="comment">//锁定数码管关闭状态</span></span><br><span class="line">    we = <span class="number">0</span>;</span><br><span class="line">    e = <span class="number">0</span>;</span><br><span class="line">    write(<span class="string">&#x27;c&#x27;</span>,<span class="number">0x38</span>);    <span class="comment">//16*2显示</span></span><br><span class="line">    write(<span class="string">&#x27;c&#x27;</span>,<span class="number">0x0c</span>);    <span class="comment">//设置开显示，不显示光标</span></span><br><span class="line">    write(<span class="string">&#x27;c&#x27;</span>,<span class="number">0x06</span>);    <span class="comment">//写一个字符后地址指针加1</span></span><br><span class="line">    write(<span class="string">&#x27;c&#x27;</span>,<span class="number">0x01</span>);    <span class="comment">//显示清0，数据指针清0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> ch,uchar x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">        rs = <span class="number">0</span>;     <span class="comment">//RS=L，写命令</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rs = <span class="number">1</span>;     <span class="comment">//RS=H，写数据</span></span><br><span class="line">    P0 = x;</span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    e = <span class="number">1</span>;          <span class="comment">//e高脉冲</span></span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    e = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uchar n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>P0复用于数码管，为了防止数码管乱显示，锁定它们在关闭状态。</p>
</blockquote>
]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>围城震荡波和红蜘蛛</title>
    <url>/2019/06/22/%E5%9B%B4%E5%9F%8E%E9%9C%87%E8%8D%A1%E6%B3%A2%E5%92%8C%E7%BA%A2%E8%9C%98%E8%9B%9B/</url>
    <content><![CDATA[<p>围城玩具总的来说，给人一种廉价的塑料感，每个级别的人物都要比传统级别小。正面颜值还算可以，虽说是赛博坦形态，但样子还是照着G1做的。值得一提的是表面刻线，算是围城变形金刚的创新。至于背面偷胶、手臂没有盖板，放在今天就是官方标配，大家都不觉得意外。看网上介绍，我觉得还不错的只有震荡波、红蜘蛛、探长、横炮。</p>
<a id="more"></a>

<p>最先买的是震荡波，这是我最喜欢的一个，将其与MP29震荡波放在一起有过之而无不及，尤其是那只独眼，放在光下就像有灯效一样。整个玩具由本体和配件组成，这应该是官方的一个策略（V级别的尺寸加上配件当L级的卖），好在这个配件本身可玩性不错，人形和伪装形态都能无违和感的用上。</p>
<p>围城震荡波的伪装形态不是一把手枪，而是一艘宇宙战舰，这一点我很喜欢。至于可动性，该有的都有，而且腿部应用了齿轮关节。</p>
<p>对于震荡波，我没有什么幼年印象，只觉得这个名字不陌生而已，过去与胡同里的小伙伴们从来没谈论过它。</p>
<p><img src="https://i.loli.net/2021/11/06/zfhqKxRXIuCgJPV.png" alt="1震荡波.png"></p>
<p>围城红蜘蛛制作精良，至少没有偷胶，人形态还原G1动画，全身刻线细节是亮点，变形为一架三角形飞机，感觉有点差强人意。</p>
<p>印象里，红蜘蛛是个话痨，遇见点事就大呼小叫，本来挺讨厌它的，但是看它锲而不舍的造反（小时候真不喜欢威震天），渐渐的就越来越喜欢了。还没上小学的我，那时就认为靠博派那帮人根本解决不了威震天，就把希望寄托于红蜘蛛了。</p>
<p><img src="https://i.loli.net/2021/11/06/IRX7NqKZMhUCFnj.png" alt="2红蜘蛛.png"></p>
<p>玩过官方的玩具后，才明白什么才是一个好的变形金刚玩具。如果一个变形金刚，你碰都懒得碰一下，只是放在柜子里摆着，那么它能算的上一个好的变形金刚玩具吗？关于这一点是仁者见仁智者见智。即便如此，变形体验（把玩手感）也是玩具设计好坏的一个重要考量。</p>
<p>另外，官方做变形金刚，一做就会是一个系列，而且同一个角色会有持续的新版本，这点是第三方比不了的。</p>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Transformers</category>
      </categories>
      <tags>
        <tag>Transformers</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机五 模数转换</title>
    <url>/2011/10/06/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E4%BA%94%20%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>数字量与模拟量的转换，其实就是一个描点过程。描点越多，表示越精确，但不可能完全一致，因为模拟量是连续的，需要无穷多的数字量。比如，用8位二进制数表示每个点，那么可以有$2^8$个点来表示模拟图像。</p>
<p>当前的处理器都是数字芯片，无法直接接收/发送模拟信号，所以在需要处理模拟信号的情况下，必然需要转换电路来完成设计。下面介绍两个芯片，分别说明两个方向上的转换。</p>
<a id="more"></a>

<h4 id="A-D"><a href="#A-D" class="headerlink" title="A/D"></a>A/D</h4><p>为了正确无误地采集模拟信号，必须满足$f_{s}\ge 2f_{imax}$。$f_{s}$为采用频率，$f_{imax}$为模拟信号最高频率分量的频率。上述采样定理只是规定了转换频率的下限，采样频率通常取$f_{s}$ = (3~5)$f_{imax}$能够满足要求。</p>
<p>A/D每次把参考电压转换为数字量都需要一定的时间，这个过程远比D/A要慢。因此，一般以精度和速度两个方面来考量A/D芯片的性能。</p>
<p>ADC0804</p>
<p><img src="https://i.loli.net/2020/08/30/lq1K2Xpk3dbN4Iy.png" alt="1ADC0805.PNG"></p>
<ol>
<li>$V_{IN}$(+)和$V_{IN}$(-)模拟信号输入端，可接受单极性、双极性和差模输入信号。</li>
<li>DB7~DB0具有三态特性数字信号输出口。</li>
<li>AGND模拟接地，DGND数字接地。</li>
<li>CLK时钟信号输入。CLKR内部时钟发生器的外接电阻端，与CLK连接可由芯片自身产生时钟，频率为1/(1.1RC)。</li>
<li>$\overline{CS}$片选信号输入，低电平有效，表明启动芯片，开始工作。</li>
<li>$\overline{WR}$写信号输入，$\overline{RD}读信号输入。</li>
<li>$\overline{INTR}$在A/D转换结束后，置低电平表示转换完成。</li>
<li>$V_{REF}$/2参考电平输入，决定量化单位，取2.5V。</li>
<li>Vcc芯片电源5V。</li>
</ol>
<p>从直觉上看，$V_{IN}$(+)和$V_{IN}$(-)用来从外界接收模拟量，DB口用来输出转换后的数字量，其他端口用于控制。开发板的连接方法如下：</p>
<p><img src="https://i.loli.net/2020/08/30/irV2pPM1vyR4oEa.png" alt="2AD数模转换.PNG"></p>
<p>如图，单片机P1口接DB0~DB7，P0.7管脚通过一个锁存器连接$\overline{CS}$，P3.6管脚接$\overline{WR}$，P3.7管脚接$\overline{RD}$。硬件连接有了，接着就要考虑编程操作，这需要知道这种连接模式的时序。</p>
<p><img src="https://i.loli.net/2020/08/30/M75AapYjHyXCZG2.png" alt="3ADC0805时序.PNG"></p>
<p>如图，先给$\overline{CS}$赋予低电平，然后给$\overline{WR}$赋予一个低脉冲，一段时间后对应数字量才会在输出口稳定住。在输出口读取数据需要给$\overline{RD}$赋予一个低脉冲。在这个脉冲底部，我们可以通过读取P1口来获得数字量。</p>
<p>例：用数码管显示电压</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line">sbit cs = P0^<span class="number">7</span>;     <span class="comment">//CS</span></span><br><span class="line">sbit wr = P3^<span class="number">6</span>;     <span class="comment">//WR</span></span><br><span class="line">sbit rd = P3^<span class="number">7</span>;     <span class="comment">//RD</span></span><br><span class="line">sbit duan = P2^<span class="number">6</span>;   <span class="comment">//段选</span></span><br><span class="line">sbit wei = P2^<span class="number">7</span>;    <span class="comment">//位选</span></span><br><span class="line">uchar code table[] = &#123;  <span class="comment">//编码0-15</span></span><br><span class="line"><span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uint)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint n = <span class="number">0</span>;</span><br><span class="line">    uint i = <span class="number">0</span>;</span><br><span class="line">    cs = <span class="number">0</span>;         <span class="comment">//始终保持为0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wr = <span class="number">1</span>;     <span class="comment">//写入</span></span><br><span class="line">        _nop_();    <span class="comment">//延时</span></span><br><span class="line">        wr = <span class="number">0</span>;</span><br><span class="line">        _nop_();</span><br><span class="line">        wr = <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">20</span>);  <span class="comment">//等待数据转换</span></span><br><span class="line"></span><br><span class="line">        rd = <span class="number">1</span>;     <span class="comment">//读取</span></span><br><span class="line">        _nop_();    </span><br><span class="line">        rd = <span class="number">0</span>;</span><br><span class="line">        _nop_();</span><br><span class="line">        n = P1;     <span class="comment">//得到数字量</span></span><br><span class="line">        rd = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//延长显示时间</span></span><br><span class="line">            display(n);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;ms; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uint n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar d = n % <span class="number">10</span>;        <span class="comment">//得到个位</span></span><br><span class="line">    uchar t = (n / <span class="number">10</span>) / <span class="number">10</span>; <span class="comment">//得到十位</span></span><br><span class="line">    uchar h = n / <span class="number">100</span>;       <span class="comment">//得到百位</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[d];        <span class="comment">//显示个位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0x7b</span>;            <span class="comment">//为了CS置为0，所以为7</span></span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">5</span>);             <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[t];        <span class="comment">//显示十位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0x7d</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">5</span>);             <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[h];        <span class="comment">//显示百位</span></span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0x7e</span>;</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">5</span>);             <span class="comment">//延时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述程序未使用中断触发方式。</p>
</blockquote>
<h4 id="D-A"><a href="#D-A" class="headerlink" title="D/A"></a>D/A</h4><p>每个数字量就是一串二进制码，其中每一位都有一定的权。为了将数字量转换为模拟量，必须将每一位按其权的大小转换成相应的模拟量，然后将这些模拟量相加，即可得到与数字量成正比的总模拟量。</p>
<p>DAC0832</p>
<p><img src="https://i.loli.net/2020/08/30/jQBCcoGS2q3EK7r.png" alt="4DAC0832.PNG"></p>
<ol>
<li>$\overline{CS}$片选信号输入端</li>
<li>$\overline{WR1}$输入寄存器写选通，当CS为0，ILE为1，WR1为0时，DI0~DI7状态被锁存到输入寄存器。</li>
<li>$\overline{WR2}$为DAC寄存器写选通，当XEFR为0，WR2为0时，输入寄存器的状态传到DAC寄存器中。</li>
<li>DI0~DI7数据输入端，TTL电平，有效时间大于90ns。</li>
<li>$V_{REF}$基准电压输入端，电压范围为-10V~+10V。</li>
<li>$R_{fb}$反馈电阻端</li>
<li>$I_{out1}$电流输出端，输入全为1时，其电流最大。$I_{out2}$其值与$I_{out1}$端电流之和为一常数。</li>
<li>$\overline{XFER}$数据传输控制信号输入端。ILE数据锁存允许信号输入端，高电平有效。</li>
<li>Vcc电源+5V~+15V，GND模拟地和数字地。</li>
</ol>
<p>从直觉上看，DI口用来接收8位二进制数输入，$I_{out1}$和$I_{out2}$口用来输出对应的模拟量，其它端口用于控制。DAC0832有三种模式：双缓冲、单缓冲、直通。开发板采用最基本的直通方式连接电路：</p>
<p><img src="https://i.loli.net/2020/08/30/etSTbsC5WpV4zXK.png" alt="5DA数模转换.PNG"></p>
<p>如图，单片机P1口接DI0~DI7，P3.2管脚接$\overline{CS}$，P3.6管脚接$\overline{WR1}$。硬件连接有了，接着就要考虑编程操作，这需要知道这种连接模式的时序。</p>
<p><img src="https://i.loli.net/2020/08/30/c3ujWf9mHXdJR2w.png" alt="6DAC0832时序.PNG"></p>
<p>如图，先要给$\overline{CS}$和$\overline{WR1}$赋予低电平，在ts秒后D/A转换完成，$I_{out}$输出稳定。结束转换可以给$\overline{CS}$和$\overline{WR1}$赋予高电平。</p>
<p>例：呼吸灯</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line">sbit cs = P3^<span class="number">2</span>; <span class="comment">//CS</span></span><br><span class="line">sbit wr = P3^<span class="number">6</span>; <span class="comment">//WR</span></span><br><span class="line">sbit duan = P2^<span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//数据端计数0~255</span></span><br><span class="line">    uint flag = <span class="number">0</span>;  <span class="comment">//标识计数方向</span></span><br><span class="line">    duan = <span class="number">1</span>;       <span class="comment">//复用了P0，为防止数码管乱显示。</span></span><br><span class="line">    P0 = <span class="number">0</span>;</span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line">    cs = <span class="number">0</span>;         <span class="comment">//片选</span></span><br><span class="line">    wr = <span class="number">0</span>;         <span class="comment">//开始写数据</span></span><br><span class="line">    P0 = flag;      <span class="comment">//给D0~D7赋初值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count += <span class="number">5</span>;</span><br><span class="line">            P0 = count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= <span class="number">255</span>)</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">//反向</span></span><br><span class="line">            delay(<span class="number">50</span>);      <span class="comment">//DA转换延时</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count -= <span class="number">5</span>;</span><br><span class="line">            P0 = count;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                flag = <span class="number">0</span>;   <span class="comment">//反向</span></span><br><span class="line">            delay(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;ms; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只要将$\overline{CS}$和$\overline{WR1}$置为0，就可以连续给数据口赋值，芯片随之输出模拟量。D/A转换过程很快，但最好还是加上延时以保证数据完成转换。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>可以在<a href="https://www.alldatasheet.com/">https://www.alldatasheet.com/</a>下载芯片说明书。</li>
<li>芯片的说明书有典型的接法，其编程方法就是其时序图。</li>
</ol>
]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机八 温控系统</title>
    <url>/2011/10/18/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%AB%20%E6%B8%A9%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><p>温控系统必然有温度感应元器件，开发板使用DS18B20作为温度传感器。DS18B20工作电压为3.0~5.5V，在寄生电源方式下可由数据线供电。电源极性接反时，不会烧毁，但不能正常工作。温控范围-55~125，在-10~85时精度为±0.5。</p>
<a id="more"></a>

<p>DS18B20样子很像三极管，如图：</p>
<p><img src="https://i.loli.net/2020/10/02/pmkvCLbRVToWAs2.png" alt="1DS18B20.PNG"></p>
<p>如图，DS18B20只有一条数据线，属于单总线设备。单总线即可传输时钟，又可传输数据，而且传输是双向的。</p>
<blockquote>
<p>目前常用的单片机与外设之间进行数据传输的串行总线有IIC，SPI和SCI。IIC总线采用同步串行双线通信。SPI总线采用同步串行三线通信（时钟线、输入线、输出线）。SCI总线采用异步方式通信（输入线、输出线）。</p>
</blockquote>
<p>DS18B20说明书连接图如下：</p>
<p><img src="https://i.loli.net/2020/10/02/a1jYMQ3fDIzwUbS.png" alt="2硬件连接.PNG"></p>
<p>通常要求在单总线上外接一个5kΩ上拉电阻。</p>
<p>开发板连接图如下：</p>
<p><img src="https://i.loli.net/2020/10/02/K6DQlE2Z3hmo1VC.png" alt="3开发板连接.PNG"></p>
<p>如果要控制多个DS18B20进行温度采集，只要将所有DS18B20的DQ口接到一起即可。单片机通过它内部的序列号来识别每个设备。</p>
<h4 id="DS18B20的指令"><a href="#DS18B20的指令" class="headerlink" title="DS18B20的指令"></a>DS18B20的指令</h4><p>DS18B20控制指令：</p>
<ol>
<li>33H：读ROM中的64位编码。</li>
<li>55H：发出此命令后，接着发送64位ROM码，等待对应的DS18B20回应。</li>
<li>CCH：跳过1，2步，直接向DS18B20发送变换命令，适用于只有一个传感器的情况。</li>
<li>F0H：确定同一总线上DS18B20的个数。</li>
<li>ECH：使得温度只有超过上限或下限时才响应。</li>
</ol>
<blockquote>
<p>64位ROM：8位CRC，48位序列号，8位产品类型号</p>
</blockquote>
<p>当有多个DS18B20连接到总线时，先发送33H命令获取每个传感器的64位ROM。然后，发送55H命令，紧接着发送想要通信的传感器64位ROM码。之后的读取操作就是针对这个传感器。如果只有一个DS18B20，就可以发送CCH命令跳过上述步骤。</p>
<p>DS18B20温度获取指令：</p>
<ol>
<li>44H：温度转换，12位转换750ms，9位转换93.75ms。</li>
<li>BEH：读取RAM中的温度数据。</li>
<li>4EH：写RAM的第2、3字节，设置上下限温度（此命令后，发送两字节温度数据）。</li>
<li>48H：将RAM的第2、3字节复制到EEPROM。</li>
<li>B8H：将EEPROM中的内容恢复到RAM的第3、4字节。</li>
<li>B4H：读取DS18B20的供电方式。寄生供电，DS18B20发送0；外接电源，发送1。</li>
</ol>
<p>RAM共9个字节：0温度值低位LSB，1温度值高位MSB，2高温限值TH，3低温限值TL，4配置寄存器，5、6、7保留，8CRC校验值。</p>
<p>DS18B20出厂默认12位，最高位为符号位，温度值为11位。单片机在读取温度值时，会读取2字节共16位。前5位为符号位，每一位同时变化一模一样，为1表示负值，为0表示正值。当温度值为负时，需要将11位温度值取反加1再乘以0.0625才可得到实际温度值；为正值，直接乘以0.0625即可。</p>
<h4 id="DS18B20读写时序"><a href="#DS18B20读写时序" class="headerlink" title="DS18B20读写时序"></a>DS18B20读写时序</h4><p>初始化时序</p>
<p><img src="https://i.loli.net/2020/10/02/BCJktomYhrMLT7x.png" alt="4初始化.png"></p>
<ol>
<li>将数据线置1，短暂延时</li>
<li>将数据线置0，延时750us（480~960us）</li>
<li>将数据线置1，延时15~60us后，由DS18B20返回低电平0。</li>
<li>单片机收到0后，延时60~240us。</li>
<li>将数据线置1结束。从第三步至此，至少需要480us。</li>
</ol>
<p>用代码描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i;                 <span class="comment">//必须为int型</span></span><br><span class="line">    DQ = <span class="number">0</span>;                 <span class="comment">//第二步</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">103</span>; i&gt;<span class="number">0</span>; i--);</span><br><span class="line">    DQ = <span class="number">1</span>;                 <span class="comment">//第三步</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">4</span>; i&gt;<span class="number">0</span>; i--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写时序</p>
<p><img src="https://i.loli.net/2020/10/02/BSyhuWKkGQCexJ1.png" alt="5写.png"></p>
<p>每个字节从低位到高位发送，每次写1位数据：</p>
<ol>
<li>写0：将数据线置0，延时60us；再将数据线置1，延时大于1us。</li>
<li>写1：将数据线置0，延时大于1us；再将数据线置1，延时45us。</li>
</ol>
<blockquote>
<p>位传送时间为45us</p>
</blockquote>
<p>用代码描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_byte</span><span class="params">(uchar d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint j;             <span class="comment">//必须为int型</span></span><br><span class="line">    uchar i;</span><br><span class="line">    bit b;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) <span class="comment">//每次写一位</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = d &amp; <span class="number">0x01</span>;   <span class="comment">//前7位清0</span></span><br><span class="line">        d = d &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b)          <span class="comment">//写1，第二条</span></span><br><span class="line">        &#123;</span><br><span class="line">            DQ = <span class="number">0</span>;</span><br><span class="line">            j++;j++;</span><br><span class="line">            DQ = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">8</span>; j&gt;<span class="number">0</span>; j--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>            <span class="comment">//写0，第一条</span></span><br><span class="line">        &#123;</span><br><span class="line">            DQ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">8</span>; j&gt;<span class="number">0</span>; j--);</span><br><span class="line">            DQ = <span class="number">1</span>;</span><br><span class="line">            j++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读时序</p>
<p><img src="https://i.loli.net/2020/10/02/64bfH9MKvrtyILx.png" alt="6读.png"></p>
<p>与写时序类似，所有的读时间间隙也应至少有60us，在时间间隙之间应有1us的恢复时间。读时间间隙起始于主设备拉低电平至少1us，然后释放总线（拉高）。</p>
<ol>
<li>将数据线置0，延时4us。</li>
<li>将数据线置1，延时6us，等待DS18B20返回数据。</li>
<li>读取1位，延时45us。</li>
<li>重复1~3，直到读取完一个字节。</li>
</ol>
<p>用代码描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">bit <span class="title">read_bit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i;</span><br><span class="line">    bit rb;             </span><br><span class="line">    DQ = <span class="number">0</span>; i++;        <span class="comment">//第一步</span></span><br><span class="line">    DQ = <span class="number">1</span>; i++;i++;    <span class="comment">//第二步</span></span><br><span class="line">    rb = DQ;            <span class="comment">//第三步</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">8</span>; i&gt;<span class="number">0</span>; i--);</span><br><span class="line">    <span class="keyword">return</span> rb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uchar <span class="title">read_byte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i, temp, rbyte;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) <span class="comment">//第四步</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = read_bit();</span><br><span class="line">        rbyte = (temp&lt;&lt;<span class="number">7</span>) | (rbyte&gt;&gt;<span class="number">1</span>); <span class="comment">//从最低位开始接收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rbyte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示当前温度"><a href="#显示当前温度" class="headerlink" title="显示当前温度"></a>显示当前温度</h4><p>通过DS18B20获取当前温度，将温度值显示到数码管并通过串口发送到上位机程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line">sbit DQ = P2^<span class="number">2</span>;     <span class="comment">//传感器数据线</span></span><br><span class="line">sbit duan = P2^<span class="number">6</span>;</span><br><span class="line">sbit wei = P2^<span class="number">7</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code table[] = &#123;</span><br><span class="line">    <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>,  <span class="comment">//带小数点0~9</span></span><br><span class="line">    <span class="number">0xbf</span>,<span class="number">0x86</span>,<span class="number">0xdb</span>,<span class="number">0xcf</span>,<span class="number">0xe6</span>,<span class="number">0xed</span>,<span class="number">0xfd</span>,<span class="number">0x87</span>,<span class="number">0xff</span>,<span class="number">0xef</span>   <span class="comment">//不带小数点0~9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">bit <span class="title">read_bit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">uchar <span class="title">read_byte</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_byte</span><span class="params">(uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_DS18B20</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_t</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uchar,uchar)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_com</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_com</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="keyword">float</span> temperature;<span class="comment">//保留1位小数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i;</span><br><span class="line">    uchar buff[<span class="number">4</span>];</span><br><span class="line">    init_com();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        init_DS18B20();</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">display_t</span>(<span class="keyword">get_t</span>());</span><br><span class="line">        <span class="built_in">sprintf</span>(buff,<span class="string">&quot;%f&quot;</span>,temperature+<span class="number">0.05</span>);<span class="comment">//浮点型转字符型</span></span><br><span class="line">        put_com(buff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uchar d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;d; i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">110</span>; j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i;                 <span class="comment">//必须为int型</span></span><br><span class="line">    DQ = <span class="number">0</span>;                 <span class="comment">//第二步</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">103</span>; i&gt;<span class="number">0</span>; i--);</span><br><span class="line">    DQ = <span class="number">1</span>;                 <span class="comment">//第三步</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">4</span>; i&gt;<span class="number">0</span>; i--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bit <span class="title">read_bit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i;</span><br><span class="line">    bit rb;</span><br><span class="line">    DQ = <span class="number">0</span>; i++;        <span class="comment">//第一步</span></span><br><span class="line">    DQ = <span class="number">1</span>; i++;i++;    <span class="comment">//第二步</span></span><br><span class="line">    rb = DQ;            <span class="comment">//第三步</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">8</span>; i&gt;<span class="number">0</span>; i--);</span><br><span class="line">    <span class="keyword">return</span> rb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uchar <span class="title">read_byte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i, temp, rbyte;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) <span class="comment">//第四步</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = read_bit();</span><br><span class="line">        rbyte = (temp&lt;&lt;<span class="number">7</span>) | (rbyte&gt;&gt;<span class="number">1</span>); <span class="comment">//从最低位开始接收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rbyte;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_byte</span><span class="params">(uchar d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint j;             <span class="comment">//必须为int型</span></span><br><span class="line">    uchar i;</span><br><span class="line">    bit b;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) <span class="comment">//每次写一位</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = d &amp; <span class="number">0x01</span>;   <span class="comment">//前7位清0</span></span><br><span class="line">        d = d &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b)          <span class="comment">//写1，第二条</span></span><br><span class="line">        &#123;</span><br><span class="line">            DQ = <span class="number">0</span>;</span><br><span class="line">            j++;j++;</span><br><span class="line">            DQ = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">8</span>; j&gt;<span class="number">0</span>; j--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>            <span class="comment">//写0，第一条</span></span><br><span class="line">        &#123;</span><br><span class="line">            DQ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">8</span>; j&gt;<span class="number">0</span>; j--);</span><br><span class="line">            DQ = <span class="number">1</span>;</span><br><span class="line">            j++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_DS18B20</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reset();</span><br><span class="line">    delayms(<span class="number">1</span>);</span><br><span class="line">    write_byte(<span class="number">0xcc</span>);    <span class="comment">//跳过寻址</span></span><br><span class="line">    write_byte(<span class="number">0x44</span>);    <span class="comment">//转换温度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_t</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar h,l;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    reset();</span><br><span class="line">    delayms(<span class="number">1</span>);</span><br><span class="line">    write_byte(<span class="number">0xcc</span>);</span><br><span class="line">    write_byte(<span class="number">0xbe</span>);    <span class="comment">//读取温度</span></span><br><span class="line">    l = read_byte();     <span class="comment">//读取低位</span></span><br><span class="line">    h = read_byte();     <span class="comment">//读取高位</span></span><br><span class="line">    t = h;               <span class="comment">//合并高低位</span></span><br><span class="line">    t &lt;&lt;= <span class="number">8</span>;             <span class="comment">//空出低8位</span></span><br><span class="line">    t = t | l;</span><br><span class="line">    temperature = t * <span class="number">0.0625</span>;    <span class="comment">//求得实际温度值（包含小数部分）</span></span><br><span class="line">    t = temperature * <span class="number">10</span> + <span class="number">0.5</span>;  <span class="comment">//乘10将第一位小数划入整数部分，</span></span><br><span class="line">    <span class="keyword">return</span> t;                    <span class="comment">//0.5加到了第二位小数，用于四舍五入。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(uchar pos,uchar d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    duan = <span class="number">1</span>;</span><br><span class="line">    P0 = table[d];</span><br><span class="line">    duan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wei = <span class="number">1</span>;</span><br><span class="line">    P0 = (~(<span class="number">0x01</span>&lt;&lt;pos));</span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    delayms(<span class="number">5</span>);     <span class="comment">//延时 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_t</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar i;</span><br><span class="line">    i = t/<span class="number">100</span>;      <span class="comment">//得到十位</span></span><br><span class="line">    display(<span class="number">0</span>,i);   <span class="comment">//在第一个数据管显示</span></span><br><span class="line">    i = t%<span class="number">100</span>/<span class="number">10</span>;   <span class="comment">//得到个位，需带小数点</span></span><br><span class="line">    display(<span class="number">1</span>,i+<span class="number">10</span>);</span><br><span class="line">    i = t%<span class="number">100</span>%<span class="number">10</span>;   <span class="comment">//小数位</span></span><br><span class="line">    display(<span class="number">2</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_com</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TMOD = <span class="number">0x20</span>;</span><br><span class="line">    PCON = <span class="number">0</span>;</span><br><span class="line">    SCON = <span class="number">0x50</span>;</span><br><span class="line">    TH1 = <span class="number">0xFD</span>;</span><br><span class="line">    TL1 = <span class="number">0xFD</span>;</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_com</span><span class="params">(<span class="keyword">char</span> *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        SBUF = *d++;</span><br><span class="line">        <span class="keyword">while</span> (!TI);</span><br><span class="line">        TI = <span class="number">0</span>;	</span><br><span class="line">    &#125;<span class="keyword">while</span>(*d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="VC开发上位机程序"><a href="#VC开发上位机程序" class="headerlink" title="VC开发上位机程序"></a>VC开发上位机程序</h4><p>一、添加串口控件，对于windows7x64，VC2010环境，需要下载MSCOMM32.OCX，然后将其放入C:\Windows\SysWOW64。在CMD中输入命令Regsvr32 C:\Windows\SysWOW64\MSCOMM32.OCX，提示注册成功后，检查注册表中两项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[HKEY_CLASSES_ROOT\Licenses\ED4B87C4-9F76-11d1-8BF7-0000F8754DA1]</span><br><span class="line">@ &#x3D; &quot;knlggnmntgggrninthpgmnngrhqhnnjnslsh&quot;</span><br><span class="line">[HKEY_CLASSES_ROOT\Licenses\4250E830-6AC2-11cf-8ADB-00AA00C00905]</span><br><span class="line">@ &#x3D; &quot;kjljvjjjoquqmjjjvpqqkqmqykypoqjquoun&quot;</span><br></pre></td></tr></table></figure>
<p>如果没有这两项，需要手动添加。完成后，重新打开VC2010即可插入MSCOMM32控件。插入方法：在资源视图下，右键对话框控件，选择“插入ActiveX控件”。在弹出的对话框中选择“Microsoft Communications Control,version6.0”。此时会出现一个电话图标，带有一个白边，右键图标选择“编辑控件”即可消除。</p>
<blockquote>
<p>这个串口控件可是个老物，使用它开发的程序未来可能会出现兼容性问题。</p>
</blockquote>
<p>二、为串口控件添加变量，右键点击控件，选择添加变量，默认类型为CMscomm1，输入变量名m_ctrlComm确定。在类视图中会看到多出了一个CMscomm1类，其中有很多以get和put开头的函数，用于操作串口输入输出。</p>
<p>三、在OnInitDialog()中，添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_ctrlComm.get_PortOpen())</span><br><span class="line">    m_ctrlComm.put_PortOpen(FALSE);</span><br><span class="line">m_ctrlComm.put_CommPort(<span class="number">4</span>);                <span class="comment">//选择COM4，根据自己的串口号</span></span><br><span class="line">m_ctrlComm.put_InputMode(<span class="number">1</span>);               <span class="comment">//1表示以二进制方式捡取数据</span></span><br><span class="line">m_ctrlComm.put_InBufferSize(<span class="number">1024</span>);         <span class="comment">//输入缓冲区大小为1024byte</span></span><br><span class="line">m_ctrlComm.put_OutBufferSize(<span class="number">512</span>);         <span class="comment">//输出缓冲区大小为512byte</span></span><br><span class="line">m_ctrlComm.put_Settings(<span class="string">&quot;9600,n,8,1&quot;</span>);     <span class="comment">//波特率9600，无校验，8个数据位，1个停止位</span></span><br><span class="line"><span class="keyword">if</span> (!m_ctrlComm.get_PortOpen())</span><br><span class="line">    m_ctrlComm.put_PortOpen(TRUE);         <span class="comment">//打开串口</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;Can&#x27;t open serialport&quot;</span>);</span><br><span class="line">m_ctrlComm.put_RThreshold(<span class="number">1</span>);              <span class="comment">//1表示缓冲区内有大于等于1个字符时，将触发一个Comm事件</span></span><br><span class="line">m_ctrlComm.put_InputLen(<span class="number">0</span>);                <span class="comment">//设置当前接收区长度为0</span></span><br><span class="line">m_ctrlComm.get_Input();                    <span class="comment">//预读缓冲区以清空残留数据</span></span><br></pre></td></tr></table></figure>
<p>四、为串口控件添加响应函数：在资源视图中右键“电话图标”，选择“添加事件处理程序”。VC会自动添加响应函数OnCommMscomm1，并建立控件与函数的映射。再在对话框资源上添加编辑框控件，绑定String类型变量m_strValue。在OnCommMscomm1中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    m_strValue = <span class="string">&quot;&quot;</span>;                    <span class="comment">//每次响应，都应清空</span></span><br><span class="line">    VARIANT var;</span><br><span class="line">    COleSafeArray sa;</span><br><span class="line">    LONG len,i;</span><br><span class="line">    BYTE rxd[<span class="number">2048</span>];</span><br><span class="line">    CString temp;</span><br><span class="line">    <span class="keyword">if</span> (m_ctrlComm.get_CommEvent() == <span class="number">2</span>)<span class="comment">//事件2表示接收缓冲区有字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        var = m_ctrlComm.get_Input();   <span class="comment">//读缓冲区</span></span><br><span class="line">        sa = var;                       <span class="comment">//类型转换</span></span><br><span class="line">        len = sa.GetOneDimSize();       <span class="comment">//得到有效数据长度</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">            sa.GetElement(&amp;i,rxd+i);    <span class="comment">//转换为BYTE型数组</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)           <span class="comment">//将数组转换为CString型变量</span></span><br><span class="line">        &#123;</span><br><span class="line">            BYTE bt = *(<span class="keyword">char</span>*)(rxd+i);</span><br><span class="line">            temp.Format(<span class="string">&quot;%c&quot;</span>,bt);</span><br><span class="line">            m_strValue += temp;         <span class="comment">//将字符累积到编辑框变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UpdateData(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>批处理</title>
    <url>/2008/03/03/%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>如果想要对windows系统进行某些设置或者获取某些信息，需要使用到命令行操作。在这里把它们整理成批处理可以方便自己和其他不擅长计算机的人使用，避免了不必要的讲解和操作。</p>
<a id="more"></a>

<p>一、获取MAC地址</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f &quot;skip=<span class="number">3</span> delims= &quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;getmac&#x27;) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%i</span>&gt;&gt;MAC.txt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PC</category>
      </categories>
      <tags>
        <tag>BAT</tag>
      </tags>
  </entry>
  <entry>
    <title>房价上天的起点</title>
    <url>/2018/09/21/%E6%88%BF%E4%BB%B7%E4%B8%8A%E5%A4%A9%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>下面这篇文章要是在2009年看到就好了。当然，看到了也不一定理解，理解了也不一定去做。不过现在看来，这篇文章也是颇具启发性。</p>
<a id="more"></a>

<h4 id="转载《周小川：扩大居民消费将拉动内需并降低总储蓄率》"><a href="#转载《周小川：扩大居民消费将拉动内需并降低总储蓄率》" class="headerlink" title="转载《周小川：扩大居民消费将拉动内需并降低总储蓄率》"></a>转载《周小川：扩大居民消费将拉动内需并降低总储蓄率》</h4><p>中央政府门户网站　<a href="http://www.gov.cn/">www.gov.cn</a>　　 2009年07月05日　　 来源：人民日报</p>
<p>中国人民银行行长周小川在全球智库峰会上指出，中国结构调整的最优选择是扩大居民消费，这将直接拉动内需并降低总储蓄率。</p>
<p>周小川说，全球经济不平衡有一个很明显的不合理特点，就是收入相对较低国家储蓄率高，而发达国家富裕人群过度消费。中国储蓄率过高，美国家庭储蓄率过低，两国都应进行改革。我们愿朝这个方向努力，同时不宜轻易夸大两个国家所能起到的作用。中国的家庭储蓄与GDP之比实际相当稳定，1992-2007年基本保持在20%上下；企业储蓄占比1992年为11.3%，2007年达22.9%，涨了1倍；同期，政府亦即公共部门储蓄占比从1992年的4.4%提高到2007年的8.1%，也上升近1倍。<strong>公司部门的利润较高缘于股权分布结构，广大劳动者只分享到较少的公司利润。解决这个问题，必须创造条件让更多群众拥有财产性收入。中国一颇具潜力的投资领域是城镇化发展，它为未来的人口迁移、消费条件和服务业发展打下基础。</strong>考虑到中国储蓄率基数相当高，还可能会有部分剩余储蓄，希望能更多地流向发展中国家。这就需要国际金融组织体系和国际货币体系的支持，以使全球生产率和收入分配得到改善，带来更普遍的、绿色的全球增长。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>美国储蓄率低的原因是什么？中国储蓄率高的原因是什么？</li>
<li>降低中国储蓄率的目的是什么？有哪些好处？有哪些坏处？</li>
<li>公司利润较高，劳动者分享的较少，最直接合理的不是应该提高工资吗？</li>
</ol>
<blockquote>
<p>上述三个问题很基本，但理解起来并不简单。这里边有真东西。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>今后，央行也应该会是中国社会舞台的主角。央行发布的政策和行长发布的言论都要当作预言深入理解。</p>
]]></content>
      <categories>
        <category>Economy</category>
      </categories>
      <tags>
        <tag>Economy</tag>
      </tags>
  </entry>
  <entry>
    <title>大力神（Devastator）</title>
    <url>/2019/12/25/%E5%A4%A7%E5%8A%9B%E7%A5%9E%EF%BC%88Devastator%EF%BC%89/</url>
    <content><![CDATA[<p>在G1动画中，大力神作为第一个出现的组合金刚，也是唯一个六合体，给我留下了深刻的印象。小时候，我唯一的一个官方变形金刚就是这个吊车：</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/07/11/oBlLJgCD8FUWpHv.jpg" alt="大力神-1.jpg"></p>
<p>记得我二姨刚买来送给我时，姥姥家中的长辈们也都觉得新鲜凑过来看。那个时候我还没上小学，根本抢不过他们，东西一直在他们手里传。我很着急，伸着胳膊就是够不到。</p>
<p>在最后一个人被我“骚扰”烦了后，将一个变得乱七八糟的“垃圾”甩给了我。我带着郁闷的心情，对照着说明书，试着复原，由于腰部可对折部分过紧，结果就掰断了！</p>
<p>这个体验就太差了，从此以后它就像个“鸡肋”，被撇在我玩具库的角落里，没给我带来一天乐趣。直到上小学三年级时，在胡同小朋友家再次看到这个玩具，才知道它在当时的价格。不过，他也只有三个而已，分别是铲车、搅拌车和吊车。</p>
<p>现在，在淘宝上看到GT大力神，自然是想买回来圆梦。同期的还有TW大力神，可玩性更好，但我不喜欢它传统的造型，那个法老头倒是创新，但实在算不上亮点。其实在我觉得，变形金刚就是一个设定，只要保证人设不变的情况下，造型完全可以随意创新。这种能够与时俱进的特性，相对于同类玩具绝对是个大优势。</p>
<p>GT大力神每个载具都比较贴近实物，具有一定的机械感。</p>
<p><img src="https://i.loli.net/2020/07/11/sLYo16fOFQDS4yC.jpg" alt="大力神-2.jpg"></p>
<p>六个单体人形态高矮一致，造型中规中矩。变形过程虽然不像官方那么简单直接，但复杂程度相对于同级别第三方玩具还算合理。</p>
<p><img src="https://i.loli.net/2020/07/11/59CPREfkBYmqKwG.jpg" alt="大力神-3.jpg"></p>
<p>作为合体金刚，最关键的还是合体后的样子：</p>
<p><img src="https://i.loli.net/2020/07/11/wYI1gPRnqoU27tc.jpg" alt="大力神-4.jpg"></p>
<p>相对于其他版本大力神，它更加健壮，细节丰富，前后隐藏的很好，整体造型更加现代，非常难得的是<strong>一体变形</strong>，没有附加一堆配件包。</p>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Transformers</category>
      </categories>
      <tags>
        <tag>Transformers</tag>
      </tags>
  </entry>
  <entry>
    <title>数据可视化</title>
    <url>/2020/11/01/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>管理工作（非领导）很难界定绩效，在当前中国职场远不如技术岗、销售岗有前途，在某些方面甚至还不如生产岗！所以，作为管理人员不能消极地寄托于领导具有一双慧眼并且具有较高的悟性，应该将自己的工作以高水平的方式展现出来。</p>
<p>所谓的“大数据”，在中国已经搞了几年，在很多领域都有一定的应用。我们可以借鉴这个思路，结合自己的管理工作，对公司相关业务领域应用“大数据”方法，生成可视化报表，并对此进行分析总结。当我们说明某些情况时或推行某些管理时，就可以节选其中某个侧面，为实际需要提供有力支撑。</p>
<a id="more"></a>

<p>从各种系统中获取的原始数据需要清洗、整理、可视化，一般选用Excel或Python来完成这些这些任务。Python比Excel更加的自动化，呈现图表的效果更好，而且当数据量很大时效率更高。因此，本人选用Python作为数据可视化工具。</p>
<h4 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h4><p>我们需要如下工具：</p>
<ol>
<li>Jupyter Notebook。这个编辑器依赖于Web浏览器，使用它便于看到结果。</li>
<li>pandas。这是个数据处理包，内含众多数据分析实用函数。</li>
<li>pyecharts。这是个图表渲染包，我们的数据就是靠它可视化。</li>
</ol>
<p>上述工具无需逐个安装，Anaconda集成了众多科学包和数据分析包，下载地址：<a href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a>。</p>
<p>安装Anaconda很简单，一路next即可，在向导最后一步可以选择将Anaconda3加入系统环境PATH。安装完成后，Python、Jupyter、pandas、numpy、matplotlib这些工具和包就都可以使用了。不过，为了使图表显示的更美观，还需要安装pyecharts，打开Anaconda Powershell Prompt，输入<code>pip install pyecharts</code>。</p>
<p>直接点击Jupyter Notebook快捷方式，将会启动浏览器并进入默认Home页。点击右侧New按钮，选择Python 3即可在当年目录新建一个ipynb文件。这个文件会以一个新的web页面显示。我们在框内输入代码，按压Shift+Enter即可在下面看到结果，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyecharts</span><br><span class="line">pyecharts.__version__       <span class="comment">#显示版本号</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当代码比较复杂时，Python解释代码需要时间，此时在显示块号的方括号内会显示星号*。</p>
</blockquote>
<p>通常，我们希望在自定义目录启动Jupyter Notebook，方法为：运行Anaconda Powershell Prompt，从这个命令行进入指定目录，键入Jupyter Notebook运行程序。</p>
<p>numpy和pandas用于数据处理；matplotlib用于数据显示。公司一般管理工作通常牵扯不到复杂的数据处理，所以我们以matplotlib为重点说明几种常用图表的应用。</p>
<h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><p>一、分类对比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"></span><br><span class="line">c = (</span><br><span class="line">    Bar()</span><br><span class="line">    .add_xaxis([<span class="string">&quot;计算机&quot;</span>,<span class="string">&quot;打印机&quot;</span>,<span class="string">&quot;复印机&quot;</span>,<span class="string">&quot;投影仪&quot;</span>,<span class="string">&quot;碎纸机&quot;</span>,<span class="string">&quot;传真机&quot;</span>,])<span class="comment">#添加x轴内容</span></span><br><span class="line">    .add_yaxis(<span class="string">&quot;公司A&quot;</span>, [<span class="number">270</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>])   <span class="comment">#添加y轴内容</span></span><br><span class="line">    .add_yaxis(<span class="string">&quot;公司B&quot;</span>, [<span class="number">520</span>, <span class="number">280</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">15</span>]) <span class="comment">#添加y轴内容</span></span><br><span class="line">    .set_global_opts(</span><br><span class="line">        xaxis_opts = opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=-<span class="number">30</span>)),<span class="comment">#x轴文字倾斜角度</span></span><br><span class="line">        title_opts = opts.TitleOpts(title=<span class="string">&quot;信息设备统计&quot;</span>, subtitle=<span class="string">&quot;台数&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">c.render_notebook()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/27/umxsw9QGICSyVbM.png" alt="1柱状对比图.png"></p>
<p>二、单柱堆叠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"></span><br><span class="line">c = (</span><br><span class="line">    Bar()</span><br><span class="line">    .add_xaxis([<span class="string">&quot;计算机&quot;</span>,<span class="string">&quot;打印机&quot;</span>,<span class="string">&quot;复印机&quot;</span>,<span class="string">&quot;投影仪&quot;</span>,<span class="string">&quot;碎纸机&quot;</span>,<span class="string">&quot;传真机&quot;</span>,])</span><br><span class="line">    .add_yaxis(<span class="string">&quot;公司A&quot;</span>, [<span class="number">270</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>], stack = <span class="string">&quot;stack1&quot;</span>)   <span class="comment">#多了一个stack参数</span></span><br><span class="line">    .add_yaxis(<span class="string">&quot;公司B&quot;</span>, [<span class="number">520</span>, <span class="number">280</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">15</span>], stack = <span class="string">&quot;stack1&quot;</span>)</span><br><span class="line">    .set_series_opts(label_opts = opts.LabelOpts(is_show = <span class="literal">False</span>))  <span class="comment">#不显示数字</span></span><br><span class="line">    .set_global_opts(title_opts = opts.TitleOpts(title=<span class="string">&quot;信息设备统计&quot;</span>))</span><br><span class="line">    .render(<span class="string">&quot;bar_stack.html&quot;</span>)                <span class="comment">#在当前目录下生成一个html文件用于显示图表</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/27/AFca1YDy7KJP4qh.png" alt="2柱状堆叠图.png"></p>
<p>三、线柱综合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyecharts.options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar, Line</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&quot;1月&quot;</span>, <span class="string">&quot;2月&quot;</span>, <span class="string">&quot;3月&quot;</span>, <span class="string">&quot;4月&quot;</span>, <span class="string">&quot;5月&quot;</span>, <span class="string">&quot;6月&quot;</span>, <span class="string">&quot;7月&quot;</span>, <span class="string">&quot;8月&quot;</span>, <span class="string">&quot;9月&quot;</span>, <span class="string">&quot;10月&quot;</span>, <span class="string">&quot;11月&quot;</span>, <span class="string">&quot;12月&quot;</span>]</span><br><span class="line">y1 = [<span class="number">2.0</span>, <span class="number">4.9</span>, <span class="number">7.0</span>, <span class="number">23.2</span>, <span class="number">25.6</span>, <span class="number">76.7</span>, <span class="number">135.6</span>, <span class="number">162.2</span>, <span class="number">32.6</span>, <span class="number">20.0</span>, <span class="number">6.4</span>, <span class="number">3.3</span>]</span><br><span class="line">y2 = [<span class="number">2.6</span>, <span class="number">5.9</span>, <span class="number">9.0</span>, <span class="number">26.4</span>, <span class="number">28.7</span>, <span class="number">70.7</span>, <span class="number">175.6</span>, <span class="number">182.2</span>, <span class="number">48.7</span>, <span class="number">18.8</span>, <span class="number">6.0</span>, <span class="number">2.3</span>]</span><br><span class="line">z = [<span class="number">2.0</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.5</span>, <span class="number">6.3</span>, <span class="number">10.2</span>, <span class="number">20.3</span>, <span class="number">23.4</span>, <span class="number">23.0</span>, <span class="number">16.5</span>, <span class="number">12.0</span>, <span class="number">6.2</span>]</span><br><span class="line"></span><br><span class="line">bar = (</span><br><span class="line">    Bar()</span><br><span class="line">    .add_xaxis(xaxis_data=x)       <span class="comment">#x轴通过参数xaxis_data赋值</span></span><br><span class="line">    .add_yaxis(</span><br><span class="line">        series_name = <span class="string">&quot;蒸发量&quot;</span>,</span><br><span class="line">        y_axis = y1,               <span class="comment">#y轴通过参数y_axis赋值，与x轴不一致</span></span><br><span class="line">        label_opts = opts.LabelOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">        color = <span class="string">&quot;#669966&quot;</span>          <span class="comment">#修改“蒸发量”柱体颜色</span></span><br><span class="line">    )</span><br><span class="line">    .add_yaxis(</span><br><span class="line">        series_name = <span class="string">&quot;降水量&quot;</span>,</span><br><span class="line">        y_axis = y2,</span><br><span class="line">        label_opts = opts.LabelOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">        color = <span class="string">&quot;#996699&quot;</span>          <span class="comment">#修改“降水量”柱体颜色</span></span><br><span class="line">    )</span><br><span class="line">    .extend_axis(                  <span class="comment">#右侧y轴的设置</span></span><br><span class="line">        yaxis=opts.AxisOpts(</span><br><span class="line">            name = <span class="string">&quot;温度&quot;</span>,</span><br><span class="line">            type_= <span class="string">&quot;value&quot;</span>,</span><br><span class="line">            min_ = <span class="number">0</span>,              <span class="comment">#轴粒度</span></span><br><span class="line">            max_ = <span class="number">25</span>,</span><br><span class="line">            interval = <span class="number">5</span>,</span><br><span class="line">            axislabel_opts = opts.LabelOpts(formatter=<span class="string">&quot;&#123;value&#125; °C&quot;</span>),</span><br><span class="line">            axisline_opts = opts.AxisLineOpts(  <span class="comment">#设置轴颜色</span></span><br><span class="line">                linestyle_opts = opts.LineStyleOpts(color=<span class="string">&quot;#332288&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    .set_global_opts(</span><br><span class="line">        tooltip_opts=opts.TooltipOpts(  <span class="comment">#提示框</span></span><br><span class="line">           is_show=<span class="literal">True</span>, trigger=<span class="string">&quot;axis&quot;</span>, axis_pointer_type=<span class="string">&quot;cross&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        xaxis_opts=opts.AxisOpts(       <span class="comment">#坐标轴类型</span></span><br><span class="line">            type_=<span class="string">&quot;category&quot;</span>,           <span class="comment">#类目轴，适用于离散的类目数据</span></span><br><span class="line">            axispointer_opts=opts.AxisPointerOpts(is_show=<span class="literal">True</span>, type_=<span class="string">&quot;shadow&quot;</span>),</span><br><span class="line">        ),</span><br><span class="line">        yaxis_opts=opts.AxisOpts(       <span class="comment">#左侧y轴设置</span></span><br><span class="line">            name = <span class="string">&quot;水量&quot;</span>,</span><br><span class="line">            type_ = <span class="string">&quot;value&quot;</span>,</span><br><span class="line">            min_ = <span class="number">0</span>,</span><br><span class="line">            max_ = <span class="number">250</span>,</span><br><span class="line">            interval = <span class="number">50</span>,</span><br><span class="line">            axislabel_opts = opts.LabelOpts(formatter=<span class="string">&quot;&#123;value&#125; ml&quot;</span>),</span><br><span class="line">            axistick_opts = opts.AxisTickOpts(is_show=<span class="literal">True</span>),   <span class="comment">#轴刻度是否显示</span></span><br><span class="line">            splitline_opts = opts.SplitLineOpts(is_show=<span class="literal">True</span>), <span class="comment">#以y坐标粒度显示横线</span></span><br><span class="line">            axisline_opts = opts.AxisLineOpts(                 <span class="comment">#轴颜色</span></span><br><span class="line">                linestyle_opts = opts.LineStyleOpts(color=<span class="string">&quot;#ddaadd&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">line = (</span><br><span class="line">    Line()</span><br><span class="line">    .add_xaxis(xaxis_data=x)</span><br><span class="line">    .add_yaxis(</span><br><span class="line">        series_name=<span class="string">&quot;平均温度&quot;</span>,</span><br><span class="line">        yaxis_index=<span class="number">1</span>,   <span class="comment">#按照右侧y轴显示折线</span></span><br><span class="line">        y_axis=z,</span><br><span class="line">        label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>)</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">bar.overlap(line).render(<span class="string">&quot;bar_and_line.html&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/27/uPDJqUG7CKFcVxr.png" alt="3柱状折线.png"></p>
<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>一、基本饼图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Pie</span><br><span class="line"></span><br><span class="line">c = (</span><br><span class="line">    Pie()</span><br><span class="line">    .add(</span><br><span class="line">        series_name=<span class="string">&quot;分布&quot;</span>,</span><br><span class="line">        data_pair=<span class="built_in">list</span>(<span class="built_in">zip</span>([<span class="string">&quot;计算机&quot;</span>,<span class="string">&quot;打印机&quot;</span>,<span class="string">&quot;复印机&quot;</span>,<span class="string">&quot;碎纸机&quot;</span>,<span class="string">&quot;投影仪&quot;</span>],[<span class="number">120</span>,<span class="number">150</span>,<span class="number">80</span>,<span class="number">20</span>,<span class="number">6</span>])),<span class="comment">#zip将两个列表组合为[(&quot;计算机&quot;,120),......]</span></span><br><span class="line">        <span class="comment">#radius=[&quot;50%&quot;, &quot;70%&quot;],   #环形显示</span></span><br><span class="line">        label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>, position=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    .set_global_opts(</span><br><span class="line">        title_opts=opts.TitleOpts(title=<span class="string">&quot;基本饼图&quot;</span>),</span><br><span class="line">        legend_opts=opts.LegendOpts(pos_left=<span class="string">&quot;30%&quot;</span>)  <span class="comment">#标识显示位置</span></span><br><span class="line">    )</span><br><span class="line">    .set_series_opts(</span><br><span class="line">        tooltip_opts=opts.TooltipOpts(</span><br><span class="line">            trigger=<span class="string">&quot;item&quot;</span>, formatter=<span class="string">&quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot;</span>)<span class="comment">#a b c d是官方定义的格式字符</span></span><br><span class="line">    )</span><br><span class="line">    .render(<span class="string">&quot;pie_base.html&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/27/SIWG2QpMRdzblna.png" alt="4饼图.png"></p>
<p>二、多饼图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Pie</span><br><span class="line"><span class="keyword">from</span> pyecharts.commons.utils <span class="keyword">import</span> JsCode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_label_opts</span>():</span></span><br><span class="line">    <span class="keyword">return</span> opts.LabelOpts(formatter=JsCode(fn), position=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = (</span><br><span class="line">    Pie()</span><br><span class="line">    .add(</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;剧情&quot;</span>, <span class="string">&quot;其他&quot;</span>], [<span class="number">25</span>, <span class="number">75</span>])],</span><br><span class="line">        center=[<span class="string">&quot;20%&quot;</span>, <span class="string">&quot;30%&quot;</span>],</span><br><span class="line">        radius=[<span class="number">60</span>, <span class="number">80</span>],</span><br><span class="line">        label_opts=new_label_opts(),</span><br><span class="line">    )</span><br><span class="line">    .add(</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;奇幻&quot;</span>, <span class="string">&quot;其他&quot;</span>], [<span class="number">24</span>, <span class="number">76</span>])],</span><br><span class="line">        center=[<span class="string">&quot;55%&quot;</span>, <span class="string">&quot;30%&quot;</span>],</span><br><span class="line">        radius=[<span class="number">60</span>, <span class="number">80</span>],</span><br><span class="line">        label_opts=new_label_opts(),</span><br><span class="line">    )</span><br><span class="line">    .add(</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;爱情&quot;</span>, <span class="string">&quot;其他&quot;</span>], [<span class="number">14</span>, <span class="number">86</span>])],</span><br><span class="line">        center=[<span class="string">&quot;20%&quot;</span>, <span class="string">&quot;70%&quot;</span>],</span><br><span class="line">        radius=[<span class="number">60</span>, <span class="number">80</span>],</span><br><span class="line">        label_opts=new_label_opts(),</span><br><span class="line">    )</span><br><span class="line">    .add(</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;惊悚&quot;</span>, <span class="string">&quot;其他&quot;</span>], [<span class="number">11</span>, <span class="number">89</span>])],</span><br><span class="line">        center=[<span class="string">&quot;55%&quot;</span>, <span class="string">&quot;70%&quot;</span>],</span><br><span class="line">        radius=[<span class="number">60</span>, <span class="number">80</span>],</span><br><span class="line">        label_opts=new_label_opts(),</span><br><span class="line">    )</span><br><span class="line">    .set_global_opts(</span><br><span class="line">        title_opts=opts.TitleOpts(title=<span class="string">&quot;多饼图基本示例&quot;</span>),</span><br><span class="line">        legend_opts=opts.LegendOpts(</span><br><span class="line">            type_=<span class="string">&quot;scroll&quot;</span>, pos_top=<span class="string">&quot;20%&quot;</span>, pos_left=<span class="string">&quot;80%&quot;</span>, orient=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    .render(<span class="string">&quot;mutiple_pie.html&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/22/s4voltkiD3ALjuT.png" alt="5多饼图.png"></p>
<blockquote>
<p>来自官方文档示例</p>
</blockquote>
<h4 id="折线"><a href="#折线" class="headerlink" title="折线"></a>折线</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pyecharts.options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">&quot;./信息设备.xlsx&quot;</span>)<span class="comment">#从excel导入数据</span></span><br><span class="line"></span><br><span class="line">c = (</span><br><span class="line">    Line()</span><br><span class="line">    .add_xaxis(df[<span class="string">&quot;月份&quot;</span>].to_list()) <span class="comment">#以列名获取数据，放入列表</span></span><br><span class="line">    .add_yaxis(<span class="string">&quot;生产&quot;</span>, df[<span class="string">&quot;生产&quot;</span>].to_list(), is_smooth=<span class="literal">True</span>)                                <span class="comment">#使得曲线平滑显示</span></span><br><span class="line">    .add_yaxis(<span class="string">&quot;科研&quot;</span>, df[<span class="string">&quot;科研&quot;</span>].to_list(), areastyle_opts=opts.AreaStyleOpts(opacity=<span class="number">0.5</span>))<span class="comment">#带阴影区域</span></span><br><span class="line">    .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;线图&quot;</span>))</span><br><span class="line">    .render(<span class="string">&quot;line_base.html&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/27/8LqiVHGeh9pTPzO.png" alt="6线图.png"></p>
<blockquote>
<p>需要事先在当前目录新建“信息设备.xlsx”文件，在其中录入3列信息，列头分别为“月份”、“生产”、“研发”。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>留下精神生活的痕迹</title>
    <url>/2016/11/29/%E7%95%99%E4%B8%8B%E7%B2%BE%E7%A5%9E%E7%94%9F%E6%B4%BB%E7%9A%84%E7%97%95%E8%BF%B9/</url>
    <content><![CDATA[<p>最近搬家收拾东西，把相册翻出来了。三本相册已经破损，近半数照片已经黏到了页面上，照片四周也不同程度的泛黄。我每天晚上花费两个小时，一张一张地清理照片，并按照时间顺序将它们放到一个新相册里。直至今日，全部照片清理完毕。</p>
<p>每张照片都过了一遍，当时的经历和感受都记得清清楚楚，甚至包括一两岁时的情景。如果没有这些照片，恐怕也就没有这些宝贵的记忆。</p>
<a id="more"></a>

<p>当今社会从纸面数据看，确实比过去的生活好了不少，但是没有幸福感的人却很普遍。两级分化的社会环境使得众多劳动者失去了目标，每天辗转于压力与乏味之间，寄希望于花钱能买到一点快乐。</p>
<p>快乐真的能买的到吗？真正的快乐又是什么？就我看来，真正的快乐有两种：</p>
<ol>
<li>初中之前，玩什么都快乐。</li>
<li>初中之后，只有获得成功才能快乐。</li>
</ol>
<p>第一条大家都懂，第二条解释一下：首先这个人得有自由，然后才会有真正的理想，经过努力实现了理想，人才能获得真正的快乐。以这个标准看，你就能明白，为什么国人普遍没有幸福感了。因为对于一般成年人，第一步就完蛋了。一个没有自由的人，必然没有真正的理想，有的只是别人的期望，你每天的黄金时间都用于实现“他人”的理想，使“他人”更加快乐，而这个“他人”还不一定感受的到你的付出。</p>
<p>有一则消息，我们那个年代的人基本上都听说过——放牛娃的故事：<br>记者采访一个农村放牛娃：“为什么放牛啊？”<br>答曰：“牛长大了卖钱。”<br>记者：“挣到钱后做什么呀？”<br>牛娃：“娶媳妇。”<br>记者：“娶完媳妇呢？”<br>牛娃：“生娃。”<br>记者：“然后呢？”<br>牛娃：“让娃放牛。”</p>
<p>这则消息有什么意义呢？那个时代给出的“标准”答案大体是：农村人口思想落后，国家要想发展农村经济先得大力发展农村教育，鼓励广大农村青壮年走出“大山”。那个时代的背景：随着第二和第三产业发展，城市建设需要大量廉价劳动力。另一方面，农村人口过剩逐渐形成社会隐患且管理难度巨大。</p>
<p>现在呢？那个故事还在延续：<br>A：为什么读书这么努力？<br>B：为了将来能找一份高薪的工作。<br>A：挣到钱后做什么呢？<br>B：交首付，贷款买房，娶媳妇。<br>A：娶完媳妇呢？<br>B：生娃，然后看看自身经济状况，再生二娃。<br>A：然后呢？<br>B：不能让孩子输在起跑线上，尽力给孩子更好的教育。</p>
<p>这个时代背景：帝国自从加入WTO，资本进程加速前进，各处都需要大量资源，某些技术型官僚借鉴了美国经验，认为房地产这条产业链较长，来钱快，并且易于控制（政府-银行），然后帝国进入房地产黄金时代。2007年美国次贷危机爆发，帝国内部矛盾也逐渐显现，于是4w亿出台，资产价格全面上涨，经济开始脱实向虚。2015年下半年股市熔断，帝国执行涨价去库存政策，然后社会就涌现出两个口号：农民工买房落户、学区房。</p>
<p><strong>农民牌</strong><br>自从建国以来，社会每逢出现问题，解决思路基本围绕农民：上山下乡、包产到户、农民进城务工、农村城镇化。因为人是社会发展的最基本资源，而帝国大部分人口是农民（有些人心里不承认）。</p>
<p><strong>教育牌</strong><br>阶级社会下，普罗大众就像生活在一口井中，教育就是一根好像能通往外界的杆子。这根杆子就是相声中说的——手电筒打出的光柱。首先它没有尽头，别人永远可以说你学的不够好；第二，打手电筒的人一旦关闭开关，你的一切努力就白费了。教育就是给底层民众一个奔头，缓和社会矛盾的一种手段。底层大众能跑多远是受控制的（考试），跑到尽头也只是定制出来的工具人而已（面试）。</p>
<blockquote>
<p>教育不能改变阶级流动性。——《21世纪资本论》</p>
</blockquote>
<p>自从工作以后，学生时代政治课上的知识时常不自觉的在头脑中浮现，比如：消灭剥削，消除两极分化，最终实现共同富裕。革命的时代没赶上，活在特色之下，只能认清现实，顺应大势做好本份，否则只能更惨。</p>
<blockquote>
<p>人最宝贵的东西就是生命，生命属于我们只有一次而已。人的一生应该是这样度过的：当他回首往事时，不因虚度年华而悔恨，也不因过去的碌碌无为而羞耻，这样，他在临死的时候就能够说：“我的整个生命和全部精力，都献给了世界上最壮丽的事业——为人类的解放而斗争。”——《钢铁是怎样炼成的》</p>
</blockquote>
<p>一个小老百姓其实没有改变命运的力量，真正实现阶级跃迁的人都是靠时机和运气的。生物的天性都是利己的，即使后天无法成就事业，也没有人甘心当人肉干电池，也想活出点意义来，至少临死前别觉得太辜负自己。生活中的美好经历必须留下痕迹，将来回忆往事时，才不会觉得虚度此生。</p>
<p>自从步入小学，上了所谓的“人生轨迹”后，除了一寸照片，我基本就没再照过像，也没买过任何纪念品。学生时代还好，有升学考试和毕业证作为里程碑。工作之后的经历就相对随缘了，日常生活较为松散，大概就是看书、看视频、玩游戏、旅行。这些事情都属于精神生活，即使当时获得了足够的满足感，但随着时光流逝，最终都会烟消云散。</p>
<p>所以，特别需要留下痕迹的就是精神生活，如果当时没留下标的物，将来回首往事必然会产生虚度感。读书要做注释，将当时的理解记录下来，最好保存为电子版，既节约空间，又永不做旧。同样的，看过之后觉得喜欢的视频，最好也下载下来保存。</p>
<p>我比较偏爱剧情型的电子游戏，例如生化危机、战争机器。这种线性叙事的游戏，普通玩家一般只通关一遍，带来的乐趣是相当短暂的，可以买一些周边商品作为纪念，比如模型或手办。外出旅行应该拍照留念，如果不拍摄夜景，我觉得用手机就好，方便携带。</p>
<p>试想一下，未来某天我们走到柜子前，看到多本标注笔记的书籍和材料，学习过的视频光盘，各种模型手办时，必然会获得相当的满足感。当朋友来家做客看到这些东西，你也能指着某个模型或某张照片，畅谈当时的趣闻。</p>
<p>就从现在开始吧！下图是前些时候购买的英雄联盟2016周年纪念手办：</p>
<p><img src="https://i.loli.net/2021/09/18/yZxUWdot349lcPM.png" alt="1Jinx.png"></p>
<p>其实创建这个博客也有留念之意，将生活中学到的东西和感想总结于此，方便未来查阅。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>拼装积木</title>
    <url>/2019/12/15/%E6%8B%BC%E8%A3%85%E7%A7%AF%E6%9C%A8/</url>
    <content><![CDATA[<p>这里所说的拼装积木就是兼容乐高积木，对于成年人来说，乐高科技组还是颇具吸引力的，尤其是每年的旗舰版科技组。小时候，我对重型机械就有一种偏爱，每当路过附近的煤场，听到传送带和机器挤压蜂窝煤的声音，都会驻足看一会儿。父母也经常带我去附近工地看各种工程车施工，其中我最喜欢挖掘机。</p>
<p>对于一个没上小学的孩子，到底喜欢的是什么呢？我当时就是觉得这些机械有一种人类无法比拟的力量感，而且它们都是人类靠科学和技术创造出来的。如果自己能掌握这种创造力该有多了不起！</p>
<a id="more"></a>

<p>对于机械爱好者，乐高积木提供了一套简洁实现方案：采用一组通用结构件，依靠简单的原理，实现复杂的机械装置。虽然采用这种方式实现的机械效率较低，但拼接的成品比现实物品更具有“机械感”。</p>
<p>原装积木价格昂贵，一般都是通过购买某个模型获得零件。兼容积木价格便宜，在某宝上可以按需购买，但零件精度差了一点。有了零件理论上就可以搭建任何模型了，但是对于积木新手，往往不能将自己的想象力自由地发挥出来，需要参考一些资料。</p>
<p>我觉得比较不错的书籍有：《乐高科技系列搭建指南》、《乐高动力组创意搭建指南：车辆装置篇》、《<br>乐高动力组创意搭建指南：机械结构篇》，后两本是个日本人写的，几乎都是图片。除此之外，还可以到乐高官网<a href="https://www.lego.com/zh-cn">https://www.lego.com/zh-cn</a>下载图纸。下面是我按照《车辆装置篇》第59个创意组装的履带车：</p>
<p><img src="https://i.loli.net/2021/10/06/O7STKFVbLx25R9c.png" alt="1履带车.png"></p>
<p>电池盒内装六节5号电池，两个M型电机分别为两侧履带提供动力，每侧由4个齿轮传导动力到履带前轮。遥控器需要两节5号电池，使用说明如下：</p>
<p><img src="https://i.loli.net/2021/10/06/AhyS5mzdCRGqHgP.png" alt="2遥控器.png"></p>
<ol>
<li>红框内两侧黑色滑动开关分别用于反转A，B遥杆。</li>
<li>红框内中间4档开关控制信号频段，对应的接收机上也有4挡，只有两者频段一致方可遥控。</li>
</ol>
<h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ol>
<li>履带车转向方法：一条履带前转，一条履带后转。</li>
<li>科技组很少使用板砖，一般只使用条砖。</li>
<li>如果主要搭建工程车，尽量购买黄色或黑色的砖块。</li>
<li>机器人或工程车的关键在于机械设计，不在于电子设计。</li>
<li>由于只采用基本的结构件搭建模型，机械效率较低，零件的精度很影响设计体验。</li>
</ol>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Lego</category>
      </categories>
      <tags>
        <tag>Lego</tag>
      </tags>
  </entry>
  <entry>
    <title>学习51单片机四 串口</title>
    <url>/2011/10/03/%E5%AD%A6%E4%B9%A051%E5%8D%95%E7%89%87%E6%9C%BA%E5%9B%9B%20%E4%B8%B2%E5%8F%A3/</url>
    <content><![CDATA[<p>单片机的通信一般是指单片机与计算机，或与单片机之间的信息交换，有并行和串行两种方式。并行通信控制简单、相对传输速度快，但长距离传送时成本高且收、发方的各位同时接收存在困难；串行通信是按位将数据逐个传送，其优点是线路少成本低，可以利用现成线路，但传送控制比较复杂。</p>
<a id="more"></a>

<h4 id="串行通信概念"><a href="#串行通信概念" class="headerlink" title="串行通信概念"></a>串行通信概念</h4><p>串行通信分为异步串行通信和同步串行通信</p>
<ol>
<li>异步串行通信的发送与接收设备使用各自的时钟，以帧为单位进行传输，每帧之间的时间间隔是任意的。通常一帧由4部分组成：起始位、数据位、奇偶校验位和停止位。</li>
<li>同步串行通信要建立发送方时钟对接收方时钟的直接控制，使双方达到完全同步。</li>
</ol>
<p>串行通信的制式</p>
<ol>
<li>单工：仅能沿一个方向传输。</li>
<li>半双工：可以两个方向传输，但需要分时进行。</li>
<li>全双工：可以两个方向同时传输。</li>
</ol>
<p>错误校验</p>
<ol>
<li>奇偶校验：奇校验时，数据位和校验位中1的个数之和应是奇数；偶校验时，数据位和校验位中1的个数之和应是偶数。</li>
<li>代码和校验：发送前，对数据求和并以此生成一个字节的校验码，附加到数据末尾一同发送。接收后，对数据求和、生成校验码并以此与发送方校验码对比。</li>
<li>循环冗余校验</li>
</ol>
<h4 id="RS-232电平与TTL电平"><a href="#RS-232电平与TTL电平" class="headerlink" title="RS-232电平与TTL电平"></a>RS-232电平与TTL电平</h4><p>RS-232电平与TTL电平都是数字电路的电平，而数字电路只有高电平和低电平。单片机的串口为TTL电平，高电平为+5V，低电平为0V；计算机的串口为RS-232C，高电平为-12V，低电平为+12V。所以，计算机与单片机之间的通信需要转换芯片。</p>
<p>RS-232C接口标准</p>
<p><img src="https://i.loli.net/2020/09/11/6LXCd5PlQ43e9fv.png" alt="1插针.PNG"></p>
<blockquote>
<p>上图是插针序号，母头则左右颠倒。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">插针序号</th>
<th align="center">名称</th>
<th align="left">功能</th>
<th align="center">方向</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">DCD</td>
<td align="left">载波检测</td>
<td align="center">DCE-&gt;DTE</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">RXD</td>
<td align="left">接收数据（串行输入）</td>
<td align="center">DCE-&gt;DTE</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">TXD</td>
<td align="left">发送数据（串行输出）</td>
<td align="center">DTE-&gt;DCE</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DTR</td>
<td align="left">DTE就绪（数据终端准备就绪）</td>
<td align="center">DTE-&gt;DCE</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">GND</td>
<td align="left">信号地线</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">DSR</td>
<td align="left">DCE就绪（数据建立就绪）</td>
<td align="center">DCE-&gt;DTE</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">RTS</td>
<td align="left">请求发送</td>
<td align="center">DTE-&gt;DCE</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">CTS</td>
<td align="left">允许发送</td>
<td align="center">DCE-&gt;DTE</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">RI</td>
<td align="left">振铃指示</td>
<td align="center">DCE-&gt;DTE</td>
</tr>
</tbody></table>
<blockquote>
<p>DTE为数据终端设备，DCE为数据通信设备。</p>
</blockquote>
<p>电平转换芯片MAX232</p>
<p><img src="https://i.loli.net/2020/09/11/UIKtiDAkPNfoh4H.png" alt="2MAX232.PNG"></p>
<ol>
<li>C1+和C1-，C2+和C2-之间各需要连接一个0.1uF/16V电容。</li>
<li>V+与GND之间连接两个0.1uF电容；V-与GND之间连接一个0.1uF/16V电容。</li>
<li>$T1_{IN}$和$T2_{IN}$可直接连接单片机的串口发送端TXD。$T1_{OUT}$和$T2_{OUT}$可直接连接PC机的串口接收端RXD。</li>
<li>$R1_{IN}$和$R2_{IN}$可直接连接PC机串口的发送端TXD。$R1_{OUT}$和$R2_{OUT}$可直接连接单片机的串口接收端RXD。</li>
</ol>
<p>开发板中MAX232的连接方法</p>
<p><img src="https://i.loli.net/2020/09/11/cmUn3dxourCVqYp.png" alt="3串口连接.PNG"></p>
<ol>
<li>单片机发送信息：单片机TXD端——P3.1连接至MAX232的11脚$T1_{IN}$。MAX232的14脚$T1_{OUT}$连接至开发板串口座的第2脚。这个第2脚通过“交叉串口线”，连接至PC机串口的RXD端——第3脚。</li>
<li>PC机发送信息：PC机串口TXD端——第2脚通过“交叉串口线”连接置开发板串口座第3脚。这个第3脚连接至MAX232的$R1_{IN}$。MAX232的$R1_{OUT}$连接至单片机的RXD端——P3.0。</li>
</ol>
<blockquote>
<p>串口连接线是交叉线，2和3口对调，传输距离不超过15米。</p>
</blockquote>
<h4 id="单片机串口特性"><a href="#单片机串口特性" class="headerlink" title="单片机串口特性"></a>单片机串口特性</h4><p>51单片机串行口是一个可编程全双工接口，由两个独立的串行数据缓冲区、发送/接收控制器、输入移位寄存器等电路组成。</p>
<p>通过SCON来设置串口的工作方式，其字节地址为98H，可位寻址。单片机复位时SCON被清0。</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">工作方式</td>
<td align="center">工作方式</td>
<td align="center">多机控制</td>
<td align="center">接受允许</td>
<td align="center">发送第9位</td>
<td align="center">接收第9位</td>
<td align="center">发送中断</td>
<td align="center">接收中断</td>
</tr>
<tr>
<td align="center">SM0</td>
<td align="center">SM1</td>
<td align="center">SM2</td>
<td align="center">REN</td>
<td align="center">TB8</td>
<td align="center">RB8</td>
<td align="center">TI</td>
<td align="center">RI</td>
</tr>
</tbody></table>
<p>串行口有4种工作方式：</p>
<table>
<thead>
<tr>
<th align="center">SM0</th>
<th align="center">SM1</th>
<th align="center">方式</th>
<th align="left">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="left">同步移位寄存器方式</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="left">10位异步收发（8位数据），波特率可变（T1溢出率控制）</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="left">11位异步收发（9位数据），波特率固定</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="left">11位异步收发（9位数据），波特率可变（T1溢出率控制）</td>
</tr>
</tbody></table>
<ol>
<li>SM2主要用于方式2和方式3。当接收机的SM2=1时：RB8=1，数据进入SBUF并中断RI置1；RB8=0，数据丢弃不中断。SM2=0时，无论RB8为何值，数据均进入SBUF并中断RI置1。方式0时，SM2必须为0。方式1时，SM2=1，则只在接收到有效停止位时，RI才置1。</li>
<li>REN为1允许串口接收数据；为0禁止串口接收数据。</li>
<li>TB8方式2、3中发送数据的第9位，可以用软件规定其作用。可以用作数据奇偶校验或标志位。方式0、1中未使用。</li>
<li>RB8方式2、3中接收数据的第9位，可以用作数据奇偶校验或标志位。方式1时，若SM2=0，RB8是接收到的停止位。</li>
<li>在方式0时，当串口发送第8位结束时，或其他方式，串口发送停止位的开始时，TI自动置1并发出中断。在中断服务程序中，必须手动清0。</li>
<li>在方式0时，当串口接收第8位结束时，或其他方式，串口接收停止位的中间时，RI自动置1并发出中断。同样必须手动清0。</li>
</ol>
<h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><p>方式1通信，一帧10位：起始位0、8位数据、停止位1。数据传送时，低位在前，高位在后。串口通信的速率用波特率表示。<strong>波特率</strong>为每秒传输二进制的位数，即1波特=1位/秒，单位是bps（位/秒）。</p>
<p>方式1波特率的计算方式：</p>
<ol>
<li>方式0的波特率=$f_{osc}/12$</li>
<li>方式1的波特率=$(2^{SMOD}/32)$×(T1溢出率)</li>
<li>方式2的波特率=$(2^{SMOD}/64)$×$f_{osc}$</li>
<li>方式3的波特率=$(2^{SMOD}/32)$×(T1溢出率)</li>
</ol>
<blockquote>
<p>$f_{osc}$为晶振频率，通常为11.0592MHz。SMOD是PCON的最高位。T1溢出率为定时器T1溢出的频率。</p>
</blockquote>
<p>电源管理寄存器PCON，字节地址为87H，不能位寻址。单片机复位时全部清0。</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SMOD</td>
<td align="center">(SMOD0)</td>
<td align="center">(LVDF)</td>
<td align="center">(P0F)</td>
<td align="center">GF1</td>
<td align="center">GF0</td>
<td align="center">PD</td>
<td align="center">IDL</td>
</tr>
</tbody></table>
<blockquote>
<p>SMOD=0时，串口方式1、2、3波特率一般；SMOD=1时，串口方式1、2、3波特率加倍。其余位在串口通信中用不到。</p>
</blockquote>
<p>如上所述，方式1的波特率决定于T1的溢出率，只要计算出T1每溢出一次的时间，那么这个时间的倒数即是它的溢出率。为了尽量使传输速率精确，我们采用T1定时器的方式2来自动装填TH1和TL1。定时器每$2^8$-X个计数溢出一次，每个计数时间为1个机器周期，1个机器周期等于12个时钟周期，所以1个计数时间为12/11.0592s。将T1溢出率代入“方式1”公式得到波特率：$(2^{SMOD}/32)\times (256−X)×12\div 11.0592$。</p>
<blockquote>
<p>通常波特率都是取1200、1800、2400、3600、4800、7200、9600、14400、19200等，当晶振频率为11.0592时，求X都能得到整数。</p>
</blockquote>
<p>例：计算机与单片机串口通信</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line">uchar flag, ch, i;</span><br><span class="line">uchar code str[] = <span class="string">&quot;answer:&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TMOD = <span class="number">0x20</span>;</span><br><span class="line">    TH1 = <span class="number">0xfd</span>;     <span class="comment">//9600bps</span></span><br><span class="line">    TL1 = <span class="number">0xfd</span>;</span><br><span class="line">    TR1 = <span class="number">1</span>;        <span class="comment">//打开定时器1</span></span><br><span class="line"></span><br><span class="line">    SM0 = <span class="number">0</span>;        <span class="comment">//串口方式1</span></span><br><span class="line">    SM1 = <span class="number">1</span>;</span><br><span class="line">    REN = <span class="number">1</span>;        <span class="comment">//打开串口</span></span><br><span class="line"></span><br><span class="line">    EA = <span class="number">1</span>;         <span class="comment">//打开串口中断</span></span><br><span class="line">    ES = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//收到一个字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            ES = <span class="number">0</span>;   <span class="comment">//关闭串口中断，一个一个字符的处理</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="comment">//发送7个字符</span></span><br><span class="line">            &#123;</span><br><span class="line">                SBUF = str[i];  <span class="comment">//发送1个字符</span></span><br><span class="line">                <span class="keyword">while</span>(!TI);     <span class="comment">//没使用中断发送方式</span></span><br><span class="line">                TI = <span class="number">0</span>;         <span class="comment">//TI复位，准备发送下一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            SBUF = ch;          <span class="comment">//接收的那个字符，也发送过去</span></span><br><span class="line">            <span class="keyword">while</span> (!TI);        <span class="comment">//判断是否发送完成</span></span><br><span class="line">            TI = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            ES = <span class="number">1</span>;             <span class="comment">//打开串口中断</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> interrupt 4</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RI = <span class="number">0</span>;     <span class="comment">//中断标志复位</span></span><br><span class="line">    ch = SBUF;  <span class="comment">//单片机获取一个字节</span></span><br><span class="line">    flag = <span class="number">1</span>;   <span class="comment">//接到数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们通过“串口调试助手”，在计算机上接收/发送数据。串口调试助手会占用当前串口，所以在下载程序到单片机时，应解除其对串口的占用。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/09/11/1PxkT3jFgzf7iDd.png" alt="4串口调试助手.PNG"></p>
<h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ol>
<li>定时器和串口通信都可以在不开中断的情况下，靠检测标志位的方式工作，如此就避免了写中断处理函数。</li>
<li>在设置好控制端口后，给SBUF赋值或SBUF赋值给某个变量，进行串口数据传输。使用while或if语句来判断RI、TI的值，以确定完成1个字节的接收/发送。</li>
</ol>
]]></content>
      <categories>
        <category>51Chip</category>
      </categories>
      <tags>
        <tag>51Chip</tag>
      </tags>
  </entry>
  <entry>
    <title>组网基本思路</title>
    <url>/2013/08/03/%E7%BB%84%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol>
<li>确定办公设备数，包括服务器、办公计算机、打印机、复印机等。</li>
<li>确定交换机、路由器、行为管理器、防火墙等网络设备的数量和品牌。<a id="more"></a>

</li>
</ol>
<h4 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h4><ol>
<li>根据上述信息确定网络拓扑结构并确定IP。</li>
<li>交换机和路由器，中国一般公司更倾向于选用华为产品（思科太贵）。行为管理器和防火墙视情况而定。</li>
<li>服务器可选用IBM或Dell的产品，由于服务器都是定制的，所以提前一定计划好用途和预算。</li>
</ol>
<h4 id="施工"><a href="#施工" class="headerlink" title="施工"></a>施工</h4><ol>
<li>公司拓扑结构按层划分，顶层使用高端一点的三层交换机。一般公司购买两个足以应对日常应用。在主交换机上用光纤连接各竖井中的二层交换机和各服务器，并做好编号工作。</li>
<li>二层交换机的串联可用光纤或六类双绞线，剩余接口可用普通超五类双绞线连接各办公场所墙壁智能模块，同样需要做好标记。</li>
<li>把重要设备，比如服务器连接到高速网口。</li>
<li>根据实际情况安装UPS。</li>
</ol>
<blockquote>
<p>单段超五类网线不得超过100米。<br>超五类传输速率100Mb/s，六类传输速率1000Mb/s，超五类不能真正实现千兆性能。<br>半径50米内，部署不超过3个AP。<br>一定要保留一些接口用于扩充或替换。<br>不要把高负荷的设备都连接到同一个交换机上，应均衡负载。<br>监控独立建网，避免未来与安保部门间的纠缠不清。</p>
</blockquote>
<h4 id="设备设置"><a href="#设备设置" class="headerlink" title="设备设置"></a>设备设置</h4><p>一、华为交换机设置<br>显示设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dis cu</span><br><span class="line">dis vlan</span><br></pre></td></tr></table></figure>
<p>端口隔离</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#S9300</span><br><span class="line">&lt;Quidway&gt; system-view</span><br><span class="line">[Quidway] interface gigabitethernet 1&#x2F;0&#x2F;1</span><br><span class="line">[Quidway-GigabitEthernet1&#x2F;0&#x2F;1] port-isolate enable</span><br><span class="line"></span><br><span class="line">#S2300</span><br><span class="line">&lt;Quidway&gt; system-view</span><br><span class="line">[Quidway] interface ethernet 0&#x2F;0&#x2F;1</span><br><span class="line">[Quidway-Ethernet0&#x2F;0&#x2F;1] port-isolate enable</span><br></pre></td></tr></table></figure>
<p>VLAN划分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#S9300</span><br><span class="line">&lt;Quidway&gt; system-view</span><br><span class="line">[Quidway] vlan 2</span><br><span class="line">[Quidway-vlan2] quit</span><br><span class="line"></span><br><span class="line">[Quidway] interface gigabitethernet 1&#x2F;0&#x2F;1</span><br><span class="line">[Quidway-GigabitEthernet1&#x2F;0&#x2F;1] port link-type trunk</span><br><span class="line">[Quidway-GigabitEthernet1&#x2F;0&#x2F;1] port trunk allow-pass vlan 2</span><br><span class="line">[Quidway-GigabitEthernet1&#x2F;0&#x2F;1] quit</span><br><span class="line"></span><br><span class="line">#S2300</span><br><span class="line">&lt;Quidway&gt; system-view</span><br><span class="line">[Quidway] vlan 2</span><br><span class="line">[Quidway-vlan2] quit</span><br><span class="line"></span><br><span class="line">[Quidway] interface ethernet 0&#x2F;0&#x2F;1</span><br><span class="line">[Quidway-Ethernet0&#x2F;0&#x2F;1] port link-type trunk</span><br><span class="line">[Quidway-Ethernet0&#x2F;0&#x2F;1] port trunk allow-pass vlan 2</span><br><span class="line">[Quidway-Ethernet0&#x2F;0&#x2F;1] quit</span><br></pre></td></tr></table></figure>
<p>VLAN建立和删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vlan id</span><br><span class="line">vlan batch id to id...</span><br><span class="line">undo vlan id   #其下有端口也可以直接删除，那个端口会回到vlan1（默认）。</span><br></pre></td></tr></table></figure>
<p>删除VLAN下的端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ethernet 0&#x2F;0&#x2F;1</span><br><span class="line">undo port trunk allow-pass vlan id...(id to id)</span><br></pre></td></tr></table></figure>
<ul>
<li>Access访问：只能属于一个VLAN，其默认VLAN就是它加入的VLAN,修改时，就是修改默认VLAN。</li>
<li>Trunk中继：可以属于多个VLAN。</li>
<li>Hybrid混合：可以属于多个VLAN，Trunk必须先转成Access，再改为Hybrid。</li>
</ul>
<p>二、管理系统的部署<br>一般都是关联数据库的程序，基本功能就是对增删改查的封装，关键在于理解企业的管理流程和公司高层的意图。</p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>双绞线(Twisted-Pair)，RJ45头。线序：<br>568A：白绿 绿 白橙 蓝 白蓝 橙 白棕 棕<br>568B：白橙 橙 白绿 蓝 白蓝 绿 白棕 棕</p>
<p>标签格式：地点-楼层-竖井-编号。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员感悟</title>
    <url>/2015/09/26/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>记得在大学刚毕业时，面试了一堆企业，总是围绕着“有强烈兴趣”来讲，把自己表现的像不给工资都能拼死干的样子。在那个年头，经济危机才刚开始，不是清华、北大…、没有实际工作经验的学生恐怕找非销售类工作都是这样的，尤其是找个编程岗位！</p>
<a id="more"></a>

<p>印象里，那时面试官的态度就跟你“再生父母”似的，以上势下，各种刁难，好像从事了这个行业就能发财，就能光宗耀祖（当时就想揍他几拳:P）。后来看了张绍刚的节目，发现这已经成为社会普遍现象了，至少小企业老板们想推动这种风气。其实有工作经验的人都明白，对于这种二三十号人的startup企业，只要有点基础认真干上半年就能在那充专家了，而这些startup企业只能靠画大饼来报答你。每次老板请我单独吃饭（弄两个“拌凉菜…”）都想婉言拒绝，心里想啊——不知道老板又出什么妖蛾子×_×大家注意，这只是想想，不敢不去啊。所以说即使你知道画饼人的目的，但你还是得把这个“饼”吃下去，而且还要表现得好吃、爱吃ToT再后来……就没有后来了，老板在作最后的垂死挣扎（乱开项目，需求朝令夕改，工资迟发、少发…）后，毫无悬念的消失了。此刻大家才注意到，开一家startup互联网软件作坊是真的简单——写字楼房间是租的，一堆廉价隔断和桌椅，30多台计算机而已，日常成本就是房租、水电费和工资。这些成本中占比最大的就是工资，自然就成为了老板每月最不想面对的开支！所以当企业出现问题，老板做出各种违约行为一点也不奇怪。</p>
<p>之后也进过一些大企业，工作比较乏味，晋升机制跟国家机关比也强不了多少，好在企业比较稳，不会因为抱怨几句就被当作异端。一路走来总的感觉是编程不适合作为一项职业，特别是大龄青年，倒不是因为竞争不过年轻人，主要是觉得太累，一方面要照顾到领导的情绪，一方面又不忍心对下属太狠（毕竟自己也是从那过来的），而自身又要去从事编码（有人说这是脱不了干活的胎）。另外这个行业女性比例太低，仅有的几个也是够看的，其中有个同事，我们一直不知道他的性别，看着是男的，感觉是女的，从说话声音也听不出来，为此我们研究了好久，直到我离开那个公司都没弄清楚，也算是个遗憾了:)</p>
<p>所以这个行业的人在积累一定的经济基础后，往往会想尝试一些更有趣味的人生，但又有几个人能真正成功摆脱这样的人生呢？很多人都是想想就算了，或者迈出一步或几步后又回来了。最狠的人是离开了这个坑，但又跳入了另一个坑，然后就在那个坑里待下去了。我觉的要想真正的解脱出来，其实面对的问题和其他行业一样，就是努力奔向财富自由，提前退休。最直接的方法还是得靠投资理财。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>高达模型制作</title>
    <url>/2019/09/15/%E9%AB%98%E8%BE%BE%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>所谓高达GUNDAM模型，其实就是拼装模型的一种。本人对于高达没有任何情怀，没看过动画，也没玩过“高达”主题的游戏，只是少年时期听说过而已。上大学后，玩过很多“超级机器人大战”游戏，发现其中很多机体来自高达，才意识到高达设定对于日本机战题材作品（漫画、游戏、动漫）的深远影响。</p>
<a id="more"></a>

<p>我是玩变形金刚过来的，老实说高达众多机体的造型虽自成体系，但过于雷同，有些只是换色而已，而且造型并不太符合当前的大众审美。动画的主角——“高达型”机体过于拟人化，武士头雕与过于纤细的身材，没有充满力量的机械感。在尝试拼装了一盒MG龟霸（BANDAI）之后，个人感觉是体验到了高达拼装模型的一些特色：</p>
<ol>
<li>具有一定的内构。在制作过程中，有制作机械人的感觉。</li>
<li>精准的模具。这是最让人赞叹的，各种琐碎零件的卡扣都能准确的扣合，不存在合不拢、扣不住、错位等现象。可能有人觉得这没什么，模型就应该这样，但作为一个工作多年的人，我觉得这很了不起。在中国，即使某些大厂制作出来的东西，比如某些机加工零配件，两个螺丝孔，拧上一个，另一个孔就对不上了……</li>
<li>具有基本的可动性。很多高达机体在制作后，出现松垮、掉件的情况，这很让人沮丧，但模型毕竟不是玩具，禁不住把玩是在意料之内的，要知道其他大多数模型都没什么可动性，而且同样不结实。</li>
<li>丰富的颜色。即使不喷漆也有模有样，这点可比军模体贴太多了。</li>
</ol>
<h4 id="MG龟霸"><a href="#MG龟霸" class="headerlink" title="MG龟霸"></a>MG龟霸</h4><p>结构紧实，内构精细，可动优秀，自带支架和特效件。右手爪子有弹簧机关，左手鱼雷可插特效件。胳膊、大腿、肩部可伸缩，可谓万代良心。</p>
<p><img src="https://i.loli.net/2021/11/07/g9wWr4pbnzEaJ8s.png" alt="1龟霸.png"></p>
<h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ol>
<li><p>按照自己的想法和需求制作一台模型。觉得水口没什么就不要修，懒得贴纸就不要贴。你制作的模型就是你的机体，这些细节就算是你独有的特色。</p>
</li>
<li><p>工欲善其事，必先利其器。有了工具能让拼装工作更容易一点，成品更好一点。现列举一些基本工具如下：</p>
<ul>
<li>剪钳。这是最重要的，如果是情怀玩家，打算将制作模型作为一项兴趣爱好来培养，买一把“神之手”剪钳不算奢侈。一般的玩家最好也买一把单刃剪钳。单刃剪钳虽然锋利，但比较娇气，掉落或大力磕碰可能断裂。使用时也不要沾湿或直接用手擦，否则容易生锈。</li>
<li>打磨。即使用神之手，水口还是会有的，推荐用砂纸、打磨板、打磨块。砂纸购买600目和1000目的。600目砂纸消耗较大，所以尽量购买质量好一点的。打磨板建议使用5mm、10mm宽的。1000目砂纸和打磨块用于消除刮痕。如果经费富裕，也可以购买同样目数的海绵砂纸，用于打磨弧状零件的水口。</li>
<li>镊子。用于粘贴纸。万代贴纸有胶贴、刮贴、水贴、铝箔贴纸。<strong>胶贴</strong>最常见，塑料材质不怕水，黏贴时沾水，用镊子夹起一角，从一边滚动张贴。<strong>刮贴</strong>最优秀，但张贴后无法调整，可用胶带固定贴纸，确定位置合适后，用牙签或指甲刮，确保每个细节都刮到位后，揭下胶带即可看到结果。<strong>水贴</strong>效果介于胶贴和刮贴之间，但万代水贴粘附力很弱，干透后容易翘起。<strong>铝箔贴纸</strong>怕水。</li>
<li>小号螺丝刀。有些模型需要螺丝固定。</li>
</ul>
</li>
<li><p>不建议买仿品。在仿制方面，变形金刚做的更好，有些仿品素质比原品还要优秀，而且价格还便宜。高达模型的仿品都不太好，基本和万代没法比。仿品零件的拼装完全让人体会不到前面说的那些优点，在我看来，钱等于全部浪费了。</p>
</li>
<li><p>如果你对高达没有情怀，或者对于高达模型机设提不起兴趣，就一定不要跟风买入。否则就像办健身年卡一样，买之前想的很好，去了没两次就撇一边了——“烂尾的模型 + 一段时间 = 垃圾”。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Toy</category>
        <category>Gundam</category>
      </categories>
      <tags>
        <tag>Gundam</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 常用控件</title>
    <url>/2015/07/31/VC%E7%BC%96%E7%A8%8B%20%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p>通常，程序需要与用户交互，对于程序来说就是数据的输入输出。控件就是MFC程序输入输出的媒介，用户通过控件输入信息，程序通过控件关联的代码获取数据、处理数据、输出结果。</p>
<p>对话框是所有控件的载体。在资源视图中，点击右侧工具箱中的控件，再在对话框中将其画出。选中控件，在右边栏属性框中可以对控件资源样式进行设置。</p>
<p>立即编译即可看到控件的样子。此时控件是无效的，我们需要根据目标功能，绑定控件资源到特定类、函数、变量，然后对这些数据进行处理以实现目标功能。MFC编程的主要工作就在于此。</p>
<a id="more"></a>

<h4 id="按钮（Button）"><a href="#按钮（Button）" class="headerlink" title="按钮（Button）"></a>按钮（Button）</h4><p>在直觉上按钮的作用就是执行某些命令，通常对其添加响应函数。这个响应函数响应的是BN_CLICKED消息。我们用鼠标双击按钮控件即可添加函数，并立即跳到响应函数代码处。也可以在类向导中添加响应函数，选择对话框类，找到按钮的ID，选择BN_CLICKED消息，点击添加处理程序按钮。</p>
<blockquote>
<p>添加按钮资源后，可以修改其ID，以区分不同按钮。通常，其他控件的ID也应该修改为有实际意义的名字。</p>
</blockquote>
<p>如果想要对按钮控件本身进行设置，需要为其关联一个CButton对象。对这个对象的任何操作就是对按钮的操作。</p>
<blockquote>
<p>在右边栏的属性框中，Default button项选择True，当用户回车时默认点击此按钮。</p>
</blockquote>
<p>因为CButton是CWnd的派生类，因此使用CButton对象可以访问CWnd的成员函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_Button.EnableWindow(FALSE); <span class="comment">//TRUE显示按钮，FALSE灰化按钮。</span></span><br></pre></td></tr></table></figure>
<h4 id="静态控件（Static-Text）和组框（Group-box）"><a href="#静态控件（Static-Text）和组框（Group-box）" class="headerlink" title="静态控件（Static Text）和组框（Group box）"></a>静态控件（Static Text）和组框（Group box）</h4><p>这两个控件主要用于在对话框中显示文本，很少遇到操作它们的情况，所以它们的默认ID同为IDC_STATIC。</p>
<p>静态控件的属性项Simple选择False，才能多行显示文本。当Simple为False时，再设置No Wrap项为False，文本将根据Static控件范围自动多行显示。</p>
<p>如果想让静态控件响应消息，可以更改其ID，将属性项Notify设置为True。然后，在类向导中选中ID，在右侧就可以看到能够响应的消息。</p>
<h4 id="编辑框（Edit-Control）"><a href="#编辑框（Edit-Control）" class="headerlink" title="编辑框（Edit Control）"></a>编辑框（Edit Control）</h4><p>编辑框可以接收用户的文本输入，也可以显示计算的结果。比较有用的属性项：Multiline、Want return、Password、Read-only、Horizontal scroll、Vertical scroll。</p>
<p>编辑框可以关联两种类型的变量，分别为CString和CEdit。如果侧重于处理数据，关联CString变量较为方便；如果侧重于控件设置，关联CEdit较为方便。</p>
<p>CString变量与编辑框的数据交换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UpdateData(TRUE);   <span class="comment">//控件-&gt;变量</span></span><br><span class="line">UpdateData(FALSE);  <span class="comment">//变量-&gt;控件</span></span><br></pre></td></tr></table></figure>
<p>CEdit变量与编辑框的数据交换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_Edit.GetWindowText(CString);  <span class="comment">//获得编辑框文本</span></span><br><span class="line">m_Edit.SetWindowText(CString);  <span class="comment">//设置编辑框文本</span></span><br></pre></td></tr></table></figure>
<h4 id="单选按钮（Radio-Button）"><a href="#单选按钮（Radio-Button）" class="headerlink" title="单选按钮（Radio Button）"></a>单选按钮（Radio Button）</h4><p>同一个对话框中，添加的所有单选按钮默认是互斥的。如果想要建立多组互斥，需要保证每组Tab号连续，并将每组Tab序第一的单选按钮的属性Group置为True。</p>
<blockquote>
<p>Tab号从1计数，显示方法：在资源视图下，选中对话框，按下Ctrl+D。Tab号可以通过点击控件左上角数字的先后来更改。</p>
</blockquote>
<p>操作单选按钮可以直接通过其ID，而不关联任何变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化部分</span></span><br><span class="line">CheckRadioButton(IDC_RADIO1,IDC_RADIO3,IDC_RADIO1);    <span class="comment">//参数1、2为首尾ID，参数3为默认选中</span></span><br><span class="line"><span class="comment">//操作部分</span></span><br><span class="line"><span class="keyword">int</span> i = GetCheckedRadioButton(IDC_RADIO1,IDC_RADIO3);  <span class="comment">//参数为首尾ID</span></span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IDC_RADIO1:</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;第一&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IDC_RADIO2:</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;第二&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IDC_RADIO3:</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;第三&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然还可以通过关联变量的方法来操作一组单选按钮。只有Group设置为True的单选按钮才能正常关联两种类型的变量，分别为Bool、int和CButton。</p>
<p>一、将组中第一个单选按钮关联int变量。这个变量会自动在对话框构造函数中被初始化为0，这表示第一个按钮被选中。为1表示第二个单选按钮被选中，以此类推（为-1表示都不选中）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UpdateData(TRUE);</span><br><span class="line"><span class="keyword">switch</span> (m_radio1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;第一&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;第二&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;第三&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_radio1 = <span class="number">0</span>;	<span class="comment">//复位到第一个控件</span></span><br><span class="line">UpdateData(FALSE);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将控件关联Value型变量都可以使用UpdateData进行数据交换。</p>
</blockquote>
<p>二、将每个单选按钮的Group都置为True，然后都关联CButton变量。通过变量调用如下两个成员函数来设置、获取单选控件的状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetCheck</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//BST_UNCHECKED未选中状态，BST_CHECKED选中状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCheck</span><span class="params">()</span></span>;     <span class="comment">//返回上述两个状态之一</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论采用哪种方法，在一个对话框中设置多组单选按钮，都需要将每组第一个单选控件的Group置为True。</p>
</blockquote>
<h4 id="复选框（Check-Box）"><a href="#复选框（Check-Box）" class="headerlink" title="复选框（Check Box）"></a>复选框（Check Box）</h4><p>复选框可以关联两种类型变量，分别为BOOL和CButton。对应于关联的变量类型有两种操作方法：<br>一、每个复选框都关联BOOL变量，用UpdateData获取状态。如果关联的变量值为TRUE，说明此复选框被勾选，否则相反。<br>二、每个复选框都关联CButton变量，用SetCheck和GetCheck来设置获取状态。</p>
<p>例如，将m_tianjin和m_beijing关联BOOL变量，m_shanghai关联CButton变量，操作代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Updatedata(TRUE);</span><br><span class="line">CString str;</span><br><span class="line"><span class="keyword">if</span> (m_tianjin == TRUE)</span><br><span class="line">    str += <span class="string">&quot;天津&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (m_beijing == TRUE)</span><br><span class="line">    str += <span class="string">&quot;北京&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (m_shanghai.GetCheck() == BST_CHECKED)</span><br><span class="line">    str += <span class="string">&quot;上海&quot;</span>;</span><br><span class="line">AfxMessageBox(str);</span><br></pre></td></tr></table></figure>
<h4 id="列表框（List-box）"><a href="#列表框（List-box）" class="headerlink" title="列表框（List box）"></a>列表框（List box）</h4><p>列表框显示一个字符串列表，用户可以选中其中的某行字符。列表框比较有用的属性项：Sort自动排序、Notify响应消息、Vertical Scroll垂直滚动条、Horizontal Scroll水平滚动条。</p>
<p>列表框可以关联两种类型变量，分别为CString和CListBox。通常关联CListBox变量来操作列表框，可以调用的函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AddString(CString);         <span class="comment">//添加字符串到列表框</span></span><br><span class="line">InsertString(n,CString);    <span class="comment">//在索引n处插入，-1表示在末尾</span></span><br><span class="line">DeleteString(n);            <span class="comment">//删除索引n处的字符串</span></span><br><span class="line">GetCurSel();                <span class="comment">//得到选中字符串的索引，如果没有选中的项返回LB_ERR</span></span><br><span class="line">GetText(n,CString);         <span class="comment">//把索引为n的字符串复制到CString</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>列表框索引从0开始</p>
</blockquote>
<p>如果需要在列表框中选择多项，可以把关联的变量类型手动更改为CCheckListBox。它派生于CListBox，使用CCheckListBox对象添加的条目前会有一个复选框。</p>
<h4 id="组合框（Combo-box）"><a href="#组合框（Combo-box）" class="headerlink" title="组合框（Combo box）"></a>组合框（Combo box）</h4><p>组合框组合了编辑框、下拉、列表框的功能。组合框的Type属性项可以选择：DropDown（默认）可编辑，下拉列表；DropList不可编辑，下拉列表；Simple可编辑，列表部分总可见。在Data属性项中，可以输入初始化列表项，多行用分号分隔。</p>
<blockquote>
<p>组合框的尺寸比较特殊，显示与实际占用大小不同。调整方法也很特殊：选择控件，单击组合框的三角箭头，然后拖动虚边框下边的黑块。</p>
</blockquote>
<p>组合框可以关联三种类型变量，分别为int、CString和CComboBox。通常关联CComboBox变量来操作组合框，可以调用函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AddString(CString);        <span class="comment">//添加列表项到组合框，添加到data属性内容之后。</span></span><br><span class="line">InsertString(n,CString);   <span class="comment">//向下拉列表中指定位置插入元素，从0开始。</span></span><br><span class="line">DeleteString(n);           <span class="comment">//删除n处的列表项，从0计数。</span></span><br><span class="line">GetCout();                 <span class="comment">//返回列表项总数</span></span><br><span class="line">GetCurSel();               <span class="comment">//返回当前选中列表项的索引值，不选为-1。</span></span><br><span class="line">SetCurSel(n);              <span class="comment">//设置n项显示在编辑框中</span></span><br><span class="line">FindString(n,CString);     <span class="comment">//从第n项开始在列表中查找指定字符返回索引，查找失败返回CB_ERR。</span></span><br><span class="line">GetLBText(n,&amp;CString);     <span class="comment">//获得第n项文本到&amp;CString</span></span><br><span class="line">GetLBTextLen(n);           <span class="comment">//返回第n项文本长度</span></span><br></pre></td></tr></table></figure>
<p>获取指定项的文本有点麻烦，记录如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString str;</span><br><span class="line"><span class="keyword">int</span> i = m_Combo.GetLBTextLen(<span class="number">0</span>);        <span class="comment">//获取第0项的文本长度</span></span><br><span class="line">m_Combo.GetLBText(<span class="number">0</span>,str.GetBuffer(i));  <span class="comment">//获取第0项文本到str</span></span><br><span class="line">str.ReleaseBuffer();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>组合框的操作函数与列表框类似</p>
</blockquote>
<h4 id="进度条（Progress-Control）"><a href="#进度条（Progress-Control）" class="headerlink" title="进度条（Progress Control）"></a>进度条（Progress Control）</h4><p>进度条通常用来显示时间进度。通过设置Smooth属性项，可以将进度平滑显示。进度条只能关联控件变量，类型为CProgressCtrl。通过关联的变量可以调用如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SetRange(Lower,Upper);    <span class="comment">//设置进度条范围</span></span><br><span class="line">SetPos(n);                <span class="comment">//设置当前进度条位置</span></span><br><span class="line">SetStep(n);               <span class="comment">//设置进度条前进步长，返回原步长</span></span><br><span class="line">StepIt();                 <span class="comment">//按SetStep设定的步长增1</span></span><br><span class="line">OffsetPos(n);             <span class="comment">//以n作为步长增1</span></span><br></pre></td></tr></table></figure>
<p>范围、起点、步长在初始化时设定，实际增量进度条使用StepIt和OffsetPos，每运行一次，进度条按照设定的步长增1。在实际项目中，可根据实际情况获得范围，设定步长，并按照实际情况运行步进函数。</p>
<h4 id="滑块（Slider-Control）"><a href="#滑块（Slider-Control）" class="headerlink" title="滑块（Slider Control）"></a>滑块（Slider Control）</h4><p>滑块给用户提供了一个调整连续状态的直接感受。通过属性项point，可以设置滑块的形状。如果要显示刻度，需要将属性项Auto Ticks和Tick Marks设置为True。</p>
<p>滑块可以关联两种类型变量，分别为int和CSliderCtrl。通过关联的控件变量可以调用如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SetRange(min,max,<span class="keyword">bool</span>); <span class="comment">//滑块范围min-max，bool默认为false。</span></span><br><span class="line">SetTicFreq(n);          <span class="comment">//设置刻度</span></span><br><span class="line">GetPos();               <span class="comment">//返回滑块当前位置</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>滑块移动的实际粒度是1</p>
</blockquote>
<p>范围、刻度在初始化时设定，然后让滑块控件响应NM_CUSTOMDRAW消息。在消息处理函数中通过GetPos获得滑块位置代表的数值。</p>
<h4 id="IP控件（IP-Address-Control）"><a href="#IP控件（IP-Address-Control）" class="headerlink" title="IP控件（IP Address Control）"></a>IP控件（IP Address Control）</h4><p>IP控件用于接收用户输入的IP地址。IP控件可以关联两种类型变量，分别为DWORD和CIPAddressCtrl。通过关联的控件变量可以调用如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IsBlank();                    <span class="comment">//如果4个域都为空，返回非零</span></span><br><span class="line">SetAddress(n0,n1,n2,n3);      <span class="comment">//4个参数类型为BTYE，设置IP控件4个域的值</span></span><br><span class="line">SetFieldRange(n,Lower,Upper); <span class="comment">//设置n域的范围Lower-Upper（BTYE）</span></span><br><span class="line">GetAddress(&amp;n0,&amp;n1,&amp;n2,&amp;n3);  <span class="comment">//获得4个域的值，返回非空域的数量</span></span><br></pre></td></tr></table></figure>
<p>设置IP与获取IP</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BYTE a1, a2, a3, a4;</span><br><span class="line">CString IP;</span><br><span class="line"><span class="keyword">if</span> (m_IPAddress.IsBlank() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_IPAddress.GetAddress(a1,a2,a3,a4);</span><br><span class="line">    IP.Format(<span class="string">&quot;%d.%d.%d.%d&quot;</span>,a1,a2,a3,a4);</span><br><span class="line">    AfxMessageBox(IP);</span><br><span class="line">&#125;</span><br><span class="line">a1 = <span class="number">192</span>;</span><br><span class="line">a2 = <span class="number">168</span>;</span><br><span class="line">a3 = <span class="number">1</span>;</span><br><span class="line">a4 = <span class="number">1</span>;</span><br><span class="line">m_IPAddress.SetAddress(a1,a2,a3,a4);</span><br></pre></td></tr></table></figure>
<h4 id="列表控件（List-Control）"><a href="#列表控件（List-Control）" class="headerlink" title="列表控件（List Control）"></a>列表控件（List Control）</h4><p>列表控件比较复杂，不像之前那些用于接收用户输入的控件，它主要用于输出，以“表”的形式显示结果。属性项View有四种样式：Icon、Small Icon、List、Report，其中的Report最适合显示表结构。列表控件只能关联CListCtrl变量，可以调用如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GetItemCount();                    <span class="comment">//得到项数</span></span><br><span class="line">SetExtendedStyle(styles);          <span class="comment">//设置样式</span></span><br><span class="line">InsertColumn(no,name,model,width); <span class="comment">//设置一列的列头，从0计数，width缺省为-1</span></span><br><span class="line">InsertItem(row,CString);           <span class="comment">//在第row行第一个字段插入字符</span></span><br><span class="line">SetItemText(row,n,CString);        <span class="comment">//在第row行第n个字段插入字符</span></span><br><span class="line">GetNextItem(<span class="number">-1</span>,nflag);             <span class="comment">//返回具有nflag属性的行号</span></span><br><span class="line">DeleteItem(n);                     <span class="comment">//删除第n行</span></span><br></pre></td></tr></table></figure>
<p>styles可以取值：</p>
<ul>
<li>LVS_EX_GRIDLINES 显示网格线</li>
<li>LVS_EX_FULLROWSELECT 列选择</li>
</ul>
<p>model可以取值：</p>
<ul>
<li>LVCFMT_LEFT</li>
<li>LVCFMT_CENTER</li>
<li>LVCFMT_RIGHT</li>
</ul>
<p>初始化列头和样式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_ListCtrl.SetExtendedStyle(LVS_EX_GRIDLINES|LVS_EX_FULLROWSELECT);</span><br><span class="line">m_ListCtrl.InsertColumn(<span class="number">0</span>,<span class="string">&quot;学号&quot;</span>,LVCFMT_CENTER,<span class="number">80</span>); <span class="comment">//设置表头</span></span><br><span class="line">m_ListCtrl.InsertColumn(<span class="number">1</span>,<span class="string">&quot;姓名&quot;</span>,LVCFMT_CENTER,<span class="number">80</span>);</span><br><span class="line">m_ListCtrl.InsertColumn(<span class="number">2</span>,<span class="string">&quot;性别&quot;</span>,LVCFMT_CENTER,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后的宽度可以省略，之后通过SetColumnWidth(no,width)进行设置。</p>
</blockquote>
<p>插入一行数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = m_ListCtrl.GetItemCount();    <span class="comment">//总行数</span></span><br><span class="line">m_ListCtrl.InsertItem(n,<span class="string">&quot;DS001&quot;</span>);     <span class="comment">//在第n行第一个字段插入字符</span></span><br><span class="line">m_ListCtrl.SetItemText(n,<span class="number">1</span>,<span class="string">&quot;科加斯&quot;</span>); <span class="comment">//在第n行第二个字段插入字符</span></span><br><span class="line">m_ListCtrl.SetItemText(n,<span class="number">2</span>,<span class="string">&quot;雄&quot;</span>);     <span class="comment">//在第n行第三个字段插入字符</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个字段要用InsertItem，后面的字段用SetItemText。</p>
</blockquote>
<p>删除选中的一行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = m_ListCtrl.GetNextItem(<span class="number">-1</span>,LVNI_SELECTED); <span class="comment">//得到所选行的索引值</span></span><br><span class="line">m_ListCtrl.DeleteItem(i);</span><br></pre></td></tr></table></figure>
<h4 id="树形控件（Tree-Control）"><a href="#树形控件（Tree-Control）" class="headerlink" title="树形控件（Tree Control）"></a>树形控件（Tree Control）</h4><p>树形控件也是一个输出控件，用来显示具有层次结构的数据，通常当作目录使用。一般会将属性项Has Buttons、Has Lines、Lines At Root设置为True。树形控件只能关联CTreeCtrl变量，可以调用如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GetCount();                 <span class="comment">//总项数，包括根</span></span><br><span class="line">GetRootItem();              <span class="comment">//返回根项的句柄</span></span><br><span class="line">GetItemText(HTREEITEM);     <span class="comment">//返回指定项文本</span></span><br><span class="line">GetSelectedItem();          <span class="comment">//返回选中项的句柄</span></span><br><span class="line">GetNextItem(HTREEITEM,code);<span class="comment">//以当前项为基础，按照code指定关系检索，返回检索到的句柄			</span></span><br><span class="line">InSertItem(str,hParent);    <span class="comment">//在母项下插入str，缺省的母项是根项</span></span><br><span class="line">ItemHasChildren(HTREEITEM); <span class="comment">//如有子项返回非0，否则返回0</span></span><br><span class="line">Expand(HTREEITEM,code);     <span class="comment">//TVE_EXPAND展开，TVE_COLLAPSE收缩</span></span><br><span class="line">DeleteItem(HTREEITEM);      <span class="comment">//删除指定项</span></span><br><span class="line">DeleteAllItems();           <span class="comment">//删除所有项，返回非0成功</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每一项都对应一个HTREEITEM类型的句柄，所有对这项的操作依赖于它。</p>
</blockquote>
<p>GetNextItem的参数code可以指定：</p>
<ul>
<li>TVGN_CARET：检索当前选中的项</li>
<li>TVGN_CHILD：检索首个孩子</li>
<li>TVGN_NEXT：检索下一项</li>
<li>TVGN_PREVIOUS:检索上一项</li>
<li>TVGN_PARENT：检索母项</li>
</ul>
<p>初始化树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HTREEITEM hRoot,hItem;</span><br><span class="line">hRoot = m_TreeCtrl.InsertItem(<span class="string">&quot;英雄联盟&quot;</span>);    <span class="comment">//根目录</span></span><br><span class="line">hItem = m_TreeCtrl.InsertItem(<span class="string">&quot;中单&quot;</span>,hRoot);  <span class="comment">//第二级目录，1</span></span><br><span class="line">m_TreeCtrl.InsertItem(<span class="string">&quot;科加斯&quot;</span>,hItem);        <span class="comment">//第三级，挂在“中单”下</span></span><br><span class="line">m_TreeCtrl.InsertItem(<span class="string">&quot;斯维因&quot;</span>,hItem);        <span class="comment">//第三级，挂在“中单”下</span></span><br><span class="line">m_TreeCtrl.Expand(hItem,TVE_EXPAND);          <span class="comment">//展开二级条目1</span></span><br><span class="line">hItem = m_TreeCtrl.InsertItem(<span class="string">&quot;射手&quot;</span>,hRoot);  <span class="comment">//第二级目录，2</span></span><br><span class="line">m_TreeCtrl.InsertItem(<span class="string">&quot;金克丝&quot;</span>,hItem);</span><br><span class="line">m_TreeCtrl.InsertItem(<span class="string">&quot;克格莫&quot;</span>,hItem);</span><br><span class="line">m_TreeCtrl.Expand(hItem,TVE_EXPAND);         <span class="comment">//展开二级条目2</span></span><br><span class="line">m_TreeCtrl.Expand(hRoot,TVE_EXPAND);         <span class="comment">//展开根目录</span></span><br></pre></td></tr></table></figure>
<p>返回项内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString s;</span><br><span class="line"><span class="keyword">int</span> n = m_TreeCtrl.GetCount();</span><br><span class="line">s.Format(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">s = m_TreeCtrl.GetItemText(m_TreeCtrl.GetRootItem());</span><br><span class="line">HTREEITEM t = m_TreeCtrl.GetSelectedItem();</span><br><span class="line">s = m_TreeCtrl.GetItemText(m_TreeCtrl.GetNextItem(t,TVGN_PARENT));</span><br><span class="line">AfxMessageBox(s);</span><br></pre></td></tr></table></figure>
<h4 id="标签控件-Tab-Control"><a href="#标签控件-Tab-Control" class="headerlink" title="标签控件(Tab Control)"></a>标签控件(Tab Control)</h4><p>标签控件提高了对话框的利用率，每个标签对应一个对话框，多个对话框可通过标签控件集中在一个对话框程序中。属性项Bottom可将上标签改为下标签。标签控件只能关联CTabCtrl变量，可以调用如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GetCurSel();        <span class="comment">//得到当前选中的标签号，从0计数，返回-1表示没有选中</span></span><br><span class="line">InsertItem(n,str);  <span class="comment">//在指定编号n处插入标签，标签名为str</span></span><br><span class="line">SetCurSel(n);       <span class="comment">//设置标签n为选中状态</span></span><br></pre></td></tr></table></figure>
<p>有多少个标签，就需要有多少个对话框。先在资源视图下插入Dialog资源，按照标签控件的尺寸（VC状态栏右下方），调整对话框的尺寸。然后，将属性项Style设置为Child，Border设置为none，再为Dialog资源关联CDialog子类。</p>
<p>在主对话框类头文件中，include新建的对话框类定义，并建立类对象。在初始化函数中键入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_TabCtrl.InsertItem(<span class="number">0</span>,<span class="string">&quot;上单&quot;</span>); <span class="comment">//插入标签头</span></span><br><span class="line">m_TabCtrl.InsertItem(<span class="number">1</span>,<span class="string">&quot;中单&quot;</span>);</span><br><span class="line">m_TabCtrl.InsertItem(<span class="number">2</span>,<span class="string">&quot;打野&quot;</span>);</span><br><span class="line">d1.Create(IDD_DIALOG1,GetDlgItem(IDC_TAB1));<span class="comment">//创建对话框，将对话框作为标签控件的子类</span></span><br><span class="line">d2.Create(IDD_DIALOG2,GetDlgItem(IDC_TAB1));</span><br><span class="line">d3.Create(IDD_DIALOG3,GetDlgItem(IDC_TAB1));</span><br><span class="line">CRect rs;</span><br><span class="line">m_TabCtrl.GetClientRect(&amp;rs);   <span class="comment">//获得Tab占用的区域（包含标签头）</span></span><br><span class="line">rs.top += <span class="number">25</span>;                   <span class="comment">//空出标签头</span></span><br><span class="line">rs.bottom -= <span class="number">1</span>;</span><br><span class="line">rs.left += <span class="number">1</span>;</span><br><span class="line">rs.right -= <span class="number">2</span>;</span><br><span class="line">d1.MoveWindow(&amp;rs);             <span class="comment">//将对话框移入标签控件</span></span><br><span class="line">d2.MoveWindow(&amp;rs);</span><br><span class="line">d3.MoveWindow(&amp;rs);</span><br><span class="line">d1.ShowWindow(<span class="literal">true</span>);            <span class="comment">//显示对话框</span></span><br><span class="line">d2.ShowWindow(<span class="literal">false</span>);           <span class="comment">//不能同时显示，否则覆盖</span></span><br><span class="line">d3.ShowWindow(<span class="literal">false</span>);</span><br><span class="line">m_TabCtrl.SetCurSel(<span class="number">0</span>);         <span class="comment">//第一个标签为初始标签</span></span><br></pre></td></tr></table></figure>
<p>让标签控件响应TCN_SELCHANGE消息，添加代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cur = m_TabCtrl.GetCurSel();</span><br><span class="line"><span class="keyword">switch</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    d1.ShowWindow(<span class="literal">true</span>);</span><br><span class="line">    d2.ShowWindow(<span class="literal">false</span>);</span><br><span class="line">    d3.ShowWindow(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    d1.ShowWindow(<span class="literal">false</span>);</span><br><span class="line">    d2.ShowWindow(<span class="literal">true</span>);</span><br><span class="line">    d3.ShowWindow(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    d1.ShowWindow(<span class="literal">false</span>);</span><br><span class="line">    d2.ShowWindow(<span class="literal">false</span>);</span><br><span class="line">    d3.ShowWindow(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>所有的控件类都是由CWnd派生的，都算是一个窗口。</li>
<li>通过DoDataExchange函数可以看到，控件通过资源ID与变量建立联系。所关联的变量类型，即为操作控件的关键，可以通过查阅MSDN获得类成员函数的详细信息。</li>
<li>控件的主要用途是与用户建立交互，获取数据或是显示数据，所以变量类型中的成员函数都是一些接口函数。</li>
<li>如果控件关联的是Value类型的变量，那么调用UpdateData函数会导致对话框内所有的Value控件的数据转移：UpdateData(TRUE)控件-&gt;变量，UpdateData(FALSE)变量-&gt;控件。</li>
<li>控件之间的层次关系是按照tab键顺序的，按Ctrl+D可以看到这个顺序，号越小，越在下面。</li>
</ol>
]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>VC编程 注册表</title>
    <url>/2016/03/20/VC%E7%BC%96%E7%A8%8B%20%E6%B3%A8%E5%86%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>Linux的很多资源都是通过文件表示的，所以使用文件操作就能调动很多系统功能；而Windows系统有个注册表，要想调动Windows系统功能，就要通过操作注册表来实现。</p>
<p>操作注册表一般有两种方式：API函数、CRegKey类。两种方式都比较常用，程序员可根据自身习惯采用。</p>
<a id="more"></a>

<h4 id="注册表结构"><a href="#注册表结构" class="headerlink" title="注册表结构"></a>注册表结构</h4><p>按压win+R，在“运行”框内输入regedit，即可打开注册表。可以看出，注册表具有树状结构。<br>最顶层的称为<strong>根键</strong>，只有五个：</p>
<ul>
<li>HKEY_CLASSES_ROOT 存储不同文件后缀和应用程序间的关系</li>
<li>HKEY_CURRENT_USER 存储有关当前登录用户的配置信息</li>
<li>HKEY_LOCAL_MACHINE 存储控制系统和软件的设置</li>
<li>HKEY_USERS 存储了所有用户的配置文件</li>
<li>HKEY_CURRENT_CONFIG 存储了系统在启动时需要的硬件配置信息</li>
</ul>
<p>根键下的每层子目录都称为<strong>子键</strong>。在树状结构的最底层——叶子位置的数据（显示在注册表程序的右侧）称为<strong>键值</strong>。一个键值包括：键值名、键值类型和数据。键值类型有：</p>
<ul>
<li>REG_DWORD 四字</li>
<li>REG_BINARY 二进制</li>
<li>REG_SZ 字符串</li>
<li>REG_MULTI_SZ 多字符串</li>
<li>REG_EXOEND_SZ 可扩展字符串</li>
</ul>
<h4 id="API函数"><a href="#API函数" class="headerlink" title="API函数"></a>API函数</h4><p>一 读取键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LSTATUS <span class="title">RegOpenKeyEx</span><span class="params">(   <span class="comment">//打开一个键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY   hKey,          <span class="comment">//根键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpSubKey,      <span class="comment">//子键路径名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  ulOptions,     <span class="comment">//必须为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">  REGSAM samDesired,    <span class="comment">//打开权限</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PHKEY  phkResult      <span class="comment">//打开成功则将一个HKEY类型的句柄返回到这个参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数lpSubKey的子键路径格式与文件路径类似，每级子键由\分隔。参数samDesired可以为：</p>
<ul>
<li>KEY_ALL_ACCESS (0xF003F) 综合了所有权限</li>
<li>KEY_CREATE_LINK (0x0020) 系统保留</li>
<li>KEY_CREATE_SUB_KEY (0x0004) 创建子键</li>
<li>KEY_ENUMERATE_SUB_KEYS (0x0008) 枚举一个键下的子键</li>
<li>KEY_EXECUTE (0x20019) 等价于KEY_READ</li>
<li>KEY_NOTIFY (0x0010) 更改键或子键</li>
<li>KEY_QUERY_VALUE (0x0001) 访问键值</li>
<li>KEY_READ (0x20019) 组合了STANDARD_RIGHTS_READ，KEY_QUERY_VALUE，KEY_ENUMERATE_SUB_KEYS，KEY_NOTIFY。</li>
<li>KEY_SET_VALUE (0x0002) 创建、删除或设置键值</li>
<li>KEY_WOW64_32KEY (0x0200) 指示在64位Windows下操作32位的注册表，此项必须与其他权限组合使用。</li>
<li>KEY_WOW64_64KEY (0x0100) 指示在64位Windows下操作64位的注册表，此项必须与其他权限组合使用。</li>
<li>KEY_WRITE (0x20006) 组合了STANDARD_RIGHTS_WRITE，KEY_SET_VALUE，KEY_CREATE_SUB_KEY。</li>
</ul>
<p>如果打开成功，函数返回ERROR_SUCCESS，否则返回一个非零错误代码。</p>
<blockquote>
<p>每个键自身具有安全描述符，实际的操作权限并不完全按照打开时参数设置的那样。<br>在win7 x64环境下，开发32位程序操作注册表，需要在samDesired中组合KEY_WOW64_64KEY。<br>使用位或 | 组合不同的权限。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LSTATUS <span class="title">RegQueryValueEx</span><span class="params">(  <span class="comment">//根据键值名获取类型和数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY    hKey,           <span class="comment">//打开的句柄，打开时必须有KEY_QUERY_VALUE权限。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR  lpValueName,    <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpReserved,     <span class="comment">//必须为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpType,         <span class="comment">//用于接收键值的类型，为NULL则放弃获取。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE  lpData,         <span class="comment">//缓冲区地址，用于接收键值的数据，为NULL则放弃获取。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpcbData        <span class="comment">//缓冲区尺寸，应该考虑到字符类型数据末尾的NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取成功返回ERROR_SUCCESS，如果注册表中不存在lpValueName键值，则返回ERROR_FILE_NOT_FOUND。</p>
<blockquote>
<p>这个函数通常用作获取REG_SZ类型的数据。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LSTATUS <span class="title">RegCloseKey</span><span class="params">(    <span class="comment">//关闭打开的键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey             <span class="comment">//打开的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例：获取键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString SerialNo=<span class="string">&quot;HARDWARE\\DEVICEMAP\\PARALLEL PORTS&quot;</span>;</span><br><span class="line">HKEY hKey;</span><br><span class="line">LONG lnRes=RegOpenKeyEx(HKEY_LOCAL_MACHINE,SerialNo,<span class="number">0</span>,KEY_READ|KEY_WOW64_64KEY,&amp;hKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lnRes == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    BYTE dev[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//用于接收REG_SZ</span></span><br><span class="line">    DWORD devSize = <span class="number">50</span>;<span class="comment">//必须够大</span></span><br><span class="line">    DWORD type;</span><br><span class="line">    lnRes = RegQueryValueEx(hKey,<span class="string">&quot;\\Device\\Parallel0&quot;</span>,<span class="number">0</span>,&amp;type,dev,&amp;devSize);</span><br><span class="line">    <span class="keyword">if</span>(lnRes == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Edit1.Format(<span class="string">&quot;%s&quot;</span>,dev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">RegCloseKey(hKey);</span><br></pre></td></tr></table></figure>
<p>使用RegOpenKeyEx打开键时，要注意那个键的权限，如果只是读取数据，使用KEY_READ足以。</p>
<p>二 设置键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LSTATUS <span class="title">RegCreateKey</span><span class="params">(   <span class="comment">//创建一个子键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY   hKey,          <span class="comment">//根键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpSubKey,      <span class="comment">//子键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PHKEY  phkResult      <span class="comment">//用于接收创建的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">LSTATUS <span class="title">RegSetValueEx</span><span class="params">(    <span class="comment">//设置或创建键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY       hKey,        <span class="comment">//已被打开的句柄，且有KEY_SET_VALUE权限</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR     lpValueName, <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD      Reserved,    <span class="comment">//必须为0</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD      dwType,      <span class="comment">//键值类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> BYTE *lpData,     <span class="comment">//数据缓冲区地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD      cbData       <span class="comment">//数据占用的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数lpData如果是REG_SZ，末尾有1个NULL；如果是REG_MULTI_SZ，末尾有2个NULL。<br>上述两个函数如果执行成功都会返回ERROR_SUCCESS。</p>
</blockquote>
<p>例：屏蔽任务管理器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString RegVervion = <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;</span>;</span><br><span class="line">HKEY hKey;</span><br><span class="line">LONG lnRes = RegOpenKeyEx(HKEY_CURRENT_USER,RegVervion,<span class="literal">NULL</span>,KEY_ALL_ACCESS|KEY_WOW64_64KEY,&amp;hKey);</span><br><span class="line">DWORD a = <span class="number">0</span>;        <span class="comment">//用于接收REG_DWORD</span></span><br><span class="line">DWORD Size = <span class="number">4</span>;     <span class="comment">//必须够大，否则234错误</span></span><br><span class="line"><span class="keyword">if</span> (lnRes != ERROR_SUCCESS)    <span class="comment">//不存在System键，建立它</span></span><br><span class="line">&#123;</span><br><span class="line">    RegCreateKey(HKEY_CURRENT_USER,RegVervion,&amp;hKey);<span class="comment">//创建子键</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    RegSetValueEx(hKey,<span class="string">&quot;DisableTaskMgr&quot;</span>,<span class="number">0</span>,REG_DWORD,(BYTE*)&amp;a,<span class="number">4</span>);<span class="comment">//一个DWORD有4个BYTE</span></span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    lnRes = RegQueryValueEx(hKey,<span class="string">&quot;DisableTaskMgr&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,(BYTE*)&amp;a,&amp;Size);</span><br><span class="line">    <span class="keyword">if</span>(lnRes == ERROR_SUCCESS)<span class="comment">//存在，检查是否为1</span></span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            RegSetValueEx(hKey,<span class="string">&quot;DisableTaskMgr&quot;</span>,<span class="number">0</span>,REG_DWORD,(BYTE*)&amp;a,<span class="number">4</span>);<span class="comment">//一个DWORD有4个BYTE</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//没有这个键值，则建立</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        RegSetValueEx(hKey,<span class="string">&quot;DisableTaskMgr&quot;</span>,<span class="number">0</span>,REG_DWORD,(BYTE*)&amp;a,<span class="number">4</span>);<span class="comment">//一个DWORD有4个BYTE</span></span><br><span class="line">    &#125;</span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，每个RegSetValueEx调用都是用BYTE*做强制转换，其目的是取DWORD类型的数据a的首地址。由于数据a占4个字节，故而最后一个参数设置为4。</p>
<p>三 枚举键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LSTATUS <span class="title">RegEnumKeyEx</span><span class="params">(        <span class="comment">//枚举已打开键的子键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY      hKey,            <span class="comment">//已打开键的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwIndex,         <span class="comment">//索引，从0起</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTR     lpName,          <span class="comment">//缓冲区，接受子键名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcchName,       <span class="comment">//lpName缓冲区尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpReserved,      <span class="comment">//设置为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTR     lpClass,         <span class="comment">//缓冲区，接受用户定义class，可以为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcchClass,      <span class="comment">//lpClass缓冲区尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PFILETIME lpftLastWriteTime<span class="comment">//接受一个FILETIME结构，获得子键最后被写时间，可以为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>此函数每次调用，获取一个子键名到lpName，获取顺序不定。获取成功则返回ERROR_SUCCESS，如果所有子键都已获取，函数返回ERROR_NO_MORE_ITEMS。</p>
<blockquote>
<p>每次调用成功，参数lpcchName会被赋值为lpName缓冲区内字符的长度。所以，如果要循环调用枚举函数，需要重置lpcchName，以保持缓冲区指定尺寸。可以使用RegQueryInfoKey获得最长子键尺寸。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FILETIME</span> &#123;</span></span><br><span class="line">  DWORD dwLowDateTime;        <span class="comment">//时间低位</span></span><br><span class="line">  DWORD dwHighDateTime;       <span class="comment">//时间高位</span></span><br><span class="line">&#125; FILETIME, *PFILETIME, *LPFILETIME;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将FILETIME数据转化为CTime对象的方法为：CTime ct(filetime)</p>
</blockquote>
<p>例：枚举所有子键</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString usbstor = <span class="string">&quot;SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\&quot;</span>;</span><br><span class="line">HKEY hKey;</span><br><span class="line">LONG regUsb = RegOpenKeyEx(HKEY_LOCAL_MACHINE,usbstor,<span class="literal">NULL</span>,KEY_READ|KEY_WOW64_64KEY,&amp;hKey);</span><br><span class="line"><span class="keyword">if</span> (regUsb == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> name[MAX_PATH] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//缓冲区，用于接收子键名</span></span><br><span class="line">    DWORD size = MAX_PATH;        <span class="comment">//缓冲区长度</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (RegEnumKeyEx(hKey,i,name,&amp;size,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        AfxMessageBox(name);</span><br><span class="line">        i++;</span><br><span class="line">        size = MAX_PATH;    <span class="comment">//重置缓冲区尺寸</span></span><br><span class="line">    &#125;</span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>四 获取子键信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LSTATUS <span class="title">RegQueryInfoKey</span><span class="params">(            <span class="comment">//获得指定键的信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY      hKey,                   <span class="comment">//已打开的键</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTR     lpClass,                <span class="comment">//用户定义class缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcchClass,             <span class="comment">//用户定义class缓冲区尺寸</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpReserved,             <span class="comment">//保留，为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcSubKeys,             <span class="comment">//包含子键数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcbMaxSubKeyLen,       <span class="comment">//最长子键名的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcbMaxClassLen,        <span class="comment">//最长子键类字符串的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcValues,              <span class="comment">//这个键下的键值数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcbMaxValueNameLen,    <span class="comment">//最长键值名的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcbMaxValueLen,        <span class="comment">//最长数据组件的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpcbSecurityDescriptor, <span class="comment">//键的安全描述符长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PFILETIME lpftLastWriteTime       <span class="comment">//FILETIME结构，接收最后写时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>除第一个参数外，其余参数都可以设置为NULL。如果不需要某项数据，赋予NULL即可。函数执行成功返回ERROR_SUCCESS。</p>
<p>例：显示子键数目和最长子键字符数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString usbstor = <span class="string">&quot;SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\&quot;</span>;</span><br><span class="line">HKEY hKey;</span><br><span class="line">LONG regUsb = RegOpenKeyEx(HKEY_LOCAL_MACHINE,usbstor,<span class="literal">NULL</span>,KEY_READ|KEY_WOW64_64KEY,&amp;hKey);</span><br><span class="line"><span class="keyword">if</span> (regUsb == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD subkeyNum;</span><br><span class="line">    DWORD maxSubkeyLen;	</span><br><span class="line">    RegQueryInfoKey(hKey,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;subkeyNum,&amp;maxSubkeyLen,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    CString result;</span><br><span class="line">    result.Format(<span class="string">&quot;有子键%d个，最长子键有字符%d个。&quot;</span>,subkeyNum,maxSubkeyLen);</span><br><span class="line">    AfxMessageBox(result);</span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>五 删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LSTATUS <span class="title">RegDeleteKey</span><span class="params">(     <span class="comment">//删除一个子键及其键值（必须没有子键）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY   hKey,            <span class="comment">//已打开的句柄，打开权限无影响</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpSubKey         <span class="comment">//子键名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">LSTATUS <span class="title">RegDeleteValue</span><span class="params">(   <span class="comment">//根据键值名删除键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY   hKey,            <span class="comment">//已打开的句柄，必须带有KEY_SET_VALUE权限</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpValueName      <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">LSTATUS <span class="title">RegDeleteTree</span><span class="params">(    <span class="comment">//递归的删除所有子键及其键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY   hKey,            <span class="comment">//已打开的句柄，必须带有KEY_ENUMERATE_SUB_KEYS和KEY_QUERY_VALUE</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpSubKey         <span class="comment">//子键名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于RegDeleteTree函数，参数lpSubKey如果为NULL，则删除已打开键下的所有子键。当已打开键下有键值时，函数会返回错误，其下子键照样被删除，但其下键值仍旧存在。如果想要彻底清空一个键，需要在打开键时，带有KEY_SET_VALUE权限。</p>
<p>例：删除键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString RegV = <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;</span>;<span class="comment">//此子键访问权限需要KEY_SET_VALUE</span></span><br><span class="line">HKEY hKey;</span><br><span class="line">LONG lnRes = RegOpenKeyEx(HKEY_CURRENT_USER,RegV,<span class="literal">NULL</span>,KEY_SET_VALUE|KEY_WOW64_64KEY,&amp;hKey);</span><br><span class="line"><span class="keyword">if</span> (lnRes == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (RegDeleteValue(hKey,<span class="string">&quot;DisableTaskMgr&quot;</span>) == ERROR_SUCCESS)</span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>例：删除子键</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString RegV = <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies&quot;</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (RegDeleteKey(hKey,<span class="string">&quot;system&quot;</span>) == ERROR_SUCCESS)</span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>例：删除子键及其下的所有子键和键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString RegV = <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\system&quot;</span>;<span class="comment">//此子键访问权限需要KEY_SET_VALUE</span></span><br><span class="line">HKEY hKey;</span><br><span class="line">LONG lnRes = RegOpenKeyEx(HKEY_CURRENT_USER,RegV,<span class="literal">NULL</span>,KEY_SET_VALUE|KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE|KEY_WOW64_64KEY,&amp;hKey);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (RegDeleteTree(hKey,<span class="literal">NULL</span>) == ERROR_SUCCESS)</span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h4 id="CRegKey类"><a href="#CRegKey类" class="headerlink" title="CRegKey类"></a>CRegKey类</h4><p>一 读取键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HKEY hKeyParent,        <span class="comment">//根键</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszKeyName,    <span class="comment">//子键名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    REGSAM samDesired = KEY_READ | KEY_WRITE)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//权限，默认为KEY_ALL_ACCESS</span></span><br><span class="line"></span><br><span class="line"><span class="function">LONG <span class="title">Close</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用注册表类操作注册表，仍旧需要先打开某键，使用Open函数，打开的句柄保存到m_hKey。然后，可以使用下列函数查询键值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">QueryBinaryValue</span><span class="params">(            <span class="comment">//读取REG_BINARY类型键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pszValueName,         <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* pValue,                 <span class="comment">//TCHAR类型缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG* pnBytes)</span> <span class="title">throw</span><span class="params">()</span></span>;      <span class="comment">//接收尺寸</span></span><br><span class="line"><span class="function">LONG <span class="title">QueryDWORDValue</span><span class="params">(             <span class="comment">//读取REG_DWORD类型键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pszValueName,         <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD&amp; dwValue)</span> <span class="title">throw</span><span class="params">()</span></span>;      <span class="comment">//缓冲区</span></span><br><span class="line"><span class="function">LONG <span class="title">QueryMultiStringValue</span><span class="params">(       <span class="comment">//读取REG_MULTI_SZ类型键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pszValueName,         <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPTSTR pszValue,              <span class="comment">//TCHAR类型缓冲区，获取的字符串末尾有两个NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG* pnChars)</span> <span class="title">throw</span><span class="params">()</span></span>;      <span class="comment">//接收尺寸</span></span><br><span class="line"><span class="function">LONG <span class="title">QueryStringValue</span><span class="params">(            <span class="comment">//读取REG_SZ类型键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pszValueName,         <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPTSTR pszValue,              <span class="comment">//TCHAR类型缓冲区，获取的字符串末尾有一个NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG* pnChars)</span> <span class="title">throw</span><span class="params">()</span></span>;      <span class="comment">//接收尺寸</span></span><br></pre></td></tr></table></figure>
<p>程序员可按照键值类型选用对应的查询函数。这些函数执行成功，返回ERROR_SUCCESS，参数pnChars会得到实际获取的长度；如果读取的是不对应类型的键值，则返回ERROR_INVALID_DATA。</p>
<p>例：查询REG_BINARY类型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString path=<span class="string">&quot;HARDWARE\\DEVICEMAP\\VIDEO&quot;</span>;</span><br><span class="line">CRegKey reg;</span><br><span class="line"><span class="keyword">if</span> (reg.Open(HKEY_LOCAL_MACHINE,path,KEY_READ) == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    TCHAR dev[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line">    ULONG devSize = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">if</span> (reg.QueryBinaryValue(<span class="string">&quot;ObjectNumberList&quot;</span>,dev,&amp;devSize) == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Edit1.Format(<span class="string">&quot;%x&quot;</span>,dev[<span class="number">24</span>]);</span><br><span class="line">        UpdateData(FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">    reg.Close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用如下通用查询函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">QueryValue</span><span class="params">(                <span class="comment">//通用查询函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pszValueName,       <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD* pdwType,             <span class="comment">//用于获取键值类型，可为NULL拒绝获取</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* pData,                <span class="comment">//TCHAR缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG* pnBytes)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">//缓冲区尺寸，执行成功则为实际获取的字节数</span></span><br></pre></td></tr></table></figure>
<p>如果获取的是REG_SZ或REG_MULTI_SZ数据，参数pnBytes的计数含末尾的NULL。</p>
<p>例：查询REG_MULTI_SZ类型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString SerialNo=<span class="string">&quot;HARDWARE\\DESCRIPTION\\System&quot;</span>;</span><br><span class="line">CRegKey reg;</span><br><span class="line"><span class="keyword">if</span> (reg.Open(HKEY_LOCAL_MACHINE,SerialNo,KEY_READ) == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    TCHAR dev[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line">    ULONG devSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (reg.QueryValue(<span class="string">&quot;SystemBiosVersion&quot;</span>,<span class="literal">NULL</span>,dev,&amp;devSize) == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Edit1.Format(<span class="string">&quot;%s&quot;</span>,&amp;dev[<span class="number">17</span>]);<span class="comment">//显示第二行</span></span><br><span class="line">        UpdateData(FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">    reg.Close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>REG_MULTI_SZ类型键值，每行由\0（NULL）分隔，末尾有两个\0（NULL）。</p>
</blockquote>
<p>二 设置键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">Create</span><span class="params">(                    <span class="comment">//创建一个键</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HKEY hKeyParent,            <span class="comment">//根键</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpszKeyName,        <span class="comment">//子键名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPTSTR lpszClass = REG_NONE,                <span class="comment">//指定键的class</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwOptions = REG_OPTION_NON_VOLATILE,  <span class="comment">//键的选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">    REGSAM samDesired = KEY_READ | KEY_WRITE,   <span class="comment">//权限</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPSECURITY_ATTRIBUTES lpSecAttr = <span class="literal">NULL</span>,     <span class="comment">//指示能否被继承</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPDWORD lpdwDisposition = <span class="literal">NULL</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">//不为空，则为REG_CREATED_NEW_KEY或REG_OPENED_EXISTING_KEY</span></span><br><span class="line"></span><br><span class="line"><span class="function">LONG <span class="title">SetValue</span><span class="params">(                <span class="comment">//设置键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR pszValueName,     <span class="comment">//键值名</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwType,             <span class="comment">//键值类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span>* pValue,       <span class="comment">//缓冲区，函数数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG nBytes)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">//数据尺寸</span></span><br></pre></td></tr></table></figure>
<p>一般只用给出Create函数前两个参数即可。使用SetValue函数，写入REG_SZ或REG_MULTI_SZ类型数据，参数nBytes需要计入字符串末尾的NULL（SZ一个，MULTI两个）。</p>
<p>例：写入REG_MULTI_SZ类型键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString RegV = <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;</span>;</span><br><span class="line">CRegKey reg;</span><br><span class="line"></span><br><span class="line">TCHAR a[<span class="number">13</span>] = <span class="string">&quot;abcdefg\0hij&quot;</span>;<span class="comment">//预留两个空间</span></span><br><span class="line">ULONG Size = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.Open(HKEY_CURRENT_USER,RegV) != ERROR_SUCCESS)<span class="comment">//不存在System键，建立它</span></span><br><span class="line">&#123;</span><br><span class="line">    reg.Create(HKEY_CURRENT_USER,RegV);	<span class="comment">//创建子键，其他默认即可</span></span><br><span class="line">    reg.SetValue(<span class="string">&quot;DisableTaskMgr&quot;</span>,REG_MULTI_SZ,a,Size);<span class="comment">//设置键值</span></span><br><span class="line">    reg.Close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;已存在&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>SetValue是一个通用写入键值函数，其实CRegKey也提供了一系列按照类型写入的专用Set函数，这里不再赘述。</p>
<p>三 枚举键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">EnumKey</span><span class="params">(                <span class="comment">//枚举已打开键的子键</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD iIndex,            <span class="comment">//索引，从0起</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPTSTR pszName,          <span class="comment">//TCHAR缓冲区，用于接收子键名，含末尾的NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPDWORD pnNameLength,    <span class="comment">//缓冲区尺寸，执行成功则为实际获取的字节数，不含末尾的NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    FILETIME* pftLastWriteTime = <span class="literal">NULL</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//返回最后写入时间</span></span><br></pre></td></tr></table></figure>
<p>函数执行成功返回ERROR_SUCCESS，如果返回ERROR_NO_MORE_ITEMS，则说明枚举了所有的子键。</p>
<p>例：枚举所有子键及其最后写入时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString usbstor = <span class="string">&quot;SYSTEM\\ControlSet002\\Enum\\USBSTOR\\Disk&amp;Ven_aigo&amp;Prod_Miniking&amp;Rev_8.07&quot;</span>;<span class="comment">//此子键访问权限不能设置为ACCESS</span></span><br><span class="line">CRegKey reg;</span><br><span class="line"><span class="keyword">if</span> (reg.Open(HKEY_LOCAL_MACHINE,usbstor,KEY_READ) == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    TCHAR name[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    DWORD size = MAX_PATH;			<span class="comment">//获得子键名字的实际长度</span></span><br><span class="line">    FILETIME t;</span><br><span class="line">    CString str;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (reg.EnumKey(i,name,&amp;size,&amp;t) == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">CTime <span class="title">ct</span><span class="params">(t)</span></span>;</span><br><span class="line">        str.Format(<span class="string">&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">            ct.GetYear(),ct.GetMonth(),ct.GetDay(),</span><br><span class="line">            ct.GetHour(),ct.GetMinute(),ct.GetSecond());</span><br><span class="line">        str = <span class="string">&quot; &quot;</span> + str;</span><br><span class="line">        str = name + str;</span><br><span class="line">        AfxMessageBox(str);</span><br><span class="line">        i++;</span><br><span class="line">        size = MAX_PATH;		<span class="comment">//重置缓冲区长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    reg.Close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>四 删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">DeleteValue</span><span class="params">(LPCTSTR lpszValue)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">//删除键值</span></span><br><span class="line"><span class="function">LONG <span class="title">DeleteSubKey</span><span class="params">(LPCTSTR lpszSubKey)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//删除没有子键的键</span></span><br><span class="line"><span class="function">LONG <span class="title">RecurseDeleteKey</span><span class="params">(LPCTSTR lpszKey)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">//删除子键及其下的所有东西</span></span><br></pre></td></tr></table></figure>
<p>删除之前还是需要打开上层的键。</p>
<p>例：删除键值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString RegV = <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;</span>;</span><br><span class="line">CRegKey Reg;</span><br><span class="line"><span class="keyword">if</span> (Reg.Open(HKEY_CURRENT_USER,RegV) == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Reg.DeleteValue(<span class="string">&quot;DisableTaskMgr&quot;</span>) == ERROR_SUCCESS)</span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        AfxMessageBox(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    Reg.Close();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;打开失败&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>例：删除含有子键的键</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (Reg.RecurseDeleteKey(<span class="string">&quot;abc&quot;</span>) == ERROR_SUCCESS)</span><br><span class="line">    AfxMessageBox(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    AfxMessageBox(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">Reg.Close();</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>个人觉得使用CRegKey操作注册表更好，它的成员函数更加面向需求，参数类型更加简洁友好。使用MFC编程的一大痛苦就是折腾数据类型，这种问题经常会中断程序员的逻辑思考，分散程序员的注意力。迫使程序员将精力分配到语法的语言，不是一门好语言。</p>
]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title>政府、商人和普罗大众</title>
    <url>/2019/07/08/%E6%94%BF%E5%BA%9C%E3%80%81%E5%95%86%E4%BA%BA%E5%92%8C%E6%99%AE%E7%BD%97%E5%A4%A7%E4%BC%97/</url>
    <content><![CDATA[<p>本人觉得下面两篇文章应该是发自官媒作者与商人的真情实感，其中的内容既没有多少政治理论，也没有罗列一堆经济数据，没有大段的政策“成就”，也没有成功人士的“正能量”鸡汤，但真正道出了一些“东西”，本人觉得非常具有启发性。</p>
<a id="more"></a>

<p>在中国，政府作为社会发展的发动机，其身影在日常经济生活中无处不在，所有的市场利益主体都要看这个超级主体的脸色，但这只看的见的手却总是显得如此“笨拙”，其行为总是落在市场其他主体行为之后。</p>
<p>李嘉诚的经历与索罗斯类似，小时候经历了战乱，后来逃难到社会相对稳定、经济相对富裕的地区。生财之道不是靠创造，而是靠钻规则的空子，不顾社会责任和普罗大众的感受。他们晚年都把自己包装成一名慈善家，李嘉诚包装的更隐晦，这不是因为他更低调，而是中国传统文化的特色。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>以下内容均来自网络。<br>要想有一个比较好的阅读效果，就不要给自己一个预设位置。</p>
</blockquote>
<h4 id="环境背景"><a href="#环境背景" class="headerlink" title="环境背景"></a>环境背景</h4><ol>
<li>2015年经济存在资金外流、制造业不振、房地产下滑、外资撤离等4大负面因素影响。</li>
<li>2015年6月份，中国股市出现了熔断，仅用了两个月从5178点一路下跌至2850点，下跌幅度达45%。</li>
<li>2015年12月20日，中央将房地产去库存列入2016年重点工作。（涨价去库存）</li>
</ol>
<h4 id="转载：新华社智库机构“瞭望智库”（2015年9月12日）"><a href="#转载：新华社智库机构“瞭望智库”（2015年9月12日）" class="headerlink" title="转载：新华社智库机构“瞭望智库”（2015年9月12日）"></a>转载：新华社智库机构“瞭望智库”（2015年9月12日）</h4><p>近日，李嘉诚拟将长实地产在上海的地盘，以200亿元出卖。这是李嘉诚撤离中国，财富转移欧洲战略部署的继续。</p>
<p>本来，商业如水流，逐利是资本的本性。李嘉诚想去哪里就去哪里。但是，鉴于李嘉诚最近二十年在中国获取财富的性质，似乎不仅仅是商业那么简单。众所周知，在中国，地产行业与权力走的很近，没有权力资源，是无法做地产生意的。由此，地产的财富，并非完全来自彻底的市场经济。恐怕不宜想走就走。</p>
<p><strong>别让李嘉诚跑了</strong><br>敏感如李嘉诚，绝不会感觉不到。在中国，经济周期与政治周期密切相关，由此，一撤资，二撤资，三撤资，其商业帝国，在大陆欲上演金蝉脱壳之法。　</p>
<p>前年是李嘉诚最不平凡的一年，先是工人罢工浪潮，风起云涌，后是在大陆的抛售，受到了巨大的非议。就民间形象而言，李嘉诚从此前的商界领袖，教父级人物，转变为长着獠牙的怪物。令人遗憾，李嘉诚本人应也比较伤心。</p>
<p>就官方感受而言，李嘉诚不顾念官方此前对其在基础设施，港口、地产等领域的大力扶持，在中国经济遭遇危机的敏感时刻，不停抛售，造成悲观情绪在部分群体中蔓延，其道义的高点，已经失守。低买高卖，确实是市场经济，但是，地产、港口等产业，恰恰是中国最不市场化的产业，没有权力的扶助，哪里来的机会？合作时借权力，卖出时说市场，似乎双重标准，让人难以淡定。</p>
<p>香港富豪榜的前几名竟然全部为地产商，显示了香港产业的畸形。而这种畸形产业的背后，隐藏着香港社会结构的畸形，而豪族的出现，以及贫富分化的眼中，则严重危害了香港社会的活力。</p>
<p>其实，李嘉诚只不过是一介小商人，有何能量影响香江?能操控香港万民福祉与未来者，国家此前的治港思路滞后于现实发展，方才导致香港困局。未来需要改变思路，进一步造福香港万民。</p>
<p><strong>“招安精英”致使李嘉诚等豪族坐大</strong><br>香港社会结构的失衡，虽然发作于回归之后，病根却早在80年代即已种下。在英治时代，虽然港英政府亦喜欢借助华商领袖的势力，来维系社会平衡，但是，总体而言，香港还算是一个健康均衡的社会，从香港的流行文化，即可知香港是一个市民化，平民化和多元化的社会。在经济领域，香港虽然是全球知名的自由港，贸易发达，但是，实业亦非常发达，其精工制造，一度全球闻名。</p>
<p>但是，到了80年代，《中英联合声明》签署之后，香港社会即发生了重大变化。中央政府的未来设想是实现“港人治港”，但是，这个“港人治港”的潜台词，很多香港人当时不太明白。</p>
<p>事实上，大陆精英治国的理念，亦被移植到香港。成为北京重点倚重对象的不是香港的升斗小民，而是香港的华商领袖。实际意义上，这形成了一种对于香港上层人士的“招安”政策。</p>
<p>在此情况下，香港腾飞过程中崛起的一些新商人，意外地获得了固化其社会经济地位的机会。三十年来，香港的头面人物不断受到各种“关照”。香港逐步形成了真正意义上的豪族，这些大族因为与大陆的关系，在拓展商业势力方面，获得了越来越多的方便，他们不仅到大陆投资受到照顾，同时，在某些与权力联系紧密的领域，亦获得了特殊的放行。</p>
<p>地产行业的畸形发展就是表现之一。作与权力关系最为亲近的行业，香港地产行业的繁荣，发蒙于60年代，但是，在60至80年代之中，并没有产生特别庞大的地产企业，诸多地产大亨的最终修成正果，普遍在80年代以后。</p>
<p>李嘉诚虽然在1958年即进军地产，但是一直以实业为主，直到他收购和黄之后，才开始大规模扩张，而李嘉诚在1978年受到当时的国家领导人接见之后，在香港可谓通行无阻。政治地位的提高，亦使其商业扩张顺风顺水，特别是在地产领域，此后，李嘉诚的财富大部来自地产行业。</p>
<p>在大陆，很多基础设施建设，亦有李嘉诚的身影，如深圳的盐田港，大陆方面即交给了李嘉诚。“一哥”李嘉诚如此，“二哥”李兆基和“四哥”郑裕彤，也是如此，李郑兴建了“香港国际会议展览中心”等众多香港地标性建筑物，无政府人脉，是绝对办不到的。从老大到老二老三，都是早年打基础，80年代爆发为巨头级华商，那就绝非偶然了。</p>
<p>目前，香港前十名的商业大家族，过半从事地产行业，可见，其财富的来源，并非为香港创造了真实的财富，而是部分建立在权力经济，土地经济之上。</p>
<p>香港与新加坡同为港口城市，但是，80年代之后的香港和新加坡，却渐行渐远。</p>
<p>香港和新加坡，都以制造业和贸易起家，后来发展服务业，不同的是，到今天，新加坡与香港的支柱产业，却完全不一样。目前，新加坡的支柱产业，是贸易、制造业、航运业与旅游业。而香港的支柱产业，是零售业、旅游业、地产业、银行及金融服务业。特别是对于地产行业的依赖，达到了不可理喻的地步。</p>
<p>同为海港城市，新加坡土地资源更为紧张，人口密度更大，但是新加坡却没有房产危机，新加坡建立了很多廉租房，地产行业的富豪，远没有香港多。但是，香港迟迟无法建立这种住房制度。香港的地产行业异常发达，富豪云集。而香港90年代以后资产过十亿美元的大富豪，几乎90%以上都涉足地产行业。</p>
<p>在市场经济完善的国家和地区，来自地产行业的富豪非常少，而这个方面，香港却颇似大陆，表现了政治权力对于香港的经济结构的同化。</p>
<p>对于富商阶层的畸形扶持，使香港的社会结构失去了平衡，贫富分化日益严重，中产阶层日益弱小。而在一个中产阶级弱小的社会中，生产与消费都是畸形的。</p>
<p>在产出领域，有什么行业比做地产更赚钱?在消费领域，有什么比奢侈品更让人着迷?</p>
<p>如此，则实业逐步被人遗忘。做塑料的李嘉诚去做地产了，甚至连做珠宝的郑裕彤，亦放着金碗不要，也去做地产。回归后的10年来，香港制造业占本地生产总值的比重，已从1997年的8.3%减至目前的不到5%，服务业的比重，接近90%，而实际上，如果从80年代算起，香港制造业的下降幅度更猛。香港制造业的衰亡，不仅是其向珠三角转移的结果，亦是畸形的社会结构导致的恶果。</p>
<p><strong>畸形社会结构的危害</strong><br>同为小经济体，香港与新加坡，乃至日本的财富分布结构，亦大为不同。</p>
<p>香港四十大家族占据全港三分之二的财富，集中程度非常吓人。而新加坡则并没有产生特别大的富豪，亦无此集中财富。日本更是如此，甚至日本的富豪密度，都不及中国大陆。</p>
<p>以日本为例，一度财阀和门阀制度流行的日本，50年代在美国的帮助下，进行了社会改革，以天皇走下神坛为标志，日本以立法的形式，限制豪强大族，同时，对于财阀进行了限制，一些大财阀被迫拆分。扫除社会和经济领域的垄断势力之后，日本正式进入大众时代，迸发出强大的创造力。任何人，只有有足够的才智和努力，都可以成为社会的中坚力量。</p>
<p>在同时起步的国家和地区队列中，香港貌似原地踏步了十余年，当人们期待它起步走的时候，结果，它却最后变成向后转了。</p>
<p>六七十年代，香港的富豪阶层也许并非主观上希望成为豪族，但是，“港人治港”的政策，客观上造就了豪族，而在回归之后，这种势力则更是有增无减，甚至，成为豪族，已经开始成为很多香港上层社会人士主动的追求。</p>
<p>2003年，时任政协副主席霍英东率领8人的“商界知名人士访京团”来到中南海。在这82人中，富豪有40人，其余42人是家眷，比富豪还多，而在这42人中，很多是这些富豪的公子。如李嘉诚就带他的两个儿子李泽钜和李泽楷，李兆基带着长子李家杰，曾宪梓带着小儿子曾智明。</p>
<p>荣及己身还不够，还希望把自己的声望与社会地位传给家族继承人，不仅实现财富的世袭，更实现社会地位的世袭，而这种变相世袭，恰恰阻隔了大众在财富和社会地位方面的上升渠道，造成了香港社会的不平衡。</p>
<p>正是这种社会领域的失衡，导致香港经济结构出现不平衡。而这种不平衡，不仅造成今日香港经济低迷，更造成了香港社会生活和精神文化的整体退化。表现得最明显的，就是香港电影产业，自从九七之后，香港的电影就乏善可陈了，变得严格的管制，使很多电影失去了风韵，而香港社会的崩溃，使香港电影失去了根基与活力，那种草根性的情怀，大众性的娱乐，兼容并包的气度，是建立在平民文化和多元文化的根基之上的，失去了这两点，也就是去了活力之源。</p>
<p>在未来，香港经济要走出困局，其根本道路，亦在于再造大众社会，重塑平民精神，而非仅仅是经济领域的努力。</p>
<p><strong>逐步改变治港思路</strong><br>为今之计，香港回归日久，人心归附，一国两制，生根发芽，不客气地说，大商人已经不再是社会稳压器，失去了其利用价值。而最近几年，中国各种矛盾开始凸显，改革形势严峻，十八大提出，改革是未来最大的红利，而改革的最大阻力，即是各种既得利益集团，这种既得利益者，不仅存在大陆，香港亦有。</p>
<p>同时，在香港的改革，比在大陆更为容易推行，香港是一个有草根传统的地方，纵使是豪族，亦只有商业地位，而无政治背景，不似大陆，要收拾一个贪官，涉及千丝万缕的社会关系，有的甚至是世家，父子高官，树大根深，难以撼动。香港豪族虽从经济上富甲一方，却并无显赫政治地位。纵使是曾经受到过领导人关照，也不过此一时彼一时。时势变，政治地位亦变。有权力之利剑，踏平香港各个山头，可谓易如反掌。</p>
<p>从国家对于香港的倚重程度的变化来说，亦需逐步削弱香港豪族地位，当下中国已经成为世界第二经济大国，经济地位非同昔比，上海，天津，深圳，广州等沿海城市亦兴起，香港作为自由港虽然仍然重要，但是已不再有不可替代的作用。对于国家来说，整个香港的利用价值大大下降。</p>
<p>为今之计，为争取民心，推动改革，以继续平稳政权，提高执政合法性，获取大众对于未来改革的支持，中央政府应权衡利弊，果断抛弃不再有利用价值的香港豪族，平抑豪族，扶持农工，在政治上，推动社会阶层的扁平化，在经济上，发展多元产业，防止一业独大。</p>
<p>在全国范围内，随着中国增速的下降，从前的以增量改革为主的改革模式，将逐步过渡到增量改革与存量改革并重的模式。存量怎么改？说白了，经济上，加大开放，政治和社会领域，即打压富豪，收买底层，扩大政权根基。</p>
<p>在此大势之下，此前的香港豪族，从被关照的对象，逐步沦落为被疏远的对象，李嘉诚人中豪杰，已经看到这种苗头，一叶落而知天下秋。</p>
<p><strong>李嘉诚等商人还有三大未竞使命</strong><br>对于李嘉诚为代表的香港富豪来说，不管走与不走，作为曾经的获利者，其在大陆，在中国，未来还有三大使命需要完成，不能轻易一走了之。</p>
<p>其一是，兼顾民生，回报穷人</p>
<p>毋庸讳言，八九十年代之后，香港富豪靠的就是卖地修港口等大生意，靠的就是与权力的结盟，获得了财富，做的都是一本万利的生意。未来，随着香港贫富分化的加大，香港富豪需要实现平安着陆，通过投资不是太赚钱的民生领域，担负起社会责任，扶持穷人的责任。在大陆，实体经济凋敝，也需要大量资本的进入，未来，香港富豪不能仅仅投资地产等赚钱行业，也需要投资赚钱一般般的行业，赚点苦钱，为全国经济复兴贡献力量，而不是没大钱就撤。</p>
<p>李嘉诚曾言，他的习惯，是“不赚尽最后一个铜板”，不仅如此，未来可能还不能光想赚“最大的铜板”。</p>
<p>二，稳定香港，担起商界领袖的责任。</p>
<p>李嘉诚是华人世界数十年的商界领袖，甚至可以说是华人历史上最强势的商界领袖。其存在对于香港的象征意义，无可替代。</p>
<p>所以，李嘉诚对于养育他的香港，应该负有巨大责任，当下香港动荡，造成各方困扰，急需定海神针。李嘉诚理应成为香港稳定的基石之一。部分撤退，部分坚守。不能将全部家产都转移出大陆和香港。</p>
<p>李嘉诚可以撤资，也可以一而再，再而三，但是不能秋风落叶，一扫而光。未来其在大陆，在香港，都应该留下标志性的财富与物业，刷好存在感。不能一走了之。见风就走非商界领袖之所为。若李嘉诚执意要走，恐数十年声望，将毁于一旦。若有所舍，有所留，虽牺牲部分利益，亦可保全声望，对各方有所交代，可谓两全。</p>
<p>其三是，必须要做更多善事，经营“社会事业”。</p>
<p>经营企业，为商人本职，但是，在中国，尤其需要“经营社会“，这种经营社会，不是简单的勾搭官府，搞好政商关系，而是切实对于社会广泛领域的事务，做出贡献。如教育，社会保障，扶贫，科研等等。</p>
<p>香港富豪陈宗启一下就捐款3.5亿美元给哈佛大学，虽然捐款自由，但是，对比邵逸夫先生，可以看出一些奥妙，邵逸夫先生一生的财富，相对香港顶尖富豪来说，其实并不多，但是其名望高，地位尊崇，无它，舍得付出。国内遍布的逸夫楼，体现了其对于大陆教育的拳拳赤子之心。</p>
<p>虽然中国官方的钱财使用方法和过程，确实存在一些弊端，但是，这不能成为将“宁与友邦，不与家乡”的借口。未来香港富豪，需要加大在中国的社会事业投入，不仅做一个经营商业出色的企业家，还要做经营社会出色的社会贤达。未来李嘉诚人走了，社会事业仍需继续。</p>
<h4 id="转载：李嘉诚自述兼回应（2017年10月19日）"><a href="#转载：李嘉诚自述兼回应（2017年10月19日）" class="headerlink" title="转载：李嘉诚自述兼回应（2017年10月19日）"></a>转载：李嘉诚自述兼回应（2017年10月19日）</h4><p>在职业上，我是一个纯粹的商人，不要用那些空洞的道德来衡量我。很多时候，我的选择，是因我没有其他更好的选择。但我在最艰难的被动选择里，选择了相对较好的结果。回到当年，我选择与官方进行合作，官方在政治上同样获得了巨大的回报，这依旧是一门生意，风险和利益同在且巨大。在本质上，我们可以相互感恩，但是互不相欠，这就是生意。</p>
<p>我是一个商人，希望大家不要给我戴上什么帽子，无论高的，还是矮的，我都不想有。因为我不是道德家、教育家、更不是什么阴谋家、政治家，我仅仅就是一个商人而已。了解这一点，你就很容易读懂我的自我辩护。</p>
<p>很多时候，我的选择，是因为我没有其他更好的选择，不是因为我想进行这样的艰难选择。</p>
<p>1928年我出生在中国广东潮州，出生时没有什么特殊的异象，预示我以后成为一个伟大的企业家，或者是一名出色的奸商。目前各种关于我的各种传记，绝大多数是基于文学演绎的穿凿附会，你们都不要信。如果我可以选择我的出生，我宁愿出生在富庶和平的国家。</p>
<p>和多数普通潮汕人一样，父亲安排我祭拜孔子儒学，进入观海寺小学念书，读的是一些传统爱国爱家的思想书籍。我成绩既不优秀，也不很差，我就是一个普通的孩子，放在街头，站在村口，和其他人没有什么异样。</p>
<p>如果没有战争，或者我就留在潮州，不会来香港，那么我可能度过平庸的一生，也或者过早死于战火，或者过早死于饥荒和疾病。当然，也可能侥幸度过这些劫难，现在潮州的某一个街道或村庄，悠闲地踱着步伐，没有被批判，也没有鲜花和掌声。当然，很可能比现在贫穷很多，但不一定就不如现在幸福。</p>
<p>因为日本侵华，我逃到了香港。同时因为后来的中国内战，我留在了香港没有返回潮州，我的故事因此开启，人生被彻底改变。请注意这个关键点，这些并不是我想要的，不是我主动选择的，我也被时代的大潮裹挟到了香港，不是荣耀的移民，而是逃离的难民。我到世界其他地方可能是为了经商和学习，但是我回到潮州故里访亲，纯粹是寻找一份家的感觉。</p>
<p>有一些东西不是我想要的，也不是我主动能选择的，这一点很重要。这就是我的命运，我的人生。</p>
<p>但是我在最艰难的被动选择里，选择了相对较好的结果，这是我的成功之处。</p>
<p>如果人生可以重来，我宁愿不要这些艰难的选择。我希望我的孩子们、我的同事们、甚至每一个中国人，都能有主动选择的余地，从容安排他们的人生，不像我李嘉诚。</p>
<p>我从普通的学徒、店员、街头推销员一步一步做起来的，直到塑料花厂的总经理。在其中我积累了不少经验，那段时间虽然过得非常辛苦，但是非常充实而快乐。我早早失学，没有读过太多的书，但是社会就是最好的学堂。</p>
<p>我一直在学习，没有停止过，直到现在。我充分理解失学的痛苦，所以后来援建了汕头大学。如果我能选择，我愿意坐在汕头大学的课堂，而不是香港的写字楼里。</p>
<p>我也不是白手起家，我创业的时候得到妻子家族的帮助，这一点我从不讳言。不要把我打扮成白手起家的商业之神，我感谢在我创业之初支持和帮助我的所有人。不过我并不是什么富二代、也没有去吃软饭，我最终靠的是自己的能力，还有天时和运气。网上流传的白手起家和完全靠朋友支持的两个极端，都非事实。</p>
<p>上个世纪五六十年代，香港的来料加工业兴起，欧美的生产转移到香港，这是我的机会。现在回头看来，我成为所谓的“塑胶花大王”，并不是因为我多厉害，只是顺应了时势而已。即使没有我，也有其他人能够享有此名。事实上，我只是“塑胶花大王之一”，擅自称王，是对其他成功同行的不敬。</p>
<p>真正困难的第一次抉择，来自1967年香港的左派闹事，导致香港的房地产一落千丈，那时候我的损失也很大。这时候有一些人卖掉了房子和土地，离开了香港。而我认为香港终将度过这些风波，于是买进了不少土地。</p>
<p>很多人认为我有眼光、低价收购土地储备。其实没有人关心我暗地里的担忧，私底下的恐慌。如果左派闹事成功，我将一文不名，甚至成为资本家的反面典型，在香港跳楼的名单中，就有我的名字，而不是在福布斯富豪榜上。</p>
<p>在这个过程中，风险和利益都是巨大的，也是均沾的，我不认为这有什么道德准则和商业原则的错误。它就是一桩生意而已，可能赚，也可能亏，而且是如履薄冰、如临深渊的高风险生意。任何过度的解读都是阴谋论，都是事后诸葛亮。</p>
<p>其后从我们长江实业的上市，到购入老牌英资商行“和记黄埔”的部分股权，都是地地道道的生意。</p>
<p>有钱赚是生意人的根本价值，做生意要遵从双方互惠互利的基本原则，当年购买我们股票的股民们也都有丰厚的利润。虽然因为缘分我心怀感恩，但本质上是合法、合理的，相互都不需介怀什么。</p>
<p>说得比较远了，我说一下现在网上各种对我的指责，说我忘恩负义，唯我是利，占了便宜之后转移资产到欧洲，面对经济危机不是承担责任而是全面撤资、影响到中国的面子和信心，并高呼“别让李嘉诚跑了”。甚至说香港目前的经济停滞困难，是我们这些“豪族”畸形的经济手法导致的。</p>
<p>我想写这类文章和赞成这些观点的，也是抱持善意，他们爱国爱民的心我能理解。但是他们不懂起码的商业原则，以及市场经济的运作真相，甚至于，他们不懂真正的人性。</p>
<p>让我们回到上个世纪70年代末文革结束、90年代初重启改革、97年香港回归之际，香港的社会波诡云谲，各种传言甚嚣尘上，对是否改革开放、是否会回到文革、是否会全面实现市场经济、是否保持一国两制等重大问题，抱有疑虑的非常多。</p>
<p>在每一个政治关键的节点，都有大量的动摇者裹足不前，甚至逃之夭夭。每一个人都面对这些艰难的选择。</p>
<p>我只是一个商人，在每一个关键节点的选择上，我认为风险与利益同在，和很多人判断不同。于是我在大陆遍地投资，港口、地产、金融、科技等领域都有涉及。指责我的文章说我与官方走的很近，利用了权力资源。这是典型的事后判断。</p>
<p>回到当年，我选择与官方进行合作，官方在政治上同样获得了巨大的回报，这本质上依旧是一门生意，尤其是风险和利益同在且巨大的生意。</p>
<p>我感谢当时的官方和政府，我也帮助了他们，带来了急需的资金、技术和人才，让香港乃至全球商界对中国更有信心。在本质上，我们可以相互感恩，但是互不相欠，这就是生意。</p>
<p>中国经济整体依旧是向好的，这个我肯定。13亿的人口和960万平方公里的土地，机会肯定是无限的。但是经过了这么多年的高速增长，以及信贷过度，已经来到了一个峰值，下一步会怎么样，我也不会贸然下结论，但具有较大的不确定性。</p>
<p>商人的首要目标是让资本更安全，其次才是增值更快。我当年大举投资大陆和现在全球布局，时间点不一样，考虑的自然不一样，但都是基于这样的考虑。除此以外，没有其他原因。就是现在，我在大陆依旧还有不少投资。</p>
<p>如《别让李嘉诚跑了》一文所说，1967年、70年代末、90年代初、97年香港回归这些重要的节点，我的选择正确，因而获得了巨大的利益。</p>
<p>但事实上，正常的商业是不需要经过这种政治选择的，而是相对纯粹的经济考量。有正常的政治氛围和良好的商业环境，就不会存在谁跑不跑的问题。存在这个问题，恰恰就是问题的根源所在。</p>
<p>在职业上，我是一个纯粹的商人，不要用那些空洞的道德来衡量我。如果不能做一个成功的商人，那我的职业是失败的，人生也是残缺的。不赚钱的商人不是好商人，也没有资本利润去做善事。</p>
<p>很多人认为，商业赚了钱之后，应该回报社会。这个我是认同的。但是如何回报社会，这个分歧巨大。难道商人应该亏本，去补贴国家和政府吗？这显然是荒谬的。</p>
<p>我们回报社会，首要条件就是赢利、赚钱，这样才能回报人民。企业没有教导人民的责任和义务，宗教和教育才是。我们通过守法经营以身作则，同时用资本捐助学校来达到教育的目的，通过捐助贫民来达到扶助的目的。</p>
<p>如果我们亏钱，那什么都不可能去做。如果我直接去搞教育，一定比专业的大专院校来的差。这就是最好的商业，最好的教育。</p>
<p>香港需要寻找未来，大陆需要寻找未来，大中华区需要寻找未来，全世界都需要寻找未来，但是我需要寻找的只是利润。地产、金融可以，教育、科技也可以，对我来说，谁是趋势、谁利润更大才是我要考虑的，而不是空洞的政治考量和虚假的道德说教。</p>
<p>不要试图让商人去承担国家的政治责任，也不要试图用政治去影响商人的经营理念。上帝的归上帝，凯撒的归凯撒，商业的归商业，政治的归政治。我就是一个商人，会去努力理解政治，但是我绝不僭越政治，那是政治家们的事情。</p>
<p>我已是耄耋之年的人了，安全比利润对我来说更重要。我从来就不是大家说的是什么超人，我可能算是一个成功的商人，但我其实更是一个普通的人，甚至是一个老人。我希望我的人生能画上一个完美的句号，而不想在晚年再横生枝节。我也希望我的家人和我的商业在我故去之后，正常运转，得到良好的继承。</p>
<p>我最后反复强调一点，我是一个商人，也是一个慈善人士，但绝不是政治家、教育家等。我参与兴建汕头大学、汕头大学附属医院、潮州的安居工程等，前后达到150亿港元，且绝大多数都花在大中华区。这都是纯粹捐献，没有任何利益可图。这是我最引以为骄傲的所在。</p>
<p>能为家乡人做事，能为祖国尽一份力量，是我的荣幸。我只是可能用的钱多一点，但是和其他人的捐献一样，同是一份心意而已，不高什么，也不低什么。汕头大学的毕业典礼，我风雨无阻地前去参加，力所能及地以过来人说说一些人生经验，但绝没有任何姿态，那里纯粹是老师们的课堂。</p>
<p>我希望大家不要把我神化，也不要把我妖魔化，其实我像你们现在的同事，也像你邻居的老头而已。我和他们一样犯过错误，也和他们一样慈祥友爱。我承担了我的错误，也获得了我的荣耀，我的人生由我自己负责，你们每一个人同样也是。不要给我过多的褒扬，也没有必要泼给我很多脏水，虽然我不在意自己的感受，但是我在意你对你自己心灵的灼伤，以及毒化中国人脆弱的舆论环境。</p>
<p>我的生意或许部分不在中国，但是我的心一直在这里，根依旧扎在这里。我是潮汕人，也是香港人，还是中国人，也是加拿大籍，最终我们都是地球村的居民。</p>
<p>我爱我的家乡，我爱我的故乡，我爱我的祖国，我也爱我们共同居住的地球，我的爱真挚而深沉，和你一样。</p>
<p>李嘉诚不会跑，也不愿跑，更跑不了。这是我的真心话，也是我的誓言。</p>
]]></content>
      <categories>
        <category>Economy</category>
      </categories>
      <tags>
        <tag>Economy</tag>
      </tags>
  </entry>
  <entry>
    <title>政府、资本和未来</title>
    <url>/2022/02/02/%E6%94%BF%E5%BA%9C%E3%80%81%E8%B5%84%E6%9C%AC%E5%92%8C%E6%9C%AA%E6%9D%A5/</url>
    <content><![CDATA[<p>入冬以来疫情再起，我在家待着没事上网刷视频，从司马南频道上看了几段关于联想和通钢的评说，紧接着就刷到了马云系列。在蚂蚁上市前夕，马云在外滩峰会上带有个人情绪的谈了一些看法，我觉得此演讲充满了超级资本家的真情实感，颇具有启发性。另外，政府对此事的理解和后续行为也值得关注，所以将演讲内容记录于此。</p>
<a id="more"></a>

<p>政府创造了现有体制，现有体制催生了资本生长，现在资本已经成长为庞然大物，大到不能倒，大到产生了权威，一堆人争着叫爸爸。马云能将资本做的那么大，本身说明了在这种体制下，其认识的“正确性和先进性”，但从客观上讲，这隐含着一些难以言表但确实存在的问题。政府挥舞着那双缓慢、笨拙、看得见的手，无法解决同样由它创造出来的“宠儿”。第一是不舍得解决，只要听话，还会继续关照；第二是人家在这个体制下没什么错，还这么“优秀”，没有解决的理由；第三是解决它会引发的问题。</p>
<blockquote>
<p>2020年10月23-25日，中国金融四十人论坛（CF40）联合各组委会成员机构在上海召开第二届外滩金融峰会。峰会主题为“危与机：新格局下的新金融与新经济”。24日，马云以联合国数字合作高级别小组联合主席、联合国可持续发展目标倡导者的身份进行了演讲。</p>
</blockquote>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>没人扔炸弹，哪敢扔炸弹。向大家问好…</p>
<p>感谢大会的邀请，很高兴有这个机会和大家一起学习、交流和探讨。2013年，也是在上海，我来到上海陆家嘴金融峰会，发表了一通关于互联网金融的被称为异想天开的观点。七年过去了，今天我作为非官方的非专业人士，又来到了上海的外滩金融论坛，希望有一些观点，供大家思考。</p>
<p>其实今天要不要来讲，坦白来说，我很纠结。但是我想我们这批人，有一个东西是责无旁贷的，就是为未来思考的责任，因为这个世界虽然留给我们发展的机会很多，但是关键性的机会也就这一两次，现在就到了最关键的时刻。</p>
<p>所以我想来这里讲讲我自己的想法和一些看法。这是我们自己16年实践经验总结出来，加上有幸担任联合国数字合作高级别小组联合主席和联合国可持续发展目标倡导者期间，我跟全世界的学者、专家还有实践者经过了探讨和研究。</p>
<p>我想，我已经算是退休了，在这个非官方的论坛上，想畅所欲言一下，分享一些非专业人士的专业看法，所幸我发现，现在绝大部分专业人士已经不讲专业了。</p>
<p>有三个观点，仅供大家参考，可能不成熟，讲得不对，贻笑大方，但是大家姑且一听，觉得没道理，忘了就算了。</p>
<p>第一个观点，一直以来我们有一些思维上的惯性，比如总觉得要为了跟国际接轨，必须要做欧美发达国家有，而我们没有的所谓空白，要填补国内空白，把填补国内空白当作追求的目标。</p>
<p>我一直认为，在今天的形势下，“填补空白”这句话是有问题的，不是因为欧美的就是先进的，就是我们要去填补的。其实我们今天不应该刻意的去追求和哪个东西接轨，适应哪国的标准，填补哪个空白，今天我们要思考的是，如何和未来接轨，如何适应未来的标准，怎么样去弥补未来的空白，我们要想明白，未来是如何的，以及自己到底要做什么，然后再去看看别人怎么做，如果永远重复别人的语言，讨论别人设定的主题，我们不但会迷失现在，更会错失未来。</p>
<p>二战以后，世界需要恢复经济的繁荣，布雷登森林体系建立起来以后，对全球经济的推动是巨大的。后来亚洲金融风暴发生后，巴塞尔协议讲的风险控制，越来越受重视，到后来变成了一个风险控制的操作标准。现在的趋势是，越来越像是全世界只讲风险控制，不讲发展，很少去讲年轻人的机会、发展中国家的机会在哪里。</p>
<p>这其实也诞生了今天世界很多问题的根源。我们今天也看到巴塞尔协议本身也让欧洲的整体创新受到了很大的限制，比如在数字金融方面。</p>
<p><strong>巴塞尔协议，比较像一个老年人俱乐部，它要解决的是运转了几十年的金融体系老化的问题，欧洲那些老化的体制，系统极其复杂。但是中国的问题，我认为正好相反，不是金融系统性风险，因为中国金融基本上没有系统，中国实际上是“缺乏金融系统”的风险。</strong></p>
<p>中国的金融和其他刚成长起来的发展中国家一样，在金融业我们是青春少年，还没有成熟的生态系统，没有完全的流动起来。中国有很多大银行，更像是大江大河和血液的动脉，但是我们今天更需要湖泊、需要水塘，需要小溪小河，需要各种各样的沼泽地，缺少了这些生态系统，我们才会涝的时候涝死，旱的时候旱死。所以，今天我们国家是缺乏健康金融系统的风险，我们需要的是建设金融的健康系统。</p>
<p>不是金融系统性风险，这是两个完全不同的病，就像老年痴呆症和小儿麻痹症，看起来都一样，但其实是完全不同的病。如果小孩子吃了老年痴呆的药，不光会得老人的病，还有很多莫名其妙的病。</p>
<p>这个巴塞尔协议就是考虑系统老化、过度复杂的老年人的病，而我们要思考的是跟着老年人学什么？要知道老年人和年轻人关心的问题不同。年轻人城市关心的是有没有学校，老年人关心是有没有医院。</p>
<p>所以，今年世界的变化是非常神奇，非常快速的。我也很自豪的跟大家宣布，昨天晚上就在上海，我们决定了蚂蚁金服上市的定价。这个全人类有史以来最大的上市，在纽约城以外定价，这是第一次。在五年前甚至三年前，我们想都不敢想，但是奇迹就这么发生了。</p>
<p>第二，创新一定要付出代价，我们这代人必须有所担当。</p>
<p>习近平主席讲过“功成不必在我”，我理解这句话讲的是一种责任，讲的是为未来、为明天、为下一代去担当。今天世界的很多问题包括中国，都只能用创新去解决。但是真正的创新，一定是没有人带路的，一定需要有人担当的，因为创新一定会犯错误，问题不是怎么样不犯错误，而是犯了错误之后，能不能完善修正，坚持创新。做没有风险的创新，就是扼杀创新，这世界上没有无风险的创新。很多时候，把风险控制为零，这才是最大的风险。</p>
<p>当年的赤壁之战，我认为，曹操要把所有的船连起来，这就是中国也是全世界最早的航母的思想，但是一把火烧掉后，一千年来，中国人连想都不敢去想，一旦想到那把火，谁还想把船做大，谁还会有这种系统性思考？</p>
<p>七八年以前，我提过互联网金融这个概念，也在上海。而且我们一直强调，互联网金融必须有三个核心要素：第一是必须拥有丰富的数据；第二是必须基于丰富大数据下的风控技术；第三，必须拥有基于大数据的信用体系。</p>
<p>用这三个标准来衡量，就会看到P2P根本不是互联网金融，但是今天不能因为P2P，把整个互联网技术对金融的创新给否定了，其实我们想一想，中国怎么可能在几年以内就出现了几千家互联网金融公司？我们是不是应该检查一下，是什么原因诞生了几千家的互联网金融，所谓的P2P公司？今天我们的监管确实很难，全球的监管都很难。</p>
<p>创新主要来自于市场，创新来自于基层，创新来自于年轻人。对监管的挑战越来越大，其实监和管是两回事，“监”是看着你发展，关注你发展。管是有问题的时候或是预判有问题的时候才去管，但是我们现在，管的能力越来越强，监的能力明显不足。</p>
<p>好的创新不怕监管，但是怕用昨天的方式去监管，我们不能用管理火车站的办法去管理飞机场，不能用昨天的办法来管未来。</p>
<p>“监”和“管”不一样，政策和文件也不一样。今天这个不许，那个不许，那都叫文件。政策是机制建设，是激励发展。今天全世界，特别是中国，需要很多的政策专家，而不是文件专家。</p>
<p>制订政策是一门技术活，其实解决系统性复杂的问题，我自己觉得，可以跟大家分享一下，我们淘宝是怎么做的。</p>
<p>17年以前，我们没有技术、没有数据，也对未来的判断不准确，我们制订了很多这个不许那个不许的很多规则。但是今天，我们能够技术解决了，今天我们有能力解决这些系统性问题。但是，我们今天的年轻人，也像监管一样，总是喜欢出各种各样新的文件，不允许这样，也不允许那样。后来我想出一个办法，叫“加一减三”，你要加一条规则，必须要减掉前面三条规则。这样我们的文件就越来越短，如果说你不减，那你的规章制度越来越厚，是逼迫每个人去犯法，每个人去犯错，大家自己都糊涂起来。</p>
<p>理论和系统也是不一样的，专家和学者是不一样的，我们这个国家，把很多学者和专家都混为一谈。专家是干出来的，他干得很厉害，但不一定会总结。</p>
<p>很多学者，自己不具体干，但是能从别人实干的经验中总结出理论。我认为只有专家和学者结合起来，才能把理论和实践结合起来，才能真正去创新、解决今天和明天的问题。我想，我们需要来自于实践的理论，不是来自于办公室理论的实践。</p>
<p>P2P很多就是来自于办公室理论的实践，我想，更应该认为，今天我们正确理解P2P给我们带来的巨大教训，我们不是要去否定互联网技术，更不要重复办公室理论的实践。</p>
<p>我觉得还有一个现象，全球很多监管部门，监管到后面，自己变成了没有风险，自己的部门没有风险，但是整个经济有风险，整个社会变成了有风险。未来的比赛是创新的比赛，不是监管技能的比赛。现在各国一个比一个狠，发展都是空的，但是不许这样干，都是刀刀见血。</p>
<p>我的理解，习主席说的提升执政能力，是指在监管有序的下面保持健康可持续的发展，而不是监管了就没有发展。监管其实不难，难的是监管的目的是为了可持续的健康发展，监管就是为了健康的发展。</p>
<p>第三个观点，金融的本质是信用管理。我们必须改掉今天金融的当铺思想，要依靠信用体系的发展。</p>
<p>今天的银行，延续的还是当铺思想。抵押和担保就是当铺。这在当年，是很先进的，没有抵押，担保这些创新，就不可能有今天的金融机构，中国经济40年来的发展也不可能发展到现在。</p>
<p>但是靠资产和抵押的资质会走向极端。我是中国企业俱乐部的主席，也是浙商总会的会长，我这几年跟很多企业家交流，中国的金融当铺思想非常严重，也影响了很多企业家。尤其企业家要把资产全押了出去，压力非常大，压力大了以后，动作就变形。</p>
<p>还有一些人，肆无忌惮地贷款，不断加杠杆，负债搞的越来越大。大家都知道，借10万块，你怕银行；借1000万，你和银行都有点慌；借10个亿，银行怕你。还有一个习惯，银行喜欢给好企业、不需要钱的企业贷款，拼命的贷款。结果让很多好企业变成了坏企业，形成了多元化的投资，形成了甚至把这个钱转出去做完全不符合自己的事，钱太多也惹很多事。</p>
<p>抵押的当铺思想，是不可能支持未来30年世界发展对金融的需求的。我们必须用借助今天的技术能力，用大数据为基础的信用体系，来取代当铺思想，这个信用体系不是建立在传统的IT基础上，不是建立在熟人关系的社会基础上，而是<strong>必须是建立在大数据的基础上</strong>，才能真正让信用等于财富。其实要饭的也要有信用，没有信用，连要饭都要不上。我认为每个要饭的人都是（要）有信用的。</p>
<p>最后我想今天的世界，迫切期待一个真正为未来而思考的全新的金融体系。</p>
<p>今天的金融体系是工业时代的产物，是为了解决工业化而设置的全面的金融体系，是为了完成二八理论。什么叫二八理论？就是投资20%，来解决80%的问题。而未来的金融体系，是要解决八二理论，帮助80%的小企业和年轻人来带动20%的人。要从过去的人找钱、企业找钱，到转型为钱找人、钱找企业，钱找好企业。评价这个体系的唯一的标准就是是否普惠、包容、绿色和可持续，背后的大数据、云计算、和区块链等前沿技术，今天能够担当起巨大的责任。</p>
<p>各位，即使在二战以后，当时的人们没有这样的远见，为后代为未来设计一个很好的金融体系，我们今天有这个责任和思考，为去建立一个真正属于未来，属于年轻人和下一代，属于这个时代的金融体系。今天我们不是做不到，而是不去做。今天我们的技术发展让我们完全可以做到这一些，遗憾的是，很多人不愿意去做。</p>
<p>今天全球的金融体系必须改革，不然不仅仅是失去机会的问题，而是让全世界可能会陷入更多的混乱。<strong>创新走在监管前面是正常的，但是当创新远远地走在监管前面的时候，当创新的丰富度和深度远远超过监管的想象的时候，就不正常了，社会和世界就会陷入混乱。</strong></p>
<p>拿数字货币来说，如果用未来的眼光打造30年以后世界所需的金融体系，数字货币可能是非常重要的核心。今天的金融确实不需要数字货币，但是明天需要，未来需要，成千上万的发展中国家和年轻人需要，我们应该问自己，数字货币到底要解决未来的什么实际问题？</p>
<p>十年以后的数字货币和今天的数字货币，可能根本就不是一回事，这个数字货币不应该从历史上去找，不应该从监管的角度去找，不应该从研究机构去找，而是从市场去找，从需求去找，从未来去找。这件事事关重大，我们的研究机构不应该是政策机构。政策机构也不能仅仅依赖于自己的研究机构。因为数字货币体系是一个技术问题，但又不仅仅是技术问题，更是一个解决未来问题的方案，数字货币可能重新定义货币，尽管货币的主要功能仍然在，但是它一定会重新定义货币，就像苹果手机重新定义了手机，打电话只是其中的一个功能。数字货币今天远远没有到抢标准的时候，是创造价值的时候，是需要思考如何通过数字货币，建立新型的金融体系，为全世界思考未来，思考全球的贸易怎么做，更要思考这世界上应该要有经得起考验的技术的基础上，所建立的数字货币。是要真正解决世界贸易可持续、绿色和普惠的问题。</p>
<p>所以，最后我想说，今天人类社会到了最关键的时刻，千万不要小看这场疫情，这场疫情是倒逼人类社会进步的力量，它不亚于二战。</p>
<p>从金融本身来说，从美国不断地向世界各国，特别是向华尔街不断输入大量现金，各国都在跟随其后，大家想过后面的结果会怎么样没有，它所带来的巨大的影响，远远超过我们今天很多人讨论的技术层面的问题。</p>
<p>我们今天对世界上很多的组织机构，不要简单的去反对它，而是一起重新思考它们今天的价值，无论是联合国，WTO，还是 WHO，这些组织确实存在着很多问题。这些组织我都工作过，打过交道，有过合作，但是消灭这些组织并不解决问题，我们应该考虑这些组织应该如何面向未来，如何改革，如何重新思考定位。</p>
<p>新金融体系是未来的方向，不管我们高兴不高兴，它一定会起来，不管我们做不做，一定会有人去做。未来，我相信，改革是要付出牺牲的，是要付出代价的，我们这一代人要做这样的改革，可能下一代人才能看到，我们可能是负重前行的一个人，这是历史的机遇，也是历史的责任。过去16年，蚂蚁金服一直围绕着绿色、可持续和普惠发展。如果绿色、可持续和普惠包容的金融是错误的话，我们将会一错再错，一错到底。</p>
]]></content>
      <categories>
        <category>Economy</category>
      </categories>
      <tags>
        <tag>Economy</tag>
      </tags>
  </entry>
  <entry>
    <title>真正使用Linux</title>
    <url>/2021/08/28/%E7%9C%9F%E6%AD%A3%E4%BD%BF%E7%94%A8Linux/</url>
    <content><![CDATA[<p>之前总想尝试一下Linux，选用Debain发行版，在VMware上安装过几次，基本上安装后就没下文了。这次所谓的“真正”使用也不是因为工作需要，只不过有一台老旧笔记本闲置，扔掉可惜不如换个系统发挥余热。</p>
<p>当前Ubuntu最新版本为21.04，我那台老爷机肯定跑不动，首先CPU就不支持64位，而且内存只有2G。通过上网查询，最后选择Ubuntu 16.04LTS(Xenial Xerus)的32位版本，光盘镜像为ubuntu-16.04.6-desktop-i386.iso。</p>
<a id="more"></a>

<p>Ubuntu相对于Debain对中文支持较好，安装过程跟Windows差不多，基本上能做到无人值守。如果是在虚拟机上安装系统，还需要安装VMware Tools，步骤如下：</p>
<ol>
<li>点击VMware菜单“虚拟机-&gt;安装VMware Tools”。虚拟机会自动以光盘形式将VMware Tools加载到ubuntu。</li>
<li>双击光盘内tar.gz压缩包，将vwware-tools-distrib提取到家目录。按压CTRL+ALT+T打开终端，<code>cd vwware-tools-distrib</code>进入目录后<code>sudo ./vmware-install.pl</code>。</li>
<li>如果提示找不到命令，则键入：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">chmod +x vmware-install.pl <span class="comment">#设置文件权限为可执行</span></span><br><span class="line">sudo ./vmware-install.pl   <span class="comment">#安装完成后，键入su - username返回普通用户</span></span><br></pre></td></tr></table></figure>
<h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><p>在操作系统安装过程中，没有设置root密码。Ubuntu默认root密码是随机的，每次开机都会有一个新的root密码。如果想要设置一个固定的root密码，按下Ctrl+Alt+T调出终端，键入<code>sudo passwd root</code>，然后输入当前用户的密码，终端会提示输入root密码。修改成功后测试，键入<code>su root</code>，再输入刚设置的密码即可看到#。</p>
<p>Ubuntu的“系统设置”（齿轮图标）汇总了全部基本功能，下面介绍一些设置：</p>
<ol>
<li>亮度和锁屏：设置无操作关闭屏幕时间，唤醒后是否需要输入密码。</li>
<li>外观：设置桌面壁纸，启动器是否隐藏，窗口菜单位置。</li>
<li>软件和更新：可以关闭自动更新。</li>
</ol>
<p>如果想要将启动器移到屏幕下方，在终端键入<code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom</code>。如果想要还原到左侧，同样输入上述命令，须将末尾的bottom替换为left。</p>
<p>Ubuntu没有宋体、微软雅黑等字体，安装方法如下：</p>
<ol>
<li>在Windows系统下，从C:\Windows\Fonts目录将所需的字体复制出来，或者从网上下载字体。</li>
<li>在Ubuntu系统下，打开终端安装微软核心字库：<code>sudo apt-get install ttf-mscorefonts-installer</code>，出现向导后，按Tab键选中按钮方可确认。然后安装字体设置工具：<code>sudo apt-get install fontconfig</code>。</li>
<li>进入/usr/share/fonts/目录，通过终端建立目录<code>sudo mkdir myfonts</code>。将下载好的字体放到这个目录<code>sudo cp ~/font/* ./myfonts/</code>。</li>
<li>修改字体文件的权限，使得一般用户可以访问<code>sudo chmod -R 755 myfonts</code>。</li>
<li>建立字体缓存，在终端键入<code>sudo mkfontscale</code>和<code>sudo mkfontdir</code>。以后每当需要新字体，只需将字体文件放入myfonts目录，再次运行这个两个命令。</li>
</ol>
<p>我的设置就这么多，其他方面都默认了。无论安装的是哪个发行版本，总归是Linux系统——以黑屏命令行为基础，在其上运行个桌面程序。从本质上Linux就不是为了好看或用户体验而生的，后天再怎么美化也不会有根本上的改变。所以，我觉得还是不要花费力气勉强Linux做它不擅长的事情，就怕一顿折腾，没好看多少，影响了系统性能。当前，Linux各大发行版所需系统配置可不比Windows低。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Linux以/为根目录，其下的目录分别有不同的用途：</p>
<ul>
<li>bin   存放基本命令程序</li>
<li>boot  存放系统启动文件</li>
<li>etc   存放配置文件，包括用户信息、密码信息、群组信息等</li>
<li>home  家目录，用户主要使用这个目录</li>
<li>lib   存放库文件</li>
<li>opt   可选的意思，有些软件会安装到这里</li>
<li>proc  进程信息与内核信息</li>
<li>sys   系统目录，存放硬件信息</li>
<li>run   运行目录，比如进程的PID文件</li>
<li>srv   服务目录，本地服务相关文件</li>
<li>sbin  存放系统管理命令程序，所有命令需要root权限</li>
<li>var   动态数据，比如系统和软件运行日志</li>
<li>usr   存放应用程序</li>
</ul>
<p>关于目录的一些符号：</p>
<ul>
<li>. 此层目录</li>
<li>.. 上一层目录</li>
<li>- 前一个工作目录</li>
<li>~ 当前用户家目录</li>
</ul>
<blockquote>
<p>查看硬盘空间的方法：在终端键入<code>df -h</code>，或者在“系统监视器”的“文件系统”属性页中查看。</p>
</blockquote>
<p>Linux系统的特点是万物皆文件，文件的内容基于字符，C语言就是字符处理机。使用任何Linux发行版离不开命令行，输入命令需要调出终端，其快捷键为CTRL+ALT+T，下面介绍一些常用命令：</p>
<p>一、账户管理<br>/etc/passwd 用于保存账户信息，每一行代表一个账号；/etc/shadow 用于保存密码信息（加密过的）；/etc/group 用于保存群组信息。相关命令如下：</p>
<ul>
<li>useradd   添加账户，-g指定初始群组，-G指定次要群组，-M不建立家目录，-m建立家目录，-r建立一个系统账号（不建立家目录），例如：<code>useradd -r name</code></li>
<li>passwd    启用账户并设定密码，-l锁定账户，-u解锁账户，-n多久不可修改密码，-x多久必须修改密码，-i密码失效日期，例如：<code>passwd name</code>，<code>passwd -l name</code>，<code>passwd -x 15 name</code></li>
<li>usermod   修改账户，可以直接修改/etc/passwd或/etc/shadow文件，-d后接家目录，-l后接账号名称，例如：<code>usermod -l newname oldname</code></li>
<li>userdel   删除账户，-r连同家目录一同删除，<code>userdel -r name</code></li>
<li>groupadd  添加群组，-r建立系统群组，例如：<code>groupadd gname</code></li>
<li>groupmod  修改群组，-n修改组名，例如：<code>groupmod -n newgname oldgname</code></li>
<li>groupdel  删除群组，例如：<code>groupdel gname</code></li>
<li>su        切换账户，例如：<code>su - name</code>，可由一般用户切换到root，但需要root密码。</li>
<li>sudo      以root权限执行命令，例如：<code>sudo su</code></li>
</ul>
<blockquote>
<p>/etc/sudoers 用来保存一些用户，使这些用户可以通过sudo命令来暂时获得root权限。这些用户使用sudo时输入的密码是当前用户密码，而不是root密码。</p>
</blockquote>
<p>二、文件目录<br>当前，大多数使用Linux系统的用户都会安装桌面系统，通过鼠标对文件和目录进行各种操作更加符合人类习惯，毕竟所见即所得嘛。但有些特殊情况还需要使用命令，在这里简单说明一下：</p>
<ul>
<li>cd    变换目录，例如：<code>cd /home/cracker/opt/</code>，<code>cd ./opt/1</code></li>
<li>pwd   目前所在目录，例如：<code>pwd</code></li>
<li>mkdir 新建目录，-p为建立多层目录，-m为目录设置权限，例如：<code>mkdir a</code>，更复杂的<code>mkdir -m 711 -p a/b/c/d</code>。</li>
<li>rmdir 删除空目录，-p为删除多层目录，例如：<code>rmdir a</code>，<code>rmdir -p a/b</code>。</li>
<li>cp    将源文件复制到目标文件，例如：<code>cp -i ~/1 ~/opt/2</code>，将文件1复制到/opt并命名为2，-i为文件重复时询问是否覆盖。</li>
<li>rm    删除目录或文件，-r为递归删除，例如：<code>rm -r a</code>。</li>
<li>mv    移动目录或文件到指定位置，例如：<code>mv 2 a</code>，将文件2移入目录a。</li>
</ul>
<blockquote>
<p>Linux跟Windows一样也有环境变量的概念，能直接使用的命令都设定到PATH。</p>
</blockquote>
<p>三、文件权限<br>这个太重要了，权限是Linux系统的一大特性，目前还是通过命令设置较为直观。<code>ls -al</code>命令可以查看当前目录所有文件和子目录的权限，如图：</p>
<p><img src="https://i.loli.net/2021/09/23/3lvBmYENLI9MkD1.png" alt="1ls-al.PNG"></p>
<p>第一列内容就是权限，其意义如下图所示：</p>
<p><img src="https://i.loli.net/2021/10/03/NC4qTMt3Gbn8gzL.png" alt="2权限.png"></p>
<blockquote>
<p>目录的x权限指的是能否进入此目录，目录的w权限指的是使用者可以无视其中文件的权限而删除它。</p>
</blockquote>
<p>第三列内容为拥有者，第四列为群组。群组可根据分工建立，方便不同开发组管控自己团队的文件。修改权限的命令如下：</p>
<ul>
<li>chgrp 改变群组，-r递归改变，例如：<code>chgrp 群组名 filename</code></li>
<li>chown 改变拥有者，-r递归改变，例如：<code>chown 账户名 filename</code></li>
<li>chmod 改变权限，-r递归改变，数字方式：<code>chmod 777 filename</code>；符号方式：u用户、g群组、o其他、a全部，+添加、-除去、=设定，例如：<code>chmod u=rwx,go=rx filename</code></li>
</ul>
<h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><p>安装Ubuntu软件中心里的软件很容易，就跟在手机商城中安装软件一样，自动下载自动安装。但是目前软件中心里只有一些传统Linux生态的软件，例如Emacs、VLC播放器等。如果想要正常办公，仍旧需要单独下载安装包。</p>
<p>选择32位版本的Linux系统给安装软件带来了一些麻烦，必须选择名字只带有x86的安装包，x86_64的往往不行。安装软件通常需要root权限，所以在“安装命令”前添加sudo。</p>
<p>通常的软件安装路径为/usr、/usr/local/、/opt，尽量不要安装到家目录下。如果软件安装后，当前目录带有锁头标志，会给将来安装插件带来麻烦，可以通过<code>sudo chmod -R 777 dirname</code>命令添加权限。</p>
<p>一、Foxit Reader<br>直接到官方网站<a href="https://www.foxitsoftware.cn/pdf-reader/?agent=foxit&amp;MD=syts">https://www.foxitsoftware.cn/pdf-reader/?agent=foxit&amp;MD=syts</a>下载32位Linux版本的run包。安装这种包很容易，直接双击即可。如果软件厂商都这样做，使用Linux的人应该更多。</p>
<p>二、DrRacket</p>
<ol>
<li>在官方网站<a href="https://download.racket-lang.org/all-versions.html">https://download.racket-lang.org/all-versions.html</a>下载7.3版本，racket-7.3-i386-linux.sh是支持32位Linux的最后版本。</li>
<li>在终端键入<code>sudo sh /home/cracker/下载/racket-7.3-i386-linux.sh</code>。选择no，路径默认即可。</li>
<li>在终端进入racket目录，执行drracket即可打开程序。</li>
</ol>
<p>三、Anconda3</p>
<ol>
<li>在<a href="https://repo.anaconda.com/archive/">https://repo.anaconda.com/archive/</a>下载Anaconda3-5.3.0-Linux-x86.sh（527M，2018-09-27）。</li>
<li>打开终端，键入<code>sudo sh /home/cracker/下载/Anaconda3-5.3.0-Linux-x86.sh</code>回车，阅读许可后yes，默认安装路径为<code>/home/cracker/anaconda3</code>回车，程序开始安装。完成后，安装环境变量yes，安装VSCode时no。</li>
<li>安装过程中已经添加了环境变量。在终端键入<code>python</code>进行测试，如果显示版本为2.7（ubuntu16.04再带python2.7），说明系统尚未识别，键入<code>source ~/.bashrc</code>更新环境变量即可。Anaconda3-5.3.0自带的python版本为3.7.0。</li>
<li>在终端中输入<code>ipython notebook</code>，启动Jupyter notebook，首页显示的是HOME目录。</li>
<li>选择路径新建文件，编写代码后Shift+Enter执行，点击软盘图标保存文件，回到首页点击右上角Quit按钮退出程序。</li>
</ol>
<p>安装python插件：</p>
<ol>
<li>先要更新pip，在终端键入<code>pip install --upgrade pip</code>。</li>
<li>安装pyecharts，在终端键入<code>pip install pyecharts</code>，会报<code>twisted 18.7.0 requires PyHamcrest&gt;=1.9.0, which is not installed.</code>错误，键入命令<code>pip install PyHamcrest</code>即可解决。</li>
<li>安装Flask，在终端键入<code>pip install Flask</code>。</li>
</ol>
<p>四、JDK9<br>安装pycharm之前，需要安装JDK，从JAVA10开始就没有32位版本的JDK了，所以只能安装JDK9，步骤如下：</p>
<ol>
<li>在终端中键入<code>javac</code>，查看需要安装的软件名，这里安装JDK9，键入命令<code>sudo apt install openjdk-9-jdk-headless</code>，输入y继续。</li>
<li>安装完成后，需要添加环境变量，在终端中键入<code>sudo gedit /etc/profile</code>。在文件开头的注释后代码前输入：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-9-openjdk-i386 <span class="comment">#文件安装路径，会在安装过程中显示</span></span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li>
<li>在终端键入<code>source /etc/profile</code>让修改的文件生效，键入<code>javac</code>测试结果。</li>
</ol>
<p>五、Pycharm</p>
<ol>
<li>在<a href="https://www.jetbrains.com/pycharm/download/other.html">https://www.jetbrains.com/pycharm/download/other.html</a>下载2019.1带有anaconda插件的版本。2020以后的版本需要JAVA11，所以无法安装。</li>
<li>将下载的压缩包解压到/opt目录，键入<code>sudo sh /opt/pycharm-anaconda-2019.1.4/bin/pytcharm.sh</code>启动程序。</li>
<li>专业版需要激活，当前不太好破解。</li>
<li>设置python解释器，选择/anaconda3/bin/python3.7（蓝色问号图标）。</li>
<li>关闭自动更新，点击菜单File-&gt;Settings，在左侧树状目录中选择System Settings-&gt;Updates，去掉勾选。</li>
</ol>
<p>六、有道翻译</p>
<ol>
<li>从官方网站<a href="http://cidian.youdao.com/index-linux.html">http://cidian.youdao.com/index-linux.html</a>下载32位程序，是个deb包。</li>
<li>在终端中键入<code>sudo dpkg -i deb路径</code>，可能会报dpkg加锁，使用如下命令解决：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock  <span class="comment">#rm后可加-rf</span></span><br></pre></td></tr></table></figure></li>
<li>重启后再次键入<code>sudo dpkg -i deb路径</code>，会报缺少依赖包，紧跟安装命令键入<code>sudo apt-get -f install</code>，系统会根据依赖关系树自动安装依赖包。</li>
<li>通过搜索找到有道词典，启动程序后点击左下角图标进行设置。</li>
</ol>
<p>七、QT Creator</p>
<ol>
<li>在官方网站注册账户，安装程序时要用。</li>
<li>从官方网站<a href="https://download.qt.io/archive/qt/">https://download.qt.io/archive/qt/</a>下载Linux32位安装包qt-linux-opensource-5.1.0-x86-offline.run。</li>
<li>直接运行不了上述.run安装包，在终端中键入<code>sudo chmod +x qt-opensource-linux-5.1.0-x86-offline.run</code>，双击run进入向导。选择安装路径到/opt，一直下一步即可。</li>
</ol>
<p>打开程序会报Help插件错误，因为QT帮助是采用流媒体方式加载的，尝试安装流媒体库文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libgstreamer0.10-dev</span><br><span class="line">sudo apt-get install libgstreamer-plugins-base0.10-dev</span><br></pre></td></tr></table></figure>
<p>新建一个默认gui程序，会报cannot find -lGL错误，在终端中键入<code>sudo apt-get install libqt4-dev</code>即可解决。</p>
<p>八、安装VScode</p>
<ol>
<li>在终端键入<code>sudo apt-get install ubuntu-make</code>安装umake工具。</li>
<li>安装VScode在终端键入<code>umake ide visual-studio-code</code>。</li>
<li>在终端家目录下键入<code>cd ./.local/share/umake/ide/visual-studio-code/bin/</code>进入目录，运行<code>code</code>。</li>
<li>设置字体为Ubuntu Mono，字号为18。安装chinese插件。</li>
<li>卸载程序在终端键入<code>umake ide visual-studio-code  --remove</code>。</li>
</ol>
<p>九、TexLive</p>
<ol>
<li>在终端键入<code>sudo apt-get install texlive-full</code>安装程序，大约3G。如果使用官方源，安装过程比较漫长。以我的经验，从中午开始下载速度较快。</li>
<li>安装完成后，可能会提示有几个安装包无法下载，此时按照提示在终端键入<code>sudo apt-get update</code>，或者<code>sudo apt-get update --fix-missing</code>，然后再次键入<code>sudo apt-get install texlive-full</code>安装程序直到成功。</li>
<li>在终端键入<code>tex --version</code>，如果安装成功会显示Primary author of TeX: D.E.Knuth。</li>
<li>我使用VScode编辑文本。先安装LaTeX Workshop插件，然后进入“设置”，搜索并点击settings.json。在settings.json中加入配置信息，具体内容参考另一篇文章——“LaTex排版一 概述”。</li>
<li>编辑文本前，选择Latex语法高亮。完成编辑后，Ctrl+S即可编译出pdf文档（也可以点击右边栏中“TEX”，再点击Build LaTeX project进行编译）。</li>
</ol>
<p>十、Arduino</p>
<ol>
<li>从官方网站<a href="https://www.arduino.cc/en/donate/">https://www.arduino.cc/en/donate/</a>下载Linux32位安装包arduino-1.8.15-linux32.tar.xz。</li>
<li>将其解压到合适的目录，这个目录就是Arduino程序的目录。</li>
<li>在终端键入<code>sudo sh 路径/install.sh</code>安装。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>很多Linux书籍一上来就介绍一堆发展史，然后就是一堆命令，这是非常不符合实际使用情况的。对于一个刚接触某个操作系统的普通使用者，面对的实际问题是：如何安装操作系统、如何安装驱动、如何进行一些必要设置、如何安装常用软件。这一系列问题才是入门真正需要的知识。</p>
<p>我觉得正确的学习方法是：就像最开始接触Windows系统时那样，直接使用即可，遇到问题上网查基本都能自行解决。随着使用时间的增加，知识和经验就积累起来了，完全没必要先学完某本书再去使用。我估计所有学会Linux的人，没有一个是学完某本书再去使用的。</p>
<p>Ubuntu在安装系统和安装驱动这两点上做的比较好，基本上做到无人值守，并且自带各种驱动，无需用户费神。系统设置与智能手机类似，只要认识文字就能操作。安装软件还是有点麻烦的，但这不是Linux的错，其实Linux的软件安装机制挺好，只不过各大软硬件厂商不怎么配合。</p>
<p>我觉的Linux未来会朝着Android、MacOS方向走，当然我知道它们都源自于Linux，但是随着技术发展，社会环境更加接受那种设计理念。Linux不应该只局限于曾经的“哲学”，况且那些所谓的“哲学”大部分只是一些设计思想而已，被硬生生拔高到哲学层面的东西还有毒。</p>
<blockquote>
<p>试想一个修理工要去修理水管，有一把看似奇异的管钳子可供选择，传说只有“天才”才能使用它，并且得先学一本大典。试问，当前社会有几个人还有那个闲心折腾，毕竟目标在于把“水管”修好，况且会修水管也不是什么了不起的事。</p>
</blockquote>
<p>不过，Linux原则中有三点非常好，就是自由、开放、免费。这三点很接地气并能聚敛人气，是Linux保持长久活力的原因，在冥冥之中引导着Linux朝着正确的方向发展。</p>
]]></content>
      <categories>
        <category>PC</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
